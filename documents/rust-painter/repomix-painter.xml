This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
[examples]/
  ball/
    shader/
      src/
        lib.rs
      Cargo.toml
      fragment.spv
      manifest.json
      vertex.spv
    geom.rs
    main.rs
    texture.png
  base_effect/
    shader/
      src/
        lib.rs
      Cargo.toml
      main.spv
      manifest.json
    main.rs
  blur/
    shader/
      src/
        lib.rs
      blur_fs.spv
      Cargo.toml
      manifest.json
      triangle_fs.spv
      triangle_vs.spv
    main.rs
  deferred_light/
    shader/
      src/
        lib.rs
      Cargo.toml
      light_fs.spv
      manifest.json
      scene_fs.spv
      scene_vs.spv
    geom.rs
    main.rs
  dynamic_shapes/
    shader/
      src/
        lib.rs
      Cargo.toml
      effect_fragment.spv
      fragment.spv
      manifest.json
      vertex.spv
    main.rs
  dynamic_texture/
    shader/
      src/
        lib.rs
      Cargo.toml
      col_fs.spv
      manifest.json
      tex_fs.spv
    main.rs
  geometries/
    shader/
      src/
        lib.rs
      Cargo.toml
      ground_frag.spv
      ground_vert.spv
      manifest.json
    main.rs
  instances/
    shader/
      src/
        lib.rs
      Cargo.toml
      fragment.spv
      manifest.json
      vertex.spv
    main.rs
  layer_tex/
    shader/
      src/
        lib.rs
      Cargo.toml
      color_fs.spv
      color_vs.spv
      manifest.json
      texture_fs.spv
      texture_vs.spv
    main.rs
  mipmap/
    shader/
      src/
        lib.rs
      Cargo.toml
      image.spv
      manifest.json
      mip_sampling.spv
      wave_effect.spv
    main.rs
  mouse_color/
    main.rs
  noise_tests/
    shader/
      src/
        lib.rs
      Cargo.toml
      hash_shader.spv
      manifest.json
      simplex_2d_shader.spv
      simplex_3d_shader.spv
      simplex_4d_shader.spv
      tiling_noise_2d_shader.spv
      tiling_noise_3d_shader.spv
      tiling_simplex_shader.spv
    main.rs
  random_lines/
    shader/
      src/
        lib.rs
      Cargo.toml
      fragment.spv
      manifest.json
      vertex.spv
    main.rs
  render_to_mip/
    shader/
      src/
        lib.rs
      Cargo.toml
      image.spv
      manifest.json
      mip_sampling.spv
    main.rs
  shader_image/
    shader/
      src/
        lib.rs
      Cargo.toml
      main_fs.spv
      main_vs.spv
      manifest.json
    main.rs
    output.png
  simple_triangle/
    shader/
      src/
        lib.rs
      Cargo.toml
      fragment.spv
      manifest.json
      vertex.spv
    main.rs
  triangle/
    shader/
      src/
        lib.rs
      Cargo.toml
      fragment.spv
      manifest.json
      vertex.spv
    src/
      main.rs
    Cargo.toml
    texture.png
  user_event/
    shader/
      src/
        lib.rs
      Cargo.toml
      fragment.spv
      manifest.json
      vertex.spv
    main.rs

[trivalibs_painter]/
  src/
    utils/
      input_state.rs
      mod.rs
    app.rs
    bind_group.rs
    binding_constants.rs
    binding.rs
    effect.rs
    events.rs
    form.rs
    layer.rs
    lib.rs
    painter.rs
    pipeline.rs
    sampler.rs
    shade.rs
    shaders.rs
    shape.rs
    texture_utils.rs
    texture.rs
    window_dimensions.rs
  Cargo.toml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="ball/shader/src/lib.rs">
#![no_std]
#![allow(unexpected_cfgs)]

use spirv_std::glam::{vec4, Mat3A, Mat4, Vec2, Vec3, Vec4};
use spirv_std::{spirv, Image, Sampler};

#[spirv(vertex)]
pub fn vertex(
	position: Vec3,
	uv: Vec2,
	color: Vec3,
	normal: Vec3,
	#[spirv(uniform, descriptor_set = 0, binding = 0)] mvp_mat: &Mat4,
	#[spirv(uniform, descriptor_set = 0, binding = 1)] normal_mat: &Mat3A,
	// #[spirv(descriptor_set = 0, binding = 2)] light_dir: &Vec3,
	#[spirv(position)] clip_pos: &mut Vec4,
	out_uv: &mut Vec2,
	out_color: &mut Vec3,
	out_norm: &mut Vec3,
) {
	*out_uv = uv;
	*out_color = color;
	*out_norm = *normal_mat * normal;
	*clip_pos = *mvp_mat * position.extend(1.0);
}

#[spirv(fragment)]
pub fn fragment(
	in_uv: Vec2,
	in_color: Vec3,
	in_norm: Vec3,
	#[spirv(descriptor_set = 0, binding = 2)] sampler: &Sampler,
	#[spirv(descriptor_set = 1, binding = 0)] tex: &Image!(2D, type=f32, sampled),
	frag_color: &mut Vec4,
) {
	let col = tex.sample(*sampler, in_uv);
	*frag_color = in_color.extend(1.0) * in_norm.extend(1.0).abs() * vec4(col.x, col.y, col.z, 1.0);
}
</file>

<file path="ball/shader/Cargo.toml">
[package]
name = "ball_shader"
edition.workspace = true
version = "0.1.0"

[lib]
crate-type = ["rlib", "cdylib"]

[dependencies]
spirv-std.workspace = true
</file>

<file path="ball/shader/manifest.json">
[
  {
    "source_path": "fragment.spv",
    "entry_point": "fragment",
    "wgsl_entry_point": "fragment"
  },
  {
    "source_path": "vertex.spv",
    "entry_point": "vertex",
    "wgsl_entry_point": "vertex"
  }
]
</file>

<file path="ball/geom.rs">
use std::f32::consts::PI;
use trivalibs::{
	math::coords::angles_to_cartesian,
	prelude::*,
	rendering::{
		BufferedGeometry, mesh_geometry::MeshBufferType, shapes::sphere::create_sphere_mesh,
	},
};

#[apply(gpu_data)]
struct Vertex {
	pos: Vec3,
	uv: Vec2,
	color: Vec3,
}
impl Position3D for Vertex {
	fn position(&self) -> Vec3 {
		self.pos
	}
}

fn vert(pos: Vec3, uv: Vec2, color: Vec3) -> Vertex {
	Vertex { pos, uv, color }
}

fn pos_vert(pos: Vec3, uv: Vec2) -> Vertex {
	Vertex {
		pos,
		color: Vec3::ZERO,
		uv,
	}
}

const VERTICAL_SEGMENTS: u32 = 50;
const HORIZONTAL_SEGMENTS: u32 = 50;

pub fn create_ball_geom() -> BufferedGeometry {
	let geom = create_sphere_mesh(
		VERTICAL_SEGMENTS,
		HORIZONTAL_SEGMENTS,
		|horiz_angle, vert_angle| {
			let pos = angles_to_cartesian(horiz_angle, vert_angle);
			let uv = vec2(horiz_angle / (PI * 2.0), vert_angle / PI + 0.5);

			pos_vert(pos * 5.0, uv)
		},
	);

	let mut geom = geom.map(|face| {
		let vertices = face.vertices();

		let uv = vertices.iter().map(|v| v.uv).sum::<Vec2>() / vertices.len() as f32;

		let use_horiz_gradient = uv.x * HORIZONTAL_SEGMENTS as f32 % 2.0 < 1.0;
		let gradient = if use_horiz_gradient { uv.x } else { uv.y };
		let color = vec3(random(), random(), random()) * 0.2 + gradient * 0.8;

		vertices.iter().map(|v| vert(v.pos, v.uv, color)).collect()
	});

	geom.to_buffered_geometry_by_type(MeshBufferType::FaceVerticesWithVertexNormal)
}

#[test]
fn ball1() {
	let res = create_ball_geom();
	// println!("{:?}", res);
	assert!(res.vertex_buffer.len() > 0);
	println!("buffer len: {}", res.vertex_buffer.len());
	println!(
		"index buffer len: {}",
		res.index_buffer.map(|i| i.len()).unwrap_or(0)
	);
}
</file>

<file path="ball/main.rs">
use geom::create_ball_geom;
use trivalibs::{
	map,
	math::transform::Transform,
	painter::prelude::*,
	prelude::*,
	rendering::{
		camera::{CamProps, PerspectiveCamera},
		scene::SceneObject,
	},
};

mod geom;

struct App {
	cam: PerspectiveCamera,
	ball_transform: Transform,

	canvas: Layer,
	mvp: BindingBuffer<Mat4>,
	norm: BindingBuffer<Mat3U>,
}

impl CanvasApp<()> for App {
	fn init(p: &mut Painter) -> Self {
		let tex_bytes = include_bytes!("./texture.png");
		let mut reader = png::Decoder::new(std::io::Cursor::new(tex_bytes))
			.read_info()
			.unwrap();
		// Allocate the output buffer.
		let mut buf = vec![0; reader.output_buffer_size().unwrap()];
		// Read the next frame. An APNG might contain multiple frames.
		let info = reader.next_frame(&mut buf).unwrap();
		// Grab the bytes of the image.
		let tex_rgba = &buf[..info.buffer_size()];

		let tex = p
			.layer()
			.with_size(info.width, info.height)
			.with_static_texture_data(tex_rgba)
			.with_format(wgpu::TextureFormat::Rgba8UnormSrgb)
			.create();

		let shade = p
			.shade([Float32x3, Float32x2, Float32x3, Float32x3])
			.with_bindings([
				BINDING_BUFFER_VERT,
				BINDING_BUFFER_VERT,
				BINDING_SAMPLER_FRAG,
			])
			.with_layers([BINDING_LAYER_FRAG])
			.create();
		load_vertex_shader!(shade, p, "./shader/vertex.spv");
		load_fragment_shader!(shade, p, "./shader/fragment.spv");

		let form = p.form(&create_ball_geom()).create();

		let mvp = p.bind_mat4();
		let norm = p.bind_mat3();

		let s = p.sampler_linear().binding();
		let shape = p
			.shape(form, shade)
			.with_bindings(map! {
				0 => mvp.binding(),
				1 => norm.binding(),
				2 => s
			})
			.with_layers(map! {
				0 => tex.binding()
			})
			.create();

		let canvas = p
			.layer()
			.with_shape(shape)
			.with_clear_color(wgpu::Color {
				r: 0.5,
				g: 0.6,
				b: 0.7,
				a: 1.0,
			})
			.with_multisampling()
			.create();

		Self {
			canvas,
			mvp,
			norm,

			cam: PerspectiveCamera::create(CamProps {
				fov: Some(0.65),
				translation: Some(vec3(0.0, 5.0, 0.0)),
				rot_vertical: Some(-0.26),
				..default()
			}),
			ball_transform: Transform::from_translation(vec3(0.0, 0.0, -20.0)),
		}
	}

	fn resize(&mut self, _p: &mut Painter, width: u32, height: u32) {
		self.cam.set_aspect_ratio(width as f32 / height as f32);
	}

	fn frame(&mut self, p: &mut Painter, tpf: f32) {
		self.ball_transform.rotate_y(tpf * 0.5);

		self.mvp
			.update(p, self.ball_transform.model_view_proj_mat(&self.cam));

		self.norm
			.update_mat3(p, self.ball_transform.view_normal_mat(&self.cam));

		p.paint_and_show(self.canvas);

		p.request_next_frame();
	}

	fn event(&mut self, _e: Event<()>, _p: &mut Painter) {}
}

pub fn main() {
	App::create()
		.config(AppConfig {
			show_fps: true,
			use_vsync: false,
			remember_window_dimensions: true,
			..default()
		})
		.start();
}
</file>

<file path="base_effect/shader/src/lib.rs">
#![no_std]
#![allow(unexpected_cfgs)]

use spirv_std::glam::{UVec2, Vec2, Vec4, vec2, vec4};
#[allow(unused_imports)]
use spirv_std::num_traits::Float;
use spirv_std::spirv;
use trivalibs_nostd::{num_ext::NumExt, vec_ext::VecExt};

#[spirv(fragment)]
pub fn main(
	coord: Vec2,
	#[spirv(uniform, descriptor_set = 0, binding = 0)] size: &UVec2,
	#[spirv(uniform, descriptor_set = 0, binding = 1)] time: &f32,
	out: &mut Vec4,
) {
	let tile_dim = vec2(200.0, 100.0);
	let size = vec2(size.x as f32, size.y as f32);
	let tile_size = size / tile_dim;
	let tile_ratio = tile_dim.x / tile_dim.y;
	let gap_size = 0.1;
	let gap = vec2(gap_size, gap_size * tile_ratio);
	let mut tile = coord * tile_size;
	tile.y -= (time * 0.5).frct() * 2.0;
	let y_offet = tile.y.ceil() % 2.0;
	if y_offet == 0.0 {
		tile.x += 0.5;
	}
	tile -= gap * 0.5;
	let tile = tile.frct();
	*out = if tile.x >= 1.0 - gap.x || tile.y >= 1.0 - gap.y {
		vec4(0.4, 0.6, 0.9, 1.0)
	} else {
		vec4(1.0, 0.8, 0.5, 1.0)
	}
}
</file>

<file path="base_effect/shader/Cargo.toml">
[package]
name = "base_effect_shader"
edition.workspace = true
version = "0.1.0"

[lib]
crate-type = ["rlib", "cdylib"]

[dependencies]
spirv-std.workspace = true
trivalibs-nostd.workspace = true
</file>

<file path="base_effect/shader/manifest.json">
[
  {
    "source_path": "main.spv",
    "entry_point": "main",
    "wgsl_entry_point": "main"
  }
]
</file>

<file path="base_effect/main.rs">
use trivalibs::{map, painter::prelude::*, prelude::*};

struct App {
	time: f32,

	u_time: BindingBuffer<f32>,
	u_size: BindingBuffer<UVec2>,
	canvas: Layer,
}

impl CanvasApp<()> for App {
	fn init(p: &mut Painter) -> Self {
		let shade = p
			.shade_effect()
			.with_bindings([BINDING_BUFFER_FRAG, BINDING_BUFFER_FRAG])
			.create();
		load_fragment_shader!(shade, p, "./shader/main.spv");

		let u_time = p.bind_f32();
		let u_size = p.bind_uvec2();

		let effect = p
			.effect(shade)
			.with_bindings(map! {
				0 => u_size.binding(),
				1 => u_time.binding()
			})
			.create();

		let canvas = p.layer().with_effect(effect).create();

		Self {
			time: 0.0,

			u_time,
			u_size,
			canvas,
		}
	}

	fn resize(&mut self, p: &mut Painter, width: u32, height: u32) {
		self.u_size.update(p, uvec2(width, height));
	}

	fn frame(&mut self, p: &mut Painter, tpf: f32) {
		p.request_next_frame();

		self.time += tpf;
		self.u_time.update(p, self.time);

		p.paint_and_show(self.canvas);
	}

	fn event(&mut self, _e: Event<()>, _p: &mut Painter) {}
}

pub fn main() {
	App::create()
		.config(AppConfig {
			show_fps: true,
			use_vsync: false,
			remember_window_dimensions: true,
			..default()
		})
		.start();
}
</file>

<file path="blur/shader/src/lib.rs">
#![no_std]
#![allow(unexpected_cfgs)]

use spirv_std::glam::{vec4, Vec2, Vec4};
use spirv_std::{spirv, Image, Sampler};
#[allow(unused_imports)]
use trivalibs_nostd::blur::{gaussian_blur, gaussian_blur_13, gaussian_blur_9};

#[spirv(vertex)]
pub fn triangle_vs(pos: Vec2, uv: Vec2, #[spirv(position)] out_pos: &mut Vec4, out_uv: &mut Vec2) {
	*out_pos = pos.extend(0.0).extend(1.0);
	*out_uv = uv;
}

#[spirv(fragment)]
pub fn triangle_fs(uv: Vec2, out: &mut Vec4) {
	*out = vec4(uv.x, uv.y, 0.0, 1.0);
}

#[spirv(fragment)]
pub fn blur_fs(
	uv: Vec2,
	#[spirv(uniform, descriptor_set = 0, binding = 0)] diameter: &f32,
	#[spirv(uniform, descriptor_set = 0, binding = 1)] resolution: &Vec2,
	#[spirv(uniform, descriptor_set = 0, binding = 2)] dir: &Vec2,
	#[spirv(descriptor_set = 0, binding = 3)] sampler: &Sampler,
	#[spirv(descriptor_set = 1, binding = 0)] tex: &Image!(2D, type=f32, sampled),
	out: &mut Vec4,
) {
	// for bluring in one pass
	// *out = gaussian_blur(tex, sampler, *diameter, uv, *resolution, *dir);

	// for bluring in multiple passes
	*out = gaussian_blur_9(tex, sampler, uv, *resolution, *dir * *diameter);
}
</file>

<file path="blur/shader/Cargo.toml">
[package]
name = "blur_shader"
version = "0.1.0"
edition.workspace = true

[lib]
crate-type = ["rlib", "cdylib"]

[dependencies]
spirv-std.workspace = true
trivalibs-nostd.workspace = true
</file>

<file path="blur/shader/manifest.json">
[
  {
    "source_path": "blur_fs.spv",
    "entry_point": "blur_fs",
    "wgsl_entry_point": "blur_fs"
  },
  {
    "source_path": "triangle_fs.spv",
    "entry_point": "triangle_fs",
    "wgsl_entry_point": "triangle_fs"
  },
  {
    "source_path": "triangle_vs.spv",
    "entry_point": "triangle_vs",
    "wgsl_entry_point": "triangle_vs"
  }
]
</file>

<file path="blur/main.rs">
use trivalibs::{painter::prelude::*, prelude::*};

const BLUR_DIAMETER: f32 = 400.0;

#[apply(gpu_data)]
struct Vertex {
	pos: Vec2,
	uv: Vec2,
}

const TRIANGLE: &[Vertex] = &[
	Vertex {
		pos: vec2(-0.7, -0.7),
		uv: vec2(0.0, 1.0),
	},
	Vertex {
		pos: vec2(0.7, -0.7),
		uv: vec2(1.0, 1.0),
	},
	Vertex {
		pos: vec2(0.0, 0.7),
		uv: vec2(0.5, 0.0),
	},
];

struct App {
	canvas: Layer,
	size: BindingBuffer<Vec2>,
}

impl CanvasApp<()> for App {
	fn init(p: &mut Painter) -> Self {
		let triangle_shade = p.shade([Float32x2, Float32x2]).create();
		load_vertex_shader!(triangle_shade, p, "./shader/triangle_vs.spv");
		load_fragment_shader!(triangle_shade, p, "./shader/triangle_fs.spv");

		let blur_shade = p
			.shade_effect()
			.with_bindings([
				BINDING_BUFFER_FRAG,
				BINDING_BUFFER_FRAG,
				BINDING_BUFFER_FRAG,
				BINDING_SAMPLER_FRAG,
			])
			.with_layer()
			.create();
		load_fragment_shader!(blur_shade, p, "./shader/blur_fs.spv");

		let tri_form = p.form(TRIANGLE).create();

		let tri_shape = p.shape(tri_form, triangle_shade).create();

		let size = p.bind_vec2();
		let horiz = p.bind_const_vec2(vec2(1.0, 0.0));
		let vertical = p.bind_const_vec2(vec2(0.0, 1.0));
		let s = p.sampler_linear().binding();

		let mut effects = vec![];

		// ===  This does blur in multiple passes ===
		// It cuts the number of texture reads logarithmically, but increases the number of passes

		let mut counter = BLUR_DIAMETER / 9.0; // Fixed diameter in shader is 9.0
		while counter > 2.0 {
			let diameter = p.bind_const_f32(counter);
			effects.push(
				p.effect(blur_shade)
					.with_bindings(map! {
						0 => diameter,
						1 => size.binding(),
						2 => horiz,
						3 => s
					})
					.create(),
			);
			effects.push(
				p.effect(blur_shade)
					.with_bindings(map! {
						0 => diameter,
						1 => size.binding(),
						2 => vertical,
						3 => s
					})
					.create(),
			);
			counter /= 2.0;
		}

		// println!("effects: {:?}", effects.len());

		// === This does all blurs in one pass ===

		// let diameter = p.binding_const_f32(BLUR_DIAMETER);
		// effects.push(
		// 	p.effect(blur_shade)
		// 		.with_bindings(map! {
		// 			0 => diameter,
		// 			1 => size.binding(),
		// 			2 => horiz,
		// 			3 => s
		// 		})
		// 		.create(),
		// );
		// effects.push(
		// 	p.effect(blur_shade)
		// 		.with_bindings(map! {
		// 			0 => diameter,
		// 			1 => size.binding(),
		// 			2 => vertical,
		// 			3 => s
		// 		})
		// 		.create(),
		// );

		let canvas = p
			.layer()
			.with_shape(tri_shape)
			.with_effects(effects)
			.with_clear_color(wgpu::Color::BLUE)
			.create();

		Self { canvas, size }
	}

	fn resize(&mut self, p: &mut Painter, width: u32, height: u32) {
		self.size.update(p, vec2(width as f32, height as f32));
	}

	fn frame(&mut self, p: &mut Painter, _tpf: f32) {
		p.request_next_frame();
		p.paint_and_show(self.canvas)
	}

	fn event(&mut self, _e: Event<()>, _p: &mut Painter) {}
}

pub fn main() {
	App::create()
		.config(AppConfig {
			show_fps: true,
			use_vsync: false,
			remember_window_dimensions: true,
			..default()
		})
		.start();
}
</file>

<file path="deferred_light/shader/src/lib.rs">
#![no_std]
#![allow(unexpected_cfgs)]

use spirv_std::glam::{swizzles::*, Mat4, Quat, Vec2, Vec3, Vec4};
#[allow(unused_imports)]
use spirv_std::num_traits::Float;
use spirv_std::{spirv, Image, Sampler};

#[spirv(vertex)]
pub fn scene_vs(
	position: Vec3,
	color: Vec3,
	normal: Vec3,
	#[spirv(uniform, descriptor_set = 0, binding = 0)] model_mat: &Mat4,
	#[spirv(uniform, descriptor_set = 0, binding = 1)] vp_mat: &Mat4,
	#[spirv(uniform, descriptor_set = 0, binding = 2)] normal_rot: &Quat,
	#[spirv(position)] clip_pos: &mut Vec4,
	out_pos: &mut Vec3,
	out_color: &mut Vec3,
	out_norm: &mut Vec3,
	out_depth: &mut f32,
) {
	*out_color = color;
	*out_norm = normal_rot.mul_vec3(normal);
	let pos = *model_mat * position.extend(1.0);
	*out_pos = pos.xyz();
	*clip_pos = *vp_mat * pos;
	*out_depth = clip_pos.z;
}

#[spirv(fragment)]
pub fn scene_fs(
	in_pos: Vec3,
	in_color: Vec3,
	in_norm: Vec3,
	in_depth: f32,
	frag_color: &mut Vec4,
	frag_norm: &mut Vec4,
	frag_pos: &mut Vec4,
) {
	*frag_color = in_color.extend(1.0);
	*frag_norm = in_norm.extend(0.0);
	*frag_pos = in_pos.extend(in_depth);
}

#[spirv(fragment)]
pub fn light_fs(
	in_uv: Vec2,
	#[spirv(descriptor_set = 0, binding = 0)] sampler: &Sampler,
	#[spirv(uniform, descriptor_set = 0, binding = 1)] eye_pos: &Vec3,
	#[spirv(uniform, descriptor_set = 0, binding = 2)] light_pos: &Vec3,
	#[spirv(uniform, descriptor_set = 0, binding = 3)] light_color: &Vec3,
	#[spirv(descriptor_set = 1, binding = 0)] color_tex: &Image!(2D, type=f32, sampled),
	#[spirv(descriptor_set = 1, binding = 1)] normal_tex: &Image!(2D, type=f32, sampled),
	#[spirv(descriptor_set = 1, binding = 2)] pos_tex: &Image!(2D, type=f32, sampled),
	frag_color: &mut Vec4,
) {
	let color = color_tex.sample(*sampler, in_uv).xyz();
	let normal = normal_tex.sample(*sampler, in_uv).xyz().normalize();
	let pos = pos_tex.sample(*sampler, in_uv).xyz();

	let light_dir = (*light_pos - pos).normalize();
	let view_dir = (*eye_pos - pos).normalize();
	let half_dir = (light_dir + view_dir).normalize();

	// Half Lambert diffuse
	let n_dot_l = normal.dot(light_dir);
	let diffuse = *light_color * n_dot_l.max(0.0);

	// Specular (Blinn-Phong)
	let n_dot_h = normal.dot(half_dir).max(0.0);
	let specular = *light_color * n_dot_h.powf(30.0) * 1.8;

	// let final_color = (color.xyz() * (1.0 - (pos.w / 25.0))).extend(1.0);
	let mut final_color = color * diffuse + specular + color * 0.01;
	final_color *= 0.4;
	// let final_color = Vec3::splat(1.0) * diffuse + specular;
	*frag_color = final_color.extend(1.0);
}
</file>

<file path="deferred_light/shader/Cargo.toml">
[package]
name = "deferred_light_shader"
edition.workspace = true
version = "0.1.0"

[lib]
crate-type = ["rlib", "cdylib"]

[dependencies]
spirv-std.workspace = true
</file>

<file path="deferred_light/shader/manifest.json">
[
  {
    "source_path": "light_fs.spv",
    "entry_point": "light_fs",
    "wgsl_entry_point": "light_fs"
  },
  {
    "source_path": "scene_fs.spv",
    "entry_point": "scene_fs",
    "wgsl_entry_point": "scene_fs"
  },
  {
    "source_path": "scene_vs.spv",
    "entry_point": "scene_vs",
    "wgsl_entry_point": "scene_vs"
  }
]
</file>

<file path="deferred_light/geom.rs">
use trivalibs::{
	math::coords::angles_to_cartesian,
	prelude::*,
	rendering::{
		BufferedGeometry,
		mesh_geometry::{MeshBufferType, MeshGeometry},
		shapes::{cuboid::Cuboid, quad::Quad3D, sphere::create_sphere_mesh},
	},
};

#[apply(gpu_data)]
struct Vertex {
	pos: Vec3,
	color: Vec3,
}
impl Position3D for Vertex {
	fn position(&self) -> Vec3 {
		self.pos
	}
}

fn vert_pos(pos: Vec3) -> Vertex {
	Vertex {
		pos,
		color: Vec3::ZERO,
	}
}

fn vert(pos: Vec3, color: Vec3) -> Vertex {
	Vertex { pos, color }
}

const VERTICAL_SEGMENTS: u32 = 25;
const HORIZONTAL_SEGMENTS: u32 = 50;

pub fn create_ball_geom() -> BufferedGeometry {
	let geom = create_sphere_mesh(
		VERTICAL_SEGMENTS,
		HORIZONTAL_SEGMENTS,
		|horiz_angle, vert_angle| vert_pos(angles_to_cartesian(horiz_angle, vert_angle)),
	);

	let mut geom = geom.map(|face| {
		let color = vec3(random(), random(), random());

		face.vertices().iter().map(|v| vert(v.pos, color)).collect()
	});

	geom.to_buffered_geometry_by_type(MeshBufferType::FaceVerticesWithVertexNormal)
}

pub fn create_box_geom() -> BufferedGeometry {
	let box_shape = Cuboid::unit_cube();
	let mut geom = MeshGeometry::new();

	let add = |geom: &mut MeshGeometry<_>, quad: Quad3D<Vec3>, color: Vec3| {
		geom.add_face(
			quad.to_ccw_verts()
				.iter()
				.map(|pos| vert(*pos, color))
				.collect::<Vec<_>>(),
		);
	};

	add(&mut geom, box_shape.front_face(), vec3(1.0, 0.0, 0.0));
	add(&mut geom, box_shape.back_face(), vec3(0.0, 1.0, 0.0));
	add(&mut geom, box_shape.left_face(), vec3(0.0, 0.0, 1.0));
	add(&mut geom, box_shape.right_face(), vec3(1.0, 1.0, 0.0));
	add(&mut geom, box_shape.top_face(), vec3(0.0, 1.0, 1.0));
	add(&mut geom, box_shape.bottom_face(), vec3(1.0, 0.0, 1.0));

	geom.to_buffered_geometry_by_type(MeshBufferType::FaceVerticesWithFaceNormal)
}
</file>

<file path="deferred_light/main.rs">
use geom::{create_ball_geom, create_box_geom};
use trivalibs::{
	map,
	math::transform::Transform,
	painter::prelude::*,
	prelude::*,
	rendering::{
		camera::{CamProps, PerspectiveCamera},
		scene::SceneObject,
	},
};

mod geom;

struct App {
	cam: PerspectiveCamera,
	ball_transform: Transform,
	box_transform: Transform,

	u_ball_model_mat: BindingBuffer<Mat4>,
	u_ball_rot: BindingBuffer<Quat>,
	u_box_model_mat: BindingBuffer<Mat4>,
	u_box_rot: BindingBuffer<Quat>,
	u_vp_mat: BindingBuffer<Mat4>,
	scene_layer: Layer,
	canvas: Layer,
}

const LIGHTS_COUNT: usize = 10;

impl CanvasApp<()> for App {
	fn init(p: &mut Painter) -> Self {
		let scene_shade = p
			.shade([Float32x3, Float32x3, Float32x3])
			.with_bindings([
				BINDING_BUFFER_VERT,
				BINDING_BUFFER_VERT,
				BINDING_BUFFER_VERT,
			])
			.create();
		load_vertex_shader!(scene_shade, p, "./shader/scene_vs.spv");
		load_fragment_shader!(scene_shade, p, "./shader/scene_fs.spv");

		let ball_form = p.form(&create_ball_geom()).create();

		let u_vp_mat = p.bind_mat4();

		let u_ball_model_mat = p.bind_mat4();
		let u_ball_rot = p.bind_quat();

		let ball_shape = p
			.shape(ball_form, scene_shade)
			.with_bindings(map! {
				0 => u_ball_model_mat.binding(),
				2 => u_ball_rot.binding(),
			})
			.create();

		let box_form = p.form(&create_box_geom()).create();

		let u_box_model_mat = p.bind_mat4();
		let u_box_rot = p.bind_quat();

		let box_shape = p
			.shape(box_form, scene_shade)
			.with_bindings(map! {
				0 => u_box_model_mat.binding(),
				2 => u_box_rot.binding(),
			})
			.create();

		let scene_layer = p
			.layer()
			.with_clear_color(wgpu::Color {
				r: 0.5,
				g: 0.6,
				b: 0.7,
				a: 1.0,
			})
			.with_shapes([ball_shape, box_shape])
			.with_formats([Rgba8UnormSrgb, Rgba16Float, Rgba16Float])
			.with_bindings(map! {
				1 => u_vp_mat.binding(),
			})
			.with_multisampling()
			.with_depth_test()
			.create();

		let canvas_shade = p
			.shade_effect()
			.with_bindings([
				BINDING_SAMPLER_FRAG,
				BINDING_BUFFER_FRAG,
				BINDING_BUFFER_FRAG,
				BINDING_BUFFER_FRAG,
			])
			.with_layers([BINDING_LAYER_FRAG, BINDING_LAYER_FRAG, BINDING_LAYER_FRAG])
			.create();
		load_fragment_shader!(canvas_shade, p, "./shader/light_fs.spv");

		let color_target = scene_layer.binding_at(0);
		let normal_target = scene_layer.binding_at(1);
		let position_target = scene_layer.binding_at(2);

		let lights = (0..LIGHTS_COUNT)
			.map(|_| {
				let light_pos = rand_vec3_unit() * rand_range(10.0, 30.0);
				let light_pos_u = p.bind_const_vec3(light_pos);

				let light_color_u = p.bind_const_vec3(rand_vec3());

				InstanceBinding {
					bindings: map! {
						2 => light_pos_u,
						3 => light_color_u,
					},
					..default()
				}
			})
			.collect();

		let cam_pos = vec3(0.0, 5.0, 0.0);
		let cam_pos_u = p.bind_const_vec3(cam_pos);

		let s = p.sampler_nearest().binding();

		let canvas_effect = p
			.effect(canvas_shade)
			.with_bindings(map! {
				0 => s,
				1 => cam_pos_u,
			})
			.with_layers(map! {
				0 => color_target,
				1 => normal_target,
				2 => position_target,
			})
			.with_instances(lights)
			.with_blend_state(wgpu::BlendState {
				color: wgpu::BlendComponent {
					src_factor: wgpu::BlendFactor::One,
					dst_factor: wgpu::BlendFactor::One,
					operation: wgpu::BlendOperation::Add,
				},
				alpha: wgpu::BlendComponent {
					src_factor: wgpu::BlendFactor::One,
					dst_factor: wgpu::BlendFactor::One,
					operation: wgpu::BlendOperation::Add,
				},
			})
			.create();

		let canvas = p
			.layer()
			.with_effect(canvas_effect)
			.with_clear_color(wgpu::Color {
				r: 0.0,
				g: 0.0,
				b: 0.0,
				a: 1.0,
			})
			.create();

		Self {
			cam: PerspectiveCamera::create(CamProps {
				fov: Some(0.65),
				translation: Some(cam_pos),
				rot_vertical: Some(-0.26),
				..default()
			}),
			ball_transform: Transform::from_translation(vec3(5.0, 0.0, -20.0))
				.with_scale(Vec3::ONE * 5.0),
			box_transform: Transform::from_translation(vec3(-5.0, 0.0, -20.0))
				.with_scale(Vec3::ONE * 7.5),

			u_ball_model_mat,
			u_ball_rot,
			u_box_model_mat,
			u_box_rot,
			u_vp_mat,
			scene_layer,
			canvas,
		}
	}

	fn resize(&mut self, p: &mut Painter, width: u32, height: u32) {
		self.cam.set_aspect_ratio(width as f32 / height as f32);
		self.u_vp_mat.update(p, self.cam.view_proj_mat());
	}

	fn frame(&mut self, p: &mut Painter, tpf: f32) {
		self.ball_transform.rotate_y(tpf * 0.25);
		self.box_transform.rotate_y(tpf * 0.25);
		self.box_transform.rotate_x(tpf * 0.3);

		self.u_ball_model_mat
			.update(p, self.ball_transform.model_mat());
		self.u_ball_rot.update(p, self.ball_transform.rotation);
		self.u_box_model_mat
			.update(p, self.box_transform.model_mat());
		self.u_box_rot.update(p, self.box_transform.rotation);

		p.request_next_frame();

		// render
		p.paint(self.scene_layer);
		p.paint(self.canvas);
		p.show(self.canvas)
	}

	fn event(&mut self, _e: Event<()>, _p: &mut Painter) {}
}

pub fn main() {
	App::create()
		.config(AppConfig {
			show_fps: true,
			use_vsync: false,
			remember_window_dimensions: true,
			..default()
		})
		.start();
}
</file>

<file path="dynamic_shapes/shader/src/lib.rs">
#![no_std]
#![allow(unexpected_cfgs)]

use spirv_std::glam::{Vec2, Vec3, Vec4, vec4};
use spirv_std::spirv;
use trivalibs_nostd::prelude::*;

#[spirv(vertex)]
pub fn vertex(position: Vec2, #[spirv(position)] clip_pos: &mut Vec4, pos: &mut Vec2) {
	*clip_pos = position.extend(0.0).extend(1.0);
	*pos = position.fit1101();
}

#[spirv(fragment)]
pub fn fragment(
	pos: Vec2,
	#[spirv(uniform, descriptor_set = 0, binding = 0)] color: &Vec3,
	#[spirv(uniform, descriptor_set = 0, binding = 1)] is_vertical: &u32,
	frag_color: &mut Vec4,
) {
	let alpha = if *is_vertical != 0 {
		if (pos.y / 0.01) as u32 % 2 == 0 {
			1.0
		} else {
			0.0
		}
	} else {
		if (pos.x / 0.01) as u32 % 2 == 0 {
			1.0
		} else {
			0.0
		}
	};
	*frag_color = color.powf(2.2).extend(alpha);
}

#[spirv(fragment)]
pub fn effect_fragment(
	uv: Vec2,
	#[spirv(descriptor_set = 0, binding = 0)] sampler: &spirv_std::Sampler,
	#[spirv(descriptor_set = 1, binding = 0)] texture: &spirv_std::Image!(2D, type=f32, sampled),
	frag_color: &mut Vec4,
) {
	let color: Vec4 = texture.sample(*sampler, uv);
	*frag_color = vec4(color.x, color.y, color.z, color.w);
}
</file>

<file path="dynamic_shapes/shader/Cargo.toml">
[package]
name = "dynamic_shapes_shader"
edition.workspace = true
version = "0.1.0"

[lib]
crate-type = ["rlib", "cdylib"]

[dependencies]
spirv-std.workspace = true
trivalibs-nostd.workspace = true
</file>

<file path="dynamic_shapes/shader/manifest.json">
[
  {
    "source_path": "effect_fragment.spv",
    "entry_point": "effect_fragment",
    "wgsl_entry_point": "effect_fragment"
  },
  {
    "source_path": "fragment.spv",
    "entry_point": "fragment",
    "wgsl_entry_point": "fragment"
  },
  {
    "source_path": "vertex.spv",
    "entry_point": "vertex",
    "wgsl_entry_point": "vertex"
  }
]
</file>

<file path="dynamic_shapes/main.rs">
use trivalibs::{map, painter::prelude::*, prelude::*};

// Generate a simple square geometry centered at a position with a given size
fn generate_square(pos: Vec2, size: f32) -> Vec<Vec2> {
	let half_size = size * 0.5;
	vec![
		// Triangle 1
		vec2(pos.x - half_size, pos.y - half_size),
		vec2(pos.x + half_size, pos.y + half_size),
		vec2(pos.x - half_size, pos.y + half_size),
		// Triangle 2
		vec2(pos.x - half_size, pos.y - half_size),
		vec2(pos.x + half_size, pos.y - half_size),
		vec2(pos.x + half_size, pos.y + half_size),
	]
}

// Pick a random selection of shapes from the pool
// Randomly selects a count between 0 and POOL_SIZE
fn pick_random_shapes(shape_pool: &[Shape]) -> Vec<Shape> {
	let count = rand_range(0.0, POOL_SIZE as f32) as usize;
	let mut selected_shapes = Vec::new();
	for _ in 0..count {
		let idx = rand_range(0.0, shape_pool.len() as f32) as usize % shape_pool.len();
		selected_shapes.push(shape_pool[idx]);
	}
	selected_shapes
}

struct App {
	canvas: Layer,
	layer1: Layer,
	layer2: Layer,
	shape_pool: Vec<Shape>,
	timer: f32,
}

const POOL_SIZE: usize = 30;

impl CanvasApp<()> for App {
	fn init(p: &mut Painter) -> Self {
		// Create a single shade that all shapes will share
		let shade = p
			.shade([Float32x2])
			.with_bindings([BINDING_BUFFER_FRAG, BINDING_BUFFER_FRAG])
			.create();
		load_vertex_shader!(shade, p, "./shader/vertex.spv");
		load_fragment_shader!(shade, p, "./shader/fragment.spv");

		// Create a pool of shapes, each with:
		// - A form (square at random position)
		// - A random color binding
		let mut shape_pool = Vec::with_capacity(POOL_SIZE);

		for i in 0..POOL_SIZE {
			// Random position in normalized device coordinates (-1 to 1)
			let pos = vec2(rand_range(-0.8, 0.8), rand_range(-0.8, 0.8));
			let size = rand_range(0.1, 0.3);

			// Create form for this square
			let vertices = generate_square(pos, size);
			let form = p.form(&vertices).create();

			// Create color binding with random color
			let color = rand_vec3();
			let color_binding = p.bind_const_vec3(color);

			// Create shape
			let shape = p
				.shape(form, shade)
				.with_bindings(map! {
					0 => color_binding
				})
				.create();

			shape_pool.push(shape);

			println!(
				"Created shape {}: pos=({:.2}, {:.2}), size={:.2}, color=({:.2}, {:.2}, {:.2})",
				i, pos.x, pos.y, size, color.x, color.y, color.z
			);
		}

		let is_vertical = p.bind_const_u32(1);
		let is_horizontal = p.bind_const_u32(0);

		// Create two intermediate layers with distinct random shapes
		let layer1 = p
			.layer()
			.with_bindings(vec![(1, is_vertical)])
			.with_clear_color(wgpu::Color::TRANSPARENT)
			.with_multisampling()
			.create();

		let layer2 = p
			.layer()
			.with_bindings(vec![(1, is_horizontal)])
			.with_clear_color(wgpu::Color::TRANSPARENT)
			.with_multisampling()
			.create();

		// Pick distinct sets of shapes for each layer
		let shapes1 = pick_random_shapes(&shape_pool);
		let shapes2 = pick_random_shapes(&shape_pool);

		layer1.set_shapes(p, shapes1.clone());
		layer2.set_shapes(p, shapes2.clone());

		println!("\nLayer 1: {} shapes", shapes1.len());
		println!("Layer 2: {} shapes", shapes2.len());

		// Create effect shader for rendering textures
		let effect_shade = p
			.shade_effect()
			.with_bindings([BINDING_SAMPLER_FRAG])
			.with_layer()
			.create();
		load_fragment_shader!(effect_shade, p, "./shader/effect_fragment.spv");

		// Create a default sampler
		let sampler = p.sampler_linear();

		// Create effect with two instances for the two layers
		let effect = p
			.effect(effect_shade)
			.with_instances(vec![
				InstanceBinding {
					layers: vec![(0, layer1.binding())],
					..default()
				},
				InstanceBinding {
					layers: vec![(0, layer2.binding())],
					..default()
				},
			])
			.with_blend_state(wgpu::BlendState::ALPHA_BLENDING)
			.create();

		// Create the canvas layer with the effect instances
		let canvas = p
			.layer()
			.with_effect(effect)
			.with_bindings(vec![(0, sampler.binding())])
			.with_clear_color(wgpu::Color {
				r: 0.1,
				g: 0.1,
				b: 0.15,
				a: 1.0,
			})
			.with_multisampling()
			.create();

		Self {
			canvas,
			layer1,
			layer2,
			shape_pool,
			timer: 0.0,
		}
	}

	fn resize(&mut self, _p: &mut Painter, _width: u32, _height: u32) {}

	fn frame(&mut self, p: &mut Painter, tpf: f32) {
		self.timer += tpf;

		// Every second, pick a random selection of shapes from the pool for both layers
		if self.timer >= 1.0 {
			self.timer -= 1.0;

			// Randomly select shapes from the pool for each layer
			let shapes1 = pick_random_shapes(&self.shape_pool);
			let shapes2 = pick_random_shapes(&self.shape_pool);

			// Update both layers with new selections
			self.layer1.set_shapes(p, shapes1.clone());
			self.layer2.set_shapes(p, shapes2.clone());

			println!(
				"Frame update: layer1={} shapes, layer2={} shapes",
				shapes1.len(),
				shapes2.len()
			);
		}

		// Request continuous rendering
		p.request_next_frame();

		// render
		p.paint(self.layer1);
		p.paint(self.layer2);
		p.paint_and_show(self.canvas);
	}

	fn event(&mut self, _e: Event<()>, _p: &mut Painter) {}
}

pub fn main() {
	App::create()
		.config(AppConfig {
			show_fps: true,
			use_vsync: false,
			remember_window_dimensions: true,
			..default()
		})
		.start();
}
</file>

<file path="dynamic_texture/shader/src/lib.rs">
#![no_std]
#![allow(unexpected_cfgs)]

use spirv_std::glam::{Vec2, Vec4, Vec4Swizzles};
use spirv_std::{Image, Sampler, spirv};

/// Fragment shader that samples a texture.
/// This is used for the display layer that switches between red/blue textures.
#[spirv(fragment)]
pub fn tex_fs(
	uv: Vec2,
	#[spirv(descriptor_set = 0, binding = 0)] sampler: &Sampler,
	#[spirv(descriptor_set = 1, binding = 0)] tex: &Image!(2D, type=f32, sampled),
	out: &mut Vec4,
) {
	*out = tex.sample(*sampler, uv);
}

/// Fragment shader that outputs a solid color from a uniform.
/// This is used to create the red and blue layers.
#[spirv(fragment)]
pub fn col_fs(
	_uv: Vec2,
	#[spirv(uniform, descriptor_set = 0, binding = 0)] color: &Vec4,
	out: &mut Vec4,
) {
	*out = color.xyz().extend(1.0);
}
</file>

<file path="dynamic_texture/shader/Cargo.toml">
[package]
name = "dynamic_texture_shader"
edition.workspace = true
version = "0.1.0"

[lib]
crate-type = ["rlib", "cdylib"]

[dependencies]
spirv-std.workspace = true
</file>

<file path="dynamic_texture/shader/manifest.json">
[
  {
    "source_path": "col_fs.spv",
    "entry_point": "col_fs",
    "wgsl_entry_point": "col_fs"
  },
  {
    "source_path": "tex_fs.spv",
    "entry_point": "tex_fs",
    "wgsl_entry_point": "tex_fs"
  }
]
</file>

<file path="dynamic_texture/main.rs">
use trivalibs::{painter::prelude::*, prelude::*};

struct App {
	red_layer: Layer,
	blue_layer: Layer,
	display_layer: Layer,
	time: f32,
	current_is_red: bool,
	last_toggle_time: f32,
}

impl CanvasApp<()> for App {
	fn init(p: &mut Painter) -> Self {
		// Create color shader for red/blue layers
		let color_shader = p
			.shade_effect()
			.with_bindings([BINDING_BUFFER_FRAG])
			.create();
		load_fragment_shader!(color_shader, p, "./shader/col_fs.spv");

		// Create texture shader for display layer
		let texture_shader = p
			.shade_effect()
			.with_bindings([BINDING_SAMPLER_FRAG])
			.with_layers([BINDING_LAYER_FRAG])
			.create();
		load_fragment_shader!(texture_shader, p, "./shader/tex_fs.spv");

		// Create color uniform bindings
		let red_color = p.bind_const_vec4(vec4(1.0, 0.0, 0.0, 1.0));
		let blue_color = p.bind_const_vec4(vec4(0.0, 0.0, 1.0, 1.0));

		// Create red layer - renders solid red color
		let red_layer = p
			.single_effect_layer(color_shader)
			.with_bindings(vec![(0, red_color)])
			.with_size(4, 4)
			.create();

		p.init_and_paint(red_layer);

		// Create blue layer - renders solid blue color
		let blue_layer = p
			.single_effect_layer(color_shader)
			.with_bindings(vec![(0, blue_color)])
			.with_size(4, 4)
			.create();

		p.init_and_paint(blue_layer);

		// Create sampler for texture sampling
		let sampler = p.sampler_nearest();

		// Create display layer - samples from red/blue layers
		// Initially bound to red layer
		let display_layer = p
			.single_effect_layer(texture_shader)
			.with_bindings(vec![(0, sampler.binding())])
			.with_layers(vec![(0, red_layer.binding())])
			.create();

		Self {
			red_layer,
			blue_layer,
			display_layer,
			time: 0.0,
			current_is_red: true,
			last_toggle_time: 0.0,
		}
	}

	fn resize(&mut self, _p: &mut Painter, _width: u32, _height: u32) {}

	fn frame(&mut self, p: &mut Painter, tpf: f32) {
		self.time += tpf;

		// Toggle every second
		if self.time - self.last_toggle_time >= 1.0 {
			self.last_toggle_time = self.time;
			self.current_is_red = !self.current_is_red;

			// This is the key part - dynamically switch texture binding!
			if self.current_is_red {
				println!("Switching to RED ({:.2}s)", self.time);
				self.display_layer
					.set_layer_binding(p, 0, self.red_layer.binding());
			} else {
				println!("Switching to BLUE ({:.2}s)", self.time);
				self.display_layer
					.set_layer_binding(p, 0, self.blue_layer.binding());
			}
		}

		// Render and show display layer (which samples from red or blue)
		p.paint_and_show(self.display_layer);

		p.request_next_frame();
	}

	fn event(&mut self, _e: Event<()>, _p: &mut Painter) {}
}

pub fn main() {
	App::create()
		.config(AppConfig {
			show_fps: true,
			..default()
		})
		.start();
}
</file>

<file path="geometries/shader/src/lib.rs">
#![no_std]
#![allow(unexpected_cfgs)]

use spirv_std::glam::{vec3, Mat4, Vec2, Vec3, Vec4};
use spirv_std::spirv;

#[spirv(vertex)]
pub fn ground_vert(
	position: Vec3,
	uv: Vec2,
	normal: Vec3,
	#[spirv(uniform, descriptor_set = 0, binding = 0)] mvp_mat: &Mat4,
	#[spirv(position)] out_pos: &mut Vec4,
	out_norm: &mut Vec3,
	out_uv: &mut Vec2,
) {
	*out_pos = *mvp_mat * position.extend(1.0);
	*out_norm = normal;
	*out_uv = uv;
}

#[spirv(fragment)]
pub fn ground_frag(_in_norm: Vec3, in_uv: Vec2, out: &mut Vec4) {
	let uv = in_uv * 40.0;
	let uv = uv.fract();

	let col = if uv.x < 0.05 || uv.y < 0.05 {
		Vec3::splat(0.4)
	} else {
		vec3(in_uv.x, in_uv.y, 0.5)
	};

	*out = col.powf(2.2).extend(1.0);
}
</file>

<file path="geometries/shader/Cargo.toml">
[package]
name = "room_shader"
version = "0.1.0"
edition.workspace = true

[lib]
crate-type = ["rlib", "cdylib"]

# Dependencies for CPU and GPU code
[dependencies]
spirv-std.workspace = true
trivalibs-nostd.workspace = true
</file>

<file path="geometries/shader/manifest.json">
[
  {
    "source_path": "ground_frag.spv",
    "entry_point": "ground_frag",
    "wgsl_entry_point": "ground_frag"
  },
  {
    "source_path": "ground_vert.spv",
    "entry_point": "ground_vert",
    "wgsl_entry_point": "ground_vert"
  }
]
</file>

<file path="geometries/main.rs">
use trivalibs::{
	common_utils::camera_controls::BasicFirstPersonCameraController,
	map,
	painter::{prelude::*, utils::input_state::InputState},
	prelude::*,
	rendering::{
		BufferedGeometry,
		camera::{CamProps, PerspectiveCamera},
		mesh_geometry::{
			MeshBufferType, MeshGeometry, face_normal, face_props,
			utils::{Vert3dUv, vert_pos_uv},
		},
		shapes::{cuboid::Cuboid, quad::Quad3D},
	},
};

pub fn create_plane(width: f32, height: f32, normal: Vec3, center: Vec3) -> BufferedGeometry {
	let plane: Quad3D<Vert3dUv> =
		Quad3D::from_dimensions_center_f(width, height, normal, center, vert_pos_uv).into();

	let mut geom = MeshGeometry::new();
	geom.add_face_data(&plane.to_ccw_verts(), face_normal(plane.normal));

	geom.to_buffered_geometry_by_type(MeshBufferType::FaceVerticesWithVertexNormal)
}

pub fn create_box(center: Vec3, size: Vec3) -> BufferedGeometry {
	let bbox = Cuboid::box_at(center, size.x, size.y, size.z);

	let mut geom = MeshGeometry::new();

	let front = bbox.front_face_f(|pos, uvw| vert_pos_uv(pos, vec2(uvw.x, uvw.y)));
	geom.add_face_data(&front.to_ccw_verts(), face_props(front.normal, 0));

	let back = bbox.back_face_f(|pos, uvw| vert_pos_uv(pos, vec2(1.0 - uvw.x, uvw.y)));
	geom.add_face_data(&back.to_ccw_verts(), face_props(back.normal, 1));

	let left = bbox.left_face_f(|pos, uvw| vert_pos_uv(pos, vec2(1.0 - uvw.z, uvw.y)));
	geom.add_face_data(&left.to_ccw_verts(), face_props(left.normal, 2));

	let right = bbox.right_face_f(|pos, uvw| vert_pos_uv(pos, vec2(uvw.z, uvw.y)));
	geom.add_face_data(&right.to_ccw_verts(), face_props(right.normal, 3));

	let top = bbox.top_face_f(|pos, uvw| vert_pos_uv(pos, vec2(uvw.x, 1.0 - uvw.z)));
	geom.add_face_data(&top.to_ccw_verts(), face_props(top.normal, 4));

	let bottom = bbox.bottom_face_f(|pos, uvw| vert_pos_uv(pos, vec2(uvw.x, uvw.z)));
	geom.add_face_data(&bottom.to_ccw_verts(), face_props(bottom.normal, 5));

	geom.to_buffered_geometry_by_type(MeshBufferType::FaceVerticesWithFaceNormal)
}

struct App {
	cam: PerspectiveCamera,
	vp_mat: BindingBuffer<Mat4>,
	canvas: Layer,

	input: InputState,
	cam_controller: BasicFirstPersonCameraController,
}

impl CanvasApp<()> for App {
	fn init(p: &mut Painter) -> Self {
		let shade = p
			.shade([Float32x3, Float32x3, Float32x2])
			.with_bindings([BINDING_BUFFER_VERT])
			.create();
		load_vertex_shader!(shade, p, "./shader/ground_vert.spv");
		load_fragment_shader!(shade, p, "./shader/ground_frag.spv");

		let cam = PerspectiveCamera::create(CamProps {
			fov: Some(0.6),
			translation: Some(vec3(0.0, 3.0, 15.0)),
			..default()
		});

		let ground_form = p
			.form(&create_plane(100.0, 100.0, Vec3::Y, Vec3::ZERO))
			.create();
		let roof_form = p
			.form(&create_plane(100.0, 100.0, -Vec3::Y, vec3(0.0, 10.0, 0.0)))
			.create();
		let wall_form = p
			.form(&create_plane(20.5, 5.0, Vec3::Z, vec3(15.0, 3.0, 0.0)))
			.create();

		let x_axis_form = p
			.form(&create_box(vec3(2.5, 0.5, 0.0), vec3(5.0, 0.5, 0.5)))
			.create();
		let y_axis_form = p
			.form(&create_box(vec3(0.0, 3.0, 0.0), vec3(0.5, 5.0, 0.5)))
			.create();
		let z_axis_form = p
			.form(&create_box(vec3(0.0, 0.5, 2.5), vec3(0.5, 0.5, 5.0)))
			.create();

		let ground_shape = p.shape(ground_form, shade).create();
		let wall_shape = p.shape(wall_form, shade).create();
		let roof_shape = p.shape(roof_form, shade).create();
		let x_axis_shape = p.shape(x_axis_form, shade).with_cull_mode(None).create();
		let y_axis_shape = p.shape(y_axis_form, shade).with_cull_mode(None).create();
		let z_axis_shape = p.shape(z_axis_form, shade).with_cull_mode(None).create();

		let vp_mat = p.bind_mat4();

		let canvas = p
			.layer()
			.with_shapes([
				ground_shape,
				wall_shape,
				roof_shape,
				x_axis_shape,
				y_axis_shape,
				z_axis_shape,
			])
			.with_clear_color(wgpu::Color {
				r: 0.5,
				g: 0.6,
				b: 0.7,
				a: 1.0,
			})
			.with_bindings(map! {
				0 => vp_mat.binding(),
			})
			.with_multisampling()
			.with_depth_test()
			.create();

		Self {
			cam,
			canvas,
			vp_mat,
			input: default(),
			cam_controller: BasicFirstPersonCameraController::new(1.0, 2.0),
		}
	}

	fn resize(&mut self, _p: &mut Painter, width: u32, height: u32) {
		self.cam.set_aspect_ratio(width as f32 / height as f32);
		self.cam_controller.set_screen_size(width, height);
	}

	fn frame(&mut self, p: &mut Painter, tpf: f32) {
		self.cam_controller
			.update_camera(&mut self.cam, &self.input, tpf);

		self.vp_mat.update(p, self.cam.view_proj_mat());

		p.paint_and_show(self.canvas);

		p.request_next_frame();
	}

	fn event(&mut self, e: Event<()>, _p: &mut Painter) {
		self.input.process_event(e);
	}
}

pub fn main() {
	App::create()
		.config(AppConfig {
			show_fps: true,
			use_vsync: true,
			remember_window_dimensions: true,
			..default()
		})
		.start();
}
</file>

<file path="instances/shader/src/lib.rs">
#![no_std]
#![allow(unexpected_cfgs)]

use spirv_std::glam::{Mat4, Vec3, Vec4};
use spirv_std::spirv;

#[spirv(vertex)]
pub fn vertex(
	position: Vec3,
	#[spirv(uniform, descriptor_set = 0, binding = 0)] vp_mat: &Mat4,
	#[spirv(uniform, descriptor_set = 0, binding = 1)] model_mat: &Mat4,
	#[spirv(position)] clip_pos: &mut Vec4,
) {
	*clip_pos = *vp_mat * *model_mat * position.extend(1.0);
}

#[spirv(fragment)]
pub fn fragment(
	#[spirv(uniform, descriptor_set = 0, binding = 2)] color: &Vec4,
	frag_color: &mut Vec4,
) {
	*frag_color = *color * 1.0;
}
</file>

<file path="instances/shader/Cargo.toml">
[package]
name = "instances_shader"
edition.workspace = true
version = "0.1.0"

[lib]
crate-type = ["rlib", "cdylib"]

[dependencies]
spirv-std.workspace = true
</file>

<file path="instances/shader/manifest.json">
[
  {
    "source_path": "fragment.spv",
    "entry_point": "fragment",
    "wgsl_entry_point": "fragment"
  },
  {
    "source_path": "vertex.spv",
    "entry_point": "vertex",
    "wgsl_entry_point": "vertex"
  }
]
</file>

<file path="instances/main.rs">
use trivalibs::{
	map,
	math::transform::Transform,
	painter::prelude::*,
	prelude::*,
	rendering::{
		camera::{CamProps, PerspectiveCamera},
		scene::SceneObject,
	},
};

const VERTICES: &[Vec3] = &[vec3(0.0, 5.0, 0.0), vec3(-2.5, 0., 0.0), vec3(2.5, 0., 0.0)];

struct Triangle {
	transform: Transform,
	speed: f32,
}

struct App {
	cam: PerspectiveCamera,
	triangles: Vec<Triangle>,

	canvas: Layer,
	model_mats: Vec<BindingBuffer<Mat4>>,
	vp_mat: BindingBuffer<Mat4>,
}

const TRIANGLE_COUNT: usize = 1100;

impl CanvasApp<()> for App {
	fn init(p: &mut Painter) -> Self {
		let mut triangles = Vec::with_capacity(TRIANGLE_COUNT);

		for _ in 0..TRIANGLE_COUNT {
			let scale = rand_vec3_range(1., 2.0);
			let mut t = Transform::from_translation(rand_vec3_range(-30.0, 30.0)).with_scale(scale);
			t.look_at(rand_vec3_range(-30.0, 30.0), Vec3::Y);
			triangles.push(Triangle {
				transform: t,
				speed: rand_range(0.1, 1.0) * rand_sign(),
			});
		}

		triangles.sort_by(|a, b| {
			a.transform
				.translation
				.z
				.partial_cmp(&b.transform.translation.z)
				.unwrap()
		});

		let shade = p
			.shade([Float32x3])
			.with_bindings([
				BINDING_BUFFER_VERT,
				BINDING_BUFFER_VERT,
				BINDING_BUFFER_FRAG,
			])
			.create();
		load_vertex_shader!(shade, p, "./shader/vertex.spv");
		load_fragment_shader!(shade, p, "./shader/fragment.spv");

		let form = p.form(VERTICES).create();

		let model_mats = (0..triangles.len())
			.map(|_| p.bind_mat4())
			.collect::<Vec<_>>();

		let cam = p.bind_mat4();

		let instances = model_mats
			.iter()
			.map(|model| InstanceBinding {
				bindings: map! {
					1 => model.binding(),
					2 => p.bind_const_vec4(rand_vec4())
				},
				..default()
			})
			.collect();

		let shape = p
			.shape(form, shade)
			.with_bindings(map! {
				0 => cam.binding()
			})
			.with_instances(instances)
			.with_cull_mode(None)
			.with_blend_state(wgpu::BlendState::ALPHA_BLENDING)
			.create();

		let canvas = p
			.layer()
			.with_shape(shape)
			.with_clear_color(wgpu::Color::BLACK)
			.with_multisampling()
			.create();

		Self {
			cam: PerspectiveCamera::create(CamProps {
				fov: Some(0.6),
				translation: Some(vec3(0.0, 0.0, 80.0)),
				..default()
			}),
			triangles,

			canvas,
			model_mats,
			vp_mat: cam,
		}
	}

	fn resize(&mut self, p: &mut Painter, width: u32, height: u32) {
		self.cam.set_aspect_ratio(width as f32 / height as f32);

		self.vp_mat.update(p, self.cam.view_proj_mat());
	}

	fn frame(&mut self, p: &mut Painter, tpf: f32) {
		p.request_next_frame();

		for (tri, model) in self.triangles.iter_mut().zip(self.model_mats.iter_mut()) {
			tri.transform.rotate_y(tpf * tri.speed);

			model.update(p, tri.transform.model_mat());
		}

		p.paint_and_show(self.canvas);
	}

	fn event(&mut self, _e: Event<()>, _p: &mut Painter) {}
}

pub fn main() {
	App::create()
		.config(AppConfig {
			show_fps: true,
			use_vsync: false,
			remember_window_dimensions: true,
			..default()
		})
		.start();
}
</file>

<file path="layer_tex/shader/src/lib.rs">
#![no_std]
#![allow(unexpected_cfgs)]

use spirv_std::glam::{vec4, Mat4, Vec2, Vec3, Vec4};
use spirv_std::{spirv, Image, Sampler};

#[spirv(vertex)]
pub fn color_vs(
	pos: Vec3,
	#[spirv(uniform, descriptor_set = 0, binding = 0)] mvp: &Mat4,
	#[spirv(position)] out_pos: &mut Vec4,
) {
	*out_pos = *mvp * pos.extend(1.0);
}

#[spirv(fragment)]
pub fn color_fs(#[spirv(uniform, descriptor_set = 0, binding = 1)] color: &Vec3, out: &mut Vec4) {
	*out = vec4(color.x, color.y, color.z, 1.0);
}

// Texture shader

#[spirv(vertex)]
pub fn texture_vs(
	pos: Vec3,
	uv: Vec2,
	#[spirv(uniform, descriptor_set = 0, binding = 0)] mvp: &Mat4,
	#[spirv(position)] out_pos: &mut Vec4,
	v_uv: &mut Vec2,
) {
	*out_pos = *mvp * pos.extend(1.0);
	*v_uv = uv;
}

#[spirv(fragment)]
pub fn texture_fs(
	uv: Vec2,
	#[spirv(descriptor_set = 0, binding = 1)] sampler: &Sampler,
	#[spirv(descriptor_set = 1, binding = 0)] tex: &Image!(2D, type=f32, sampled),
	out: &mut Vec4,
) {
	*out = tex.sample(*sampler, uv);
}
</file>

<file path="layer_tex/shader/Cargo.toml">
[package]
name = "layer_tex_shader"
edition.workspace = true
version = "0.1.0"

[lib]
crate-type = ["rlib", "cdylib"]

[dependencies]
spirv-std.workspace = true
</file>

<file path="layer_tex/shader/manifest.json">
[
  {
    "source_path": "color_fs.spv",
    "entry_point": "color_fs",
    "wgsl_entry_point": "color_fs"
  },
  {
    "source_path": "color_vs.spv",
    "entry_point": "color_vs",
    "wgsl_entry_point": "color_vs"
  },
  {
    "source_path": "texture_fs.spv",
    "entry_point": "texture_fs",
    "wgsl_entry_point": "texture_fs"
  },
  {
    "source_path": "texture_vs.spv",
    "entry_point": "texture_vs",
    "wgsl_entry_point": "texture_vs"
  }
]
</file>

<file path="layer_tex/main.rs">
use trivalibs::{
	map,
	math::transform::Transform,
	painter::prelude::*,
	prelude::*,
	rendering::{
		camera::{CamProps, PerspectiveCamera},
		scene::SceneObject,
	},
};

#[apply(gpu_data)]
struct Vertex {
	pos: Vec3,
	uv: Vec2,
}

const TRIANGLE: &[Vertex] = &[
	Vertex {
		pos: vec3(-1.0, -1.0, 0.0),
		uv: vec2(0.0, 1.0),
	},
	Vertex {
		pos: vec3(1.0, -1.0, 0.0),
		uv: vec2(1.0, 1.0),
	},
	Vertex {
		pos: vec3(0.0, 1.0, 0.0),
		uv: vec2(0.5, 0.0),
	},
];

const QUAD: &[Vertex] = &[
	Vertex {
		pos: vec3(-1.0, -1.0, 0.0),
		uv: vec2(0.0, 1.0),
	},
	Vertex {
		pos: vec3(1.0, -1.0, 0.0),
		uv: vec2(1.0, 1.0),
	},
	Vertex {
		pos: vec3(-1.0, 1.0, 0.0),
		uv: vec2(0.0, 0.0),
	},
	Vertex {
		pos: vec3(-1.0, 1.0, 0.0),
		uv: vec2(0.0, 0.0),
	},
	Vertex {
		pos: vec3(1.0, -1.0, 0.0),
		uv: vec2(1.0, 1.0),
	},
	Vertex {
		pos: vec3(1.0, 1.0, 0.0),
		uv: vec2(1.0, 0.0),
	},
];

const COLOR_TEX_SIZE_BIG: (u32, u32) = (800, 800);
const COLOR_TEX_SIZE_SMALL: (u32, u32) = (100, 100);

struct App {
	color_cam: PerspectiveCamera,
	tex_cam: PerspectiveCamera,
	triangle_transform: Transform,
	quad_transform: Transform,

	color_quad_mvp: BindingBuffer<Mat4>,
	color_triangle_mvp: BindingBuffer<Mat4>,
	tex_quad_mvp: BindingBuffer<Mat4>,
	tex_triangle_mvp: BindingBuffer<Mat4>,

	color_triangle_layer: Layer,
	color_quad_layer: Layer,
	canvas: Layer,

	is_big_tex: bool,
}

const YELLOW: wgpu::Color = wgpu::Color {
	r: 1.0,
	g: 1.0,
	b: 0.0,
	a: 1.0,
};

const GREEN: wgpu::Color = wgpu::Color {
	r: 0.0,
	g: 1.0,
	b: 0.0,
	a: 1.0,
};

#[derive(Debug, Clone, Copy)]
struct ResizeEvent;

impl CanvasApp<ResizeEvent> for App {
	fn init(p: &mut Painter) -> Self {
		let color_shade = p
			.shade([Float32x3, Float32x2])
			.with_bindings([BINDING_BUFFER_VERT, BINDING_BUFFER_FRAG])
			.create();
		load_vertex_shader!(color_shade, p, "./shader/color_vs.spv");
		load_fragment_shader!(color_shade, p, "./shader/color_fs.spv");

		let tex_shade = p
			.shade([Float32x3, Float32x2])
			.with_bindings([BINDING_BUFFER_VERT, BINDING_SAMPLER_FRAG])
			.with_layers([BINDING_LAYER_FRAG])
			.create();
		load_vertex_shader!(tex_shade, p, "./shader/texture_vs.spv");
		load_fragment_shader!(tex_shade, p, "./shader/texture_fs.spv");

		let quad_form = p.form(QUAD).create();
		let triangle_form = p.form(TRIANGLE).create();

		let color_quad_mvp = p.bind_mat4();
		let color_triangle_mvp = p.bind_mat4();

		let quad_color = p.bind_const_vec3(vec3(0.0, 0.0, 1.0));
		let triangle_color = p.bind_const_vec3(vec3(1.0, 0.0, 0.0));

		let color_quad_shape = p
			.shape(quad_form, color_shade)
			.with_bindings(map! {
				0 => color_quad_mvp.binding(),
				1 => quad_color,
			})
			.with_cull_mode(None)
			.create();

		let color_triangle_shape = p
			.shape(triangle_form, color_shade)
			.with_bindings(map! {
				0 => color_triangle_mvp.binding(),
				1 => triangle_color,
			})
			.with_cull_mode(None)
			.create();

		let color_triangle_layer = p
			.layer()
			.with_shape(color_triangle_shape)
			.with_size(COLOR_TEX_SIZE_BIG.0, COLOR_TEX_SIZE_BIG.1)
			.with_clear_color(YELLOW)
			.create();

		let sl = p.sampler_linear();
		let sn = p.sampler_nearest();

		let color_quad_layer = p
			.layer()
			.with_shape(color_quad_shape)
			.with_size(COLOR_TEX_SIZE_BIG.0, COLOR_TEX_SIZE_BIG.1)
			.with_clear_color(GREEN)
			.with_multisampling()
			.create();

		let tex_triangle_mvp = p.bind_mat4();
		let tex_quad_mvp = p.bind_mat4();

		let tex_quad_shape = p
			.shape(quad_form, tex_shade)
			.with_cull_mode(None)
			.with_bindings(map! {
				0 => tex_quad_mvp.binding(),
				1 => sn.binding(),
			})
			.with_layers(map! {
				0 => color_triangle_layer.binding()
			})
			.create();

		let tex_triangle_shape = p
			.shape(triangle_form, tex_shade)
			.with_bindings(map! {
				0 => tex_triangle_mvp.binding(),
				1 => sl.binding(),
			})
			.with_layers(map! {
				0 => color_quad_layer.binding()
			})
			.with_cull_mode(None)
			.create();

		let canvas = p
			.layer()
			.with_shapes([tex_quad_shape, tex_triangle_shape])
			.with_clear_color(wgpu::Color::BLACK)
			.with_depth_test()
			.with_multisampling()
			.create();

		Self {
			color_cam: PerspectiveCamera::create(CamProps {
				fov: Some(0.6),
				translation: vec3(0.0, 0.0, 5.0).into(),
				..default()
			}),
			tex_cam: PerspectiveCamera::create(CamProps {
				fov: Some(0.6),
				translation: vec3(0.0, 0.0, 5.0).into(),
				..default()
			}),
			triangle_transform: Transform::default(),
			quad_transform: Transform::default(),

			color_quad_mvp,
			color_triangle_mvp,
			tex_quad_mvp,
			tex_triangle_mvp,

			canvas,
			color_triangle_layer,
			color_quad_layer,

			is_big_tex: true,
		}
	}

	fn resize(&mut self, _p: &mut Painter, width: u32, height: u32) {
		self.tex_cam.set_aspect_ratio(width as f32 / height as f32);
	}

	fn frame(&mut self, p: &mut Painter, tpf: f32) {
		self.triangle_transform.rotate_y(0.25 * tpf);
		self.quad_transform.rotate_y(0.3 * tpf);

		self.color_triangle_mvp.update(
			p,
			self.triangle_transform.model_view_proj_mat(&self.color_cam),
		);
		self.tex_triangle_mvp.update(
			p,
			self.triangle_transform.model_view_proj_mat(&self.tex_cam),
		);

		self.color_quad_mvp
			.update(p, self.quad_transform.model_view_proj_mat(&self.color_cam));
		self.tex_quad_mvp
			.update(p, self.quad_transform.model_view_proj_mat(&self.tex_cam));

		p.paint(self.color_triangle_layer);
		p.paint(self.color_quad_layer);
		p.paint(self.canvas);
		p.show(self.canvas);

		p.request_next_frame();
	}

	fn event(&mut self, e: Event<ResizeEvent>, p: &mut Painter) {
		match e {
			Event::UserEvent(ResizeEvent) => {
				let size = if self.is_big_tex {
					COLOR_TEX_SIZE_SMALL
				} else {
					COLOR_TEX_SIZE_BIG
				};

				self.color_triangle_layer.resize(p, size.0, size.1);
				self.color_quad_layer.resize(p, size.0, size.1);

				if self.is_big_tex {
					self.color_triangle_layer.set_clear_color(p, Some(GREEN));
					self.color_quad_layer.set_clear_color(p, Some(YELLOW));
				} else {
					self.color_triangle_layer.set_clear_color(p, Some(YELLOW));
					self.color_quad_layer.set_clear_color(p, Some(GREEN));
				}

				self.is_big_tex = !self.is_big_tex;
			}
			_ => {}
		}
	}
}

pub fn main() {
	let app = App::create().config(AppConfig {
		show_fps: true,
		use_vsync: false,
		remember_window_dimensions: true,
		..default()
	});

	let handle = app.get_handle();

	std::thread::spawn(move || {
		loop {
			std::thread::sleep(std::time::Duration::from_secs(2));
			let _ = handle.send_event(ResizeEvent);
		}
	});

	app.start();
}
</file>

<file path="mipmap/shader/src/lib.rs">
#![no_std]
#![allow(unexpected_cfgs)]

#[allow(unused_imports)]
use spirv_std::num_traits::Float;
use spirv_std::spirv;
use spirv_std::{
	Image, Sampler,
	glam::{Mat2, UVec2, Vec2, Vec4, vec2, vec3},
};
use trivalibs_nostd::num_ext::NumExt;
use trivalibs_nostd::{color::hsv2rgb, random::hash::hash, vec_ext::VecExt};

pub fn aspect_preserving_uv(uv: Vec2, size: UVec2) -> Vec2 {
	let aspect = size.x as f32 / size.y as f32;
	if aspect > 1.0 {
		uv * vec2(1.0, 1.0 / aspect)
	} else {
		uv * vec2(aspect, 1.0)
	}
}

#[spirv(fragment)]
pub fn image(
	coord: Vec2,
	#[spirv(uniform, descriptor_set = 0, binding = 0)] size: &UVec2,
	#[spirv(uniform, descriptor_set = 0, binding = 1)] time: &f32,
	out: &mut Vec4,
) {
	let uv = aspect_preserving_uv(coord, *size).fit0111();
	let rot_mat = Mat2::from_angle(*time * 0.05);
	let uv = rot_mat * uv;
	let uv = uv * (7.0 + (*time * 0.1).sin());
	let mut idx = uv.floor();
	let mut uv = uv.frct();

	for i in 1..=3 {
		let h1 = hash((idx.x + (8.0 * i as f32) * idx.y + 8.0.powf(i as f32 + 1.0)) as u32);

		let should_subdivide = h1 < 0.5;
		let subdivision_dir_x = h1 < 0.25;

		if should_subdivide {
			uv = if subdivision_dir_x {
				vec2(uv.x * 2.0, uv.y)
			} else {
				vec2(uv.x, uv.y * 2.0)
			};

			idx = uv.floor() * 8.0 + idx;
			uv = uv.frct();

			let h2 = hash((idx.x + (8.0 * (1 + i) as f32) * idx.y + (8.0.powf(i as f32))) as u32);

			let should_subdivide = h2 < 0.5;

			if should_subdivide {
				uv = if subdivision_dir_x {
					vec2(uv.x, uv.y * 2.0)
				} else {
					vec2(uv.x * 2.0, uv.y)
				};

				idx = uv.floor() * (8.0 * (i + 2) as f32) + idx;
				uv = uv.frct();
			}
		}
	}

	let h = hash(((idx.x + (8.0 * 4.0) * idx.y) + 9.0.powf(4.0f32)) as u32);

	let color = hsv2rgb(vec3(h, 0.7, 0.7));

	*out = color.powf(2.2).extend(1.0);
}

#[spirv(fragment)]
pub fn mip_sampling(
	coord: Vec2,
	#[spirv(uniform, descriptor_set = 0, binding = 0)] time: &f32,
	#[spirv(uniform, descriptor_set = 0, binding = 1)] mips: &f32,
	#[spirv(descriptor_set = 0, binding = 2)] sampler: &Sampler,
	#[spirv(descriptor_set = 1, binding = 0)] tex: &Image!(2D, type=f32, sampled),
	out: &mut Vec4,
) {
	let col = tex.sample_by_lod(*sampler, coord, (*time * 0.2).sin().fit1101() * mips);
	*out = col;
}

#[spirv(fragment)]
pub fn wave_effect(
	coord: Vec2,
	#[spirv(uniform, descriptor_set = 0, binding = 0)] time: &f32,
	#[spirv(descriptor_set = 0, binding = 1)] sampler: &Sampler,
	#[spirv(descriptor_set = 1, binding = 0)] tex: &Image!(2D, type=f32, sampled),
	out: &mut Vec4,
) {
	let coord = vec2(coord.x + (coord.y * 30.0 + time).sin() * 0.005, coord.y);
	let col = tex.sample(*sampler, coord);
	*out = col;
}
</file>

<file path="mipmap/shader/Cargo.toml">
[package]
name = "mipmap_shader"
edition.workspace = true
version = "0.1.0"

[lib]
crate-type = ["rlib", "cdylib"]

[dependencies]
spirv-std.workspace = true
trivalibs-nostd.workspace = true
</file>

<file path="mipmap/shader/manifest.json">
[
  {
    "source_path": "image.spv",
    "entry_point": "image",
    "wgsl_entry_point": "image"
  },
  {
    "source_path": "mip_sampling.spv",
    "entry_point": "mip_sampling",
    "wgsl_entry_point": "mip_sampling"
  },
  {
    "source_path": "wave_effect.spv",
    "entry_point": "wave_effect",
    "wgsl_entry_point": "wave_effect"
  }
]
</file>

<file path="mipmap/main.rs">
use trivalibs::{map, painter::prelude::*, prelude::*};

struct App {
	time: f32,

	u_time: BindingBuffer<f32>,
	u_size: BindingBuffer<UVec2>,
	u_mip_levels: BindingBuffer<f32>,

	image: Layer,
	canvas: Layer,
}

impl CanvasApp<()> for App {
	fn init(p: &mut Painter) -> Self {
		let image_shade = p
			.shade_effect()
			.with_bindings([BINDING_BUFFER_FRAG, BINDING_BUFFER_FRAG])
			.create();
		load_fragment_shader!(image_shade, p, "./shader/image.spv");

		let u_time = p.bind_f32();
		let u_size = p.bind_uvec2();
		let u_mip_levels = p.bind_f32();

		let image_effect = p
			.effect(image_shade)
			.with_bindings(map! {
				0 => u_size.binding(),
				1 => u_time.binding()
			})
			.create();

		let image = p.layer().with_effect(image_effect).with_mips().create();

		let sample_shade = p
			.shade_effect()
			.with_bindings([
				BINDING_BUFFER_FRAG,
				BINDING_BUFFER_FRAG,
				BINDING_SAMPLER_FRAG,
			])
			.with_layer()
			.create();
		load_fragment_shader!(sample_shade, p, "./shader/mip_sampling.spv");

		let sampler = p
			.sampler()
			.with_filters(wgpu::FilterMode::Linear)
			.with_mipmap_filter(wgpu::FilterMode::Linear)
			.create();

		let sample_effect = p
			.effect(sample_shade)
			.with_bindings(map! {
				0 => u_time.binding(),
				1 => u_mip_levels.binding(),
				2 => sampler.binding()
			})
			.with_layers(map! { 1 => image.binding() })
			.create();

		let effect_shade = p
			.shade_effect()
			.with_bindings([BINDING_BUFFER_FRAG, BINDING_SAMPLER_FRAG])
			.with_layer()
			.create();
		load_fragment_shader!(effect_shade, p, "./shader/wave_effect.spv");

		let effect = p
			.effect(effect_shade)
			.with_bindings(map! {
				0 => u_time.binding(),
				1 => sampler.binding()
			})
			.create();

		let canvas = p.layer().with_effects([sample_effect, effect]).create();

		Self {
			time: 0.0,

			u_time,
			u_size,
			u_mip_levels,

			canvas,
			image,
		}
	}

	fn resize(&mut self, p: &mut Painter, width: u32, height: u32) {
		self.u_size.update(p, uvec2(width, height));

		let mips = self.image.get_mip_levels_count(p);
		println!("mip levels: {}", mips);
		self.u_mip_levels.update(p, mips as f32);

		let canvas_mips = self.canvas.get_mip_levels_count(p);
		println!("canvas mip levels: {}", canvas_mips);
	}

	fn frame(&mut self, p: &mut Painter, tpf: f32) {
		self.time += tpf;
		self.u_time.update(p, self.time);

		p.paint(self.image);
		p.paint_and_show(self.canvas);

		p.request_next_frame();
	}

	fn event(&mut self, _e: Event<()>, _p: &mut Painter) {}
}

pub fn main() {
	App::create()
		.config(AppConfig {
			show_fps: true,
			use_vsync: false,
			remember_window_dimensions: true,
			..default()
		})
		.start();
}
</file>

<file path="mouse_color/main.rs">
use trivalibs::painter::{
	Painter,
	app::{CanvasApp, Event},
	wgpu,
};

struct App {
	color: wgpu::Color,
}

impl CanvasApp<()> for App {
	fn init(_p: &mut Painter) -> Self {
		Self {
			color: wgpu::Color {
				r: 0.3,
				g: 0.3,
				b: 0.3,
				a: 1.0,
			},
		}
	}

	fn frame(&mut self, p: &mut Painter, _tpf: f32) {
		let frame = p.surface.get_current_texture().unwrap();

		let view = frame
			.texture
			.create_view(&wgpu::TextureViewDescriptor::default());

		let mut encoder = p
			.device
			.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: None });
		{
			encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
				label: None,
				color_attachments: &[Some(wgpu::RenderPassColorAttachment {
					view: &view,
					resolve_target: None,
					ops: wgpu::Operations {
						load: wgpu::LoadOp::Clear(self.color),
						store: wgpu::StoreOp::Store,
					},
					depth_slice: None,
				})],
				depth_stencil_attachment: None,
				timestamp_writes: None,
				occlusion_query_set: None,
			});
		}

		p.queue.submit(Some(encoder.finish()));
		frame.present();
	}

	fn event(&mut self, event: Event<()>, p: &mut Painter) {
		match event {
			Event::PointerMove { x, y, .. } => {
				let size = p.canvas_size();
				self.color = wgpu::Color {
					r: x / size.width as f64,
					g: y / size.height as f64,
					b: 0.3,
					a: 1.0,
				};
				p.request_next_frame();
			}
			_ => {}
		}
	}

	fn resize(&mut self, _p: &mut Painter, _w: u32, _h: u32) {}
}

pub fn main() {
	App::create().start();
}
</file>

<file path="noise_tests/shader/src/lib.rs">
#![no_std]
#![allow(unexpected_cfgs)]

#[allow(unused_imports)]
use spirv_std::num_traits::Float;
use spirv_std::{
	glam::{UVec2, Vec2, Vec3, Vec4, uvec2, vec2, vec3},
	spirv,
};
use trivalibs_nostd::{
	bits::FloatBits,
	num_ext::NumExt,
	random::{
		hash::{hash, hash2d, hash3d, hash21, hashi},
		simplex::{
			simplex_noise_2d, simplex_noise_3d, simplex_noise_4d, tiling_rot_noise_2d,
			tiling_rot_noise_3d, tiling_simplex_noise_2d,
		},
	},
};

const GAMMA: f32 = 2.2;

fn aspect_preserving_uv(uv: Vec2, size: UVec2) -> Vec2 {
	let aspect = size.x as f32 / size.y as f32;
	if aspect > 1.0 {
		uv * vec2(1.0, 1.0 / aspect)
	} else {
		uv * vec2(aspect, 1.0)
	}
}

#[spirv(fragment)]
pub fn simplex_3d_shader(
	uv: Vec2,
	#[spirv(uniform, descriptor_set = 0, binding = 0)] size: &UVec2,
	#[spirv(uniform, descriptor_set = 0, binding = 1)] time: &f32,
	out: &mut Vec4,
) {
	let uv = aspect_preserving_uv(uv, *size);
	let uv = uv * 10.0;

	let noise = simplex_noise_3d(uv.extend(*time)).fit1101();

	let color = Vec3::splat(noise).powf(GAMMA).extend(1.0);
	*out = color;
}

#[spirv(fragment)]
pub fn simplex_2d_shader(
	uv: Vec2,
	#[spirv(uniform, descriptor_set = 0, binding = 0)] size: &UVec2,
	#[spirv(uniform, descriptor_set = 0, binding = 1)] time: &f32,
	out: &mut Vec4,
) {
	let uv = aspect_preserving_uv(uv, *size);

	let noise = simplex_noise_2d(uv * (time.sin().fit1101() * 20. + 0.5)).fit1101();

	let color = Vec3::splat(noise).powf(GAMMA).extend(1.0);
	*out = color;
}

#[spirv(fragment)]
pub fn simplex_4d_shader(
	uv: Vec2,
	#[spirv(uniform, descriptor_set = 0, binding = 0)] size: &UVec2,
	#[spirv(uniform, descriptor_set = 0, binding = 1)] time: &f32,
	out: &mut Vec4,
) {
	let uv = aspect_preserving_uv(uv, *size);
	let uv = uv * 10.0;

	let noise = simplex_noise_4d(uv.extend(123. + *time * 0.2345).extend(*time)).fit1101();

	let color = Vec3::splat(noise).powf(GAMMA).extend(1.0);
	*out = color;
}

#[spirv(fragment)]
pub fn tiling_simplex_shader(
	uv: Vec2,
	#[spirv(uniform, descriptor_set = 0, binding = 0)] size: &UVec2,
	#[spirv(uniform, descriptor_set = 0, binding = 1)] time: &f32,
	out: &mut Vec4,
) {
	let uv = aspect_preserving_uv(uv, *size);

	let uv = (uv * 1.5 + *time * 0.1).fract();
	let scale = (time * 0.2).sin().fit1101() * 4. + 0.5;

	let noise = tiling_simplex_noise_2d(uv, scale).fit1101();

	let color = Vec3::splat(noise).powf(GAMMA).extend(1.0);
	*out = color;
}

#[spirv(fragment)]
pub fn tiling_noise_2d_shader(
	uv: Vec2,
	#[spirv(uniform, descriptor_set = 0, binding = 0)] size: &UVec2,
	#[spirv(uniform, descriptor_set = 0, binding = 1)] time: &f32,
	out: &mut Vec4,
) {
	let uv = aspect_preserving_uv(uv, *size);

	let noise = tiling_rot_noise_2d(
		(uv * 2.5).fract() * 4. + 0.5, // shift by 0.5 to avoid tiling artifacts
		vec2(1.0, 1.0) * 4.,
		*time * 0.8,
	)
	.0
	.fit1101();

	let color = Vec3::splat(noise).powf(GAMMA).extend(1.0);
	*out = color;
}

#[spirv(fragment)]
pub fn tiling_noise_3d_shader(
	uv: Vec2,
	#[spirv(uniform, descriptor_set = 0, binding = 0)] size: &UVec2,
	#[spirv(uniform, descriptor_set = 0, binding = 1)] time: &f32,
	out: &mut Vec4,
) {
	let uv = aspect_preserving_uv(uv, *size);

	let noise = tiling_rot_noise_3d(
		((uv * 2.5).fract() * 4. + 0.5) // shift by 0.5 to avoid tiling artifacts
			.extend(*time * 0.2),
		Vec3::ONE * 4.,
		*time * 0.3345,
	)
	.0
	.fit1101();

	let color = Vec3::splat(noise).powf(GAMMA).extend(1.0);
	*out = color;
}

#[spirv(fragment)]
pub fn hash_shader(
	uv: Vec2,
	#[spirv(uniform, descriptor_set = 0, binding = 0)] _size: &UVec2,
	#[spirv(uniform, descriptor_set = 0, binding = 1)] time: &f32,
	out: &mut Vec4,
) {
	*out = {
		let time = *time;
		let q_uv = (uv * 2.).fract();
		let q_idx = (uv * 2.).floor().as_uvec2();

		let color = if uv.x > 0.98 || uv.y > 0.98 || uv.x < 0.02 || uv.y < 0.02 {
			Vec3::ZERO
		} else if q_uv.x > 0.98 || q_uv.y > 0.98 || q_uv.x < 0.02 || q_uv.y < 0.02 {
			Vec3::ZERO
		} else if q_idx.eq(&uvec2(0, 0)) {
			let v = hash(q_uv.x.to_bits() + hashi((q_uv.y + time).to_bits()));
			vec3(v, 0.0, 0.0)
		} else if q_idx.eq(&uvec2(1, 0)) {
			let v = hash21((q_uv + time).to_bits());
			vec3(0.0, v, 0.0)
		} else if q_idx.eq(&uvec2(0, 1)) {
			let v = hash2d((q_uv + time).to_bits());
			v.extend(1.0)
		} else if q_idx.eq(&uvec2(1, 1)) {
			hash3d(q_uv.extend(time).to_bits())
		} else {
			vec3(0.0, 1.0, 1.0)
		};

		color.powf(GAMMA).extend(1.0)
	};
}
</file>

<file path="noise_tests/shader/Cargo.toml">
[package]
name = "noise_tests_shader"
version = "0.1.0"
edition.workspace = true

[lib]
crate-type = ["rlib", "cdylib"]

# Dependencies for CPU and GPU code
[dependencies]
spirv-std.workspace = true
trivalibs-nostd.workspace = true
</file>

<file path="noise_tests/shader/manifest.json">
[
  {
    "source_path": "hash_shader.spv",
    "entry_point": "hash_shader",
    "wgsl_entry_point": "hash_shader"
  },
  {
    "source_path": "simplex_2d_shader.spv",
    "entry_point": "simplex_2d_shader",
    "wgsl_entry_point": "simplex_2d_shader"
  },
  {
    "source_path": "simplex_3d_shader.spv",
    "entry_point": "simplex_3d_shader",
    "wgsl_entry_point": "simplex_3d_shader"
  },
  {
    "source_path": "simplex_4d_shader.spv",
    "entry_point": "simplex_4d_shader",
    "wgsl_entry_point": "simplex_4d_shader"
  },
  {
    "source_path": "tiling_noise_2d_shader.spv",
    "entry_point": "tiling_noise_2d_shader",
    "wgsl_entry_point": "tiling_noise_2d_shader"
  },
  {
    "source_path": "tiling_noise_3d_shader.spv",
    "entry_point": "tiling_noise_3d_shader",
    "wgsl_entry_point": "tiling_noise_3d_shader"
  },
  {
    "source_path": "tiling_simplex_shader.spv",
    "entry_point": "tiling_simplex_shader",
    "wgsl_entry_point": "tiling_simplex_shader"
  }
]
</file>

<file path="noise_tests/main.rs">
use trivalibs::{map, painter::prelude::*, prelude::*};

struct App {
	time: f32,
	u_size: BindingBuffer<UVec2>,
	u_time: BindingBuffer<f32>,

	layers: Vec<Layer>,
	current_layer: usize,
}

impl CanvasApp<()> for App {
	fn init(p: &mut Painter) -> Self {
		let u_size = p.bind_uvec2();
		let u_time = p.bind_f32();

		let shade_canvas = |p: &mut Painter| {
			let s = p
				.shade_effect()
				.with_bindings([BINDING_BUFFER_FRAG, BINDING_BUFFER_FRAG])
				.create();

			let e = p.effect(s).create();
			let layer = p
				.layer()
				.with_effect(e)
				.with_bindings(map! {
					0 => u_size.binding(),
					1 => u_time.binding()
				})
				.create();

			(s, layer)
		};

		let (s, simplex_2d_test) = shade_canvas(p);
		load_fragment_shader!(s, p, "./shader/simplex_2d_shader.spv");

		let (s, simplex_3d_test) = shade_canvas(p);
		load_fragment_shader!(s, p, "./shader/simplex_3d_shader.spv");

		let (s, simplex_4d_test) = shade_canvas(p);
		load_fragment_shader!(s, p, "./shader/simplex_4d_shader.spv");

		let (s, tiling_simplex_test) = shade_canvas(p);
		load_fragment_shader!(s, p, "./shader/tiling_simplex_shader.spv");

		let (s, tiling_noise_2d_test) = shade_canvas(p);
		load_fragment_shader!(s, p, "./shader/tiling_noise_2d_shader.spv");

		let (s, tiling_noise_3d_test) = shade_canvas(p);
		load_fragment_shader!(s, p, "./shader/tiling_noise_3d_shader.spv");

		let (s, hash_test) = shade_canvas(p);
		load_fragment_shader!(s, p, "./shader/hash_shader.spv");

		// return App

		Self {
			time: 0.0,
			u_size,
			u_time,

			layers: vec![
				hash_test,
				simplex_2d_test,
				simplex_3d_test,
				simplex_4d_test,
				tiling_simplex_test,
				tiling_noise_2d_test,
				tiling_noise_3d_test,
			],
			current_layer: 0,
		}
	}

	fn resize(&mut self, p: &mut Painter, width: u32, height: u32) {
		self.u_size.update(p, uvec2(width, height));
	}

	fn frame(&mut self, p: &mut Painter, tpf: f32) {
		self.time += tpf;
		self.u_time.update(p, self.time);

		let layer = self.layers[self.current_layer];

		p.paint_and_show(layer);

		p.request_next_frame();
	}

	fn event(&mut self, e: Event<()>, _p: &mut Painter) {
		if let Event::PointerUp { button, .. } = e {
			if button == PointerButton::Primary {
				self.current_layer = (self.current_layer + 1) % self.layers.len();
			} else {
				self.current_layer =
					(self.current_layer + self.layers.len() - 1) % self.layers.len();
			}
		}
	}
}

pub fn main() {
	App::create()
		.config(AppConfig {
			show_fps: true,
			use_vsync: false,
			remember_window_dimensions: true,
			..default()
		})
		.start();
}
</file>

<file path="random_lines/shader/src/lib.rs">
#![no_std]
#![allow(unexpected_cfgs)]

use spirv_std::glam::{Vec2, Vec3, Vec4};
use spirv_std::spirv;

#[spirv(vertex)]
pub fn vertex(position: Vec2, #[spirv(position)] clip_pos: &mut Vec4) {
	*clip_pos = position.extend(0.0).extend(1.0);
}

#[spirv(fragment)]
pub fn fragment(
	#[spirv(uniform, descriptor_set = 0, binding = 0)] color: &Vec3,
	frag_color: &mut Vec4,
) {
	*frag_color = color.powf(2.2).extend(1.0);
}
</file>

<file path="random_lines/shader/Cargo.toml">
[package]
name = "random_lines_shader"
edition.workspace = true
version = "0.1.0"

[lib]
crate-type = ["rlib", "cdylib"]

[dependencies]
spirv-std.workspace = true
</file>

<file path="random_lines/shader/manifest.json">
[
  {
    "source_path": "fragment.spv",
    "entry_point": "fragment",
    "wgsl_entry_point": "fragment"
  },
  {
    "source_path": "vertex.spv",
    "entry_point": "vertex",
    "wgsl_entry_point": "vertex"
  }
]
</file>

<file path="random_lines/main.rs">
use trivalibs::{
	map,
	painter::{form::Form, prelude::*},
	prelude::*,
};

struct App {
	canvas: Layer,
	form: Form,
	color_binding: BindingBuffer<Vec3U>,
	timer: f32,
}

// Generate a single line made of multiple quad segments
fn generate_line_geometry(start: Vec2, end: Vec2, width: f32, segments: usize) -> Vec<Vec2> {
	let mut vertices = Vec::new();

	let dir = (end - start).normalize();
	let perp = vec2(-dir.y, dir.x) * (width * 0.5);

	for i in 0..segments {
		let t0 = i as f32 / segments as f32;
		let t1 = (i + 1) as f32 / segments as f32;

		let p0 = start + dir * (t0 * (end - start).length());
		let p1 = start + dir * (t1 * (end - start).length());

		// Create quad for this segment (two triangles)
		// Triangle 1
		vertices.push(vec2(p0.x - perp.x, p0.y - perp.y));
		vertices.push(vec2(p1.x + perp.x, p1.y + perp.y));
		vertices.push(vec2(p0.x + perp.x, p0.y + perp.y));

		// Triangle 2
		vertices.push(vec2(p0.x - perp.x, p0.y - perp.y));
		vertices.push(vec2(p1.x - perp.x, p1.y - perp.y));
		vertices.push(vec2(p1.x + perp.x, p1.y + perp.y));
	}

	vertices
}

// Generate random lines with varying segment counts - each line as separate vector
fn generate_all_lines() -> Vec<Vec<Vec2>> {
	let line_count = rand_range(1.0, 10.0) as usize;
	let mut all_lines = Vec::new();

	for _ in 0..line_count {
		let start = vec2(rand_range(-0.9, 0.9), rand_range(-0.9, 0.9));
		let end = vec2(rand_range(-0.9, 0.9), rand_range(-0.9, 0.9));
		let segments = rand_range(1.0, 10.0) as usize;

		// Width in normalized device coordinates (60px relative to screen)
		let width = 0.06;

		let line_verts = generate_line_geometry(start, end, width, segments);
		all_lines.push(line_verts);
	}

	all_lines
}

impl CanvasApp<()> for App {
	fn init(p: &mut Painter) -> Self {
		// Generate initial geometry - each line gets its own buffer
		let initial_lines = generate_all_lines();

		// Create form with initial data using FormBuilder with_buffers
		// Pass the Vec directly - each Vec<Vec3> converts to FormBuffer automatically
		let form = p.form_builder().with_buffers(&initial_lines).create();

		// Create shade with vec3 position and vec3 color uniform
		let shade = p
			.shade([Float32x2])
			.with_bindings([BINDING_BUFFER_FRAG])
			.create();

		// Load shaders
		load_vertex_shader!(shade, p, "./shader/vertex.spv");
		load_fragment_shader!(shade, p, "./shader/fragment.spv");

		// Create color binding with random initial color
		let color_binding = p.bind_vec3();
		color_binding.update_vec3(p, rand_vec3());

		// Create shape
		let shape = p
			.shape(form, shade)
			.with_bindings(map! {
				0 => color_binding.binding(),
			})
			.create();

		let canvas = p
			.layer()
			.with_shape(shape)
			.with_clear_color(wgpu::Color::WHITE)
			.with_multisampling()
			.create();

		Self {
			canvas,
			form,
			color_binding,
			timer: 0.0,
		}
	}

	fn frame(&mut self, p: &mut Painter, tpf: f32) {
		self.timer += tpf;

		// Every second, regenerate geometry and color
		if self.timer >= 1.0 {
			self.timer -= 1.0;

			// Generate new random lines - each line as separate buffer
			let new_lines = generate_all_lines();

			// Update form with all new geometries using update_all
			// Pass the Vec directly - each Vec<Vec2> converts to FormBuffer automatically
			self.form.update_all(p, &new_lines);

			// Update color with new random color
			self.color_binding.update_vec3(p, rand_vec3());

			let total_vertices: usize = new_lines.iter().map(|l| l.len()).sum();
			println!(
				"\nGenerated {} lines with {} total vertices",
				new_lines.len(),
				total_vertices
			);
		}

		p.paint_and_show(self.canvas);

		// Request continuous rendering
		p.request_next_frame();
	}

	fn resize(&mut self, _p: &mut Painter, _width: u32, _height: u32) {}
	fn event(&mut self, _e: Event<()>, _p: &mut Painter) {}
}

pub fn main() {
	App::create()
		.config(AppConfig {
			show_fps: true,
			use_vsync: false,
			remember_window_dimensions: true,
			..default()
		})
		.start();
}
</file>

<file path="render_to_mip/shader/src/lib.rs">
#![no_std]
#![allow(unexpected_cfgs)]

use spirv_std::glam::Vec3;
#[allow(unused_imports)]
use spirv_std::num_traits::Float;
use spirv_std::spirv;
use spirv_std::{
	Image, Sampler,
	glam::{UVec2, Vec2, Vec4, swizzles::*, vec2},
};
use trivalibs_nostd::num_ext::NumExt;
use trivalibs_nostd::vec_ext::VecExt;

pub fn aspect_preserving_uv(uv: Vec2, size: UVec2) -> Vec2 {
	let aspect = size.x as f32 / size.y as f32;
	if aspect > 1.0 {
		uv * vec2(1.0, 1.0 / aspect)
	} else {
		uv * vec2(aspect, 1.0)
	}
}

#[spirv(fragment)]
pub fn image(
	coord: Vec2,
	#[spirv(uniform, descriptor_set = 0, binding = 0)] color: &Vec3,
	#[spirv(descriptor_set = 0, binding = 1)] sampler: &Sampler,
	#[spirv(descriptor_set = 1, binding = 0)] tex: &Image!(2D, type=f32, sampled),
	out: &mut Vec4,
) {
	let coord = coord * 2.0;
	let idx = coord.floor();
	let coord = coord.frct();

	let color = if idx.x + idx.y == 1.0 {
		*color
	} else {
		let col = tex.sample(*sampler, coord);
		col.xyz()
	};

	*out = color.extend(1.0);
}

#[spirv(fragment)]
pub fn mip_sampling(
	coord: Vec2,
	#[spirv(uniform, descriptor_set = 0, binding = 0)] time: &f32,
	#[spirv(uniform, descriptor_set = 0, binding = 1)] mips: &f32,
	#[spirv(descriptor_set = 0, binding = 2)] sampler: &Sampler,
	#[spirv(descriptor_set = 1, binding = 0)] tex: &Image!(2D, type=f32, sampled),
	out: &mut Vec4,
) {
	let col = tex.sample_by_lod(*sampler, coord, (*time * 0.1).frct() * mips);
	*out = col;
}
</file>

<file path="render_to_mip/shader/Cargo.toml">
[package]
name = "render_to_mip_shader"
edition.workspace = true
version = "0.1.0"

[lib]
crate-type = ["rlib", "cdylib"]

[dependencies]
spirv-std.workspace = true
trivalibs-nostd.workspace = true
</file>

<file path="render_to_mip/shader/manifest.json">
[
  {
    "source_path": "image.spv",
    "entry_point": "image",
    "wgsl_entry_point": "image"
  },
  {
    "source_path": "mip_sampling.spv",
    "entry_point": "mip_sampling",
    "wgsl_entry_point": "mip_sampling"
  }
]
</file>

<file path="render_to_mip/main.rs">
use trivalibs::{map, painter::prelude::*, prelude::*};
use trivalibs_nostd::color::hsv2rgb;

struct App {
	time: f32,

	u_time: BindingBuffer<f32>,
	u_mip_levels: BindingBuffer<f32>,

	image: Layer,
	canvas: Layer,
}

const MIP_EFFECT_COUNT: u32 = 8;

impl CanvasApp<()> for App {
	fn init(p: &mut Painter) -> Self {
		let image_shade = p
			.shade_effect()
			.with_bindings([BINDING_BUFFER_FRAG, BINDING_SAMPLER_FRAG])
			.with_layer()
			.create();
		load_fragment_shader!(image_shade, p, "./shader/image.spv");

		let sampler = p
			.sampler()
			.with_filters(wgpu::FilterMode::Nearest)
			.with_mipmap_filter(wgpu::FilterMode::Linear)
			.create();

		let mut effects = vec![];

		for i in 1..MIP_EFFECT_COUNT {
			let color_shift = i as f32 / MIP_EFFECT_COUNT as f32;
			let color = hsv2rgb(vec3(color_shift, 1.0, 0.7));
			let color_binding = p.bind_const_vec3(color);
			let i = MIP_EFFECT_COUNT - i;
			effects.push(
				p.effect(image_shade)
					.with_bindings(map! {
						0 => color_binding,
						1 => sampler.binding(),
					})
					.with_mip_source(i)
					.with_mip_target(i - 1)
					.create(),
			);
		}

		let image = p
			.layer()
			.with_effects(effects)
			.with_mips_max(MIP_EFFECT_COUNT)
			.create();

		let u_time = p.bind_f32();
		let u_mip_levels = p.bind_f32();

		let sample_shade = p
			.shade_effect()
			.with_bindings([
				BINDING_BUFFER_FRAG,
				BINDING_BUFFER_FRAG,
				BINDING_SAMPLER_FRAG,
			])
			.with_layer()
			.create();
		load_fragment_shader!(sample_shade, p, "./shader/mip_sampling.spv");

		let sample_effect = p
			.effect(sample_shade)
			.with_bindings(map! {
				0 => u_time.binding(),
				1 => u_mip_levels.binding(),
				2 => sampler.binding()
			})
			.with_layers(map! { 1 => image.binding() })
			.create();

		let canvas = p.layer().with_effects([sample_effect]).create();

		Self {
			time: 0.0,

			u_time,
			u_mip_levels,

			canvas,
			image,
		}
	}

	fn resize(&mut self, p: &mut Painter, _width: u32, _height: u32) {
		let mips = self.image.get_mip_levels_count(p);
		self.u_mip_levels.update(p, mips as f32);
	}

	fn frame(&mut self, p: &mut Painter, tpf: f32) {
		self.time += tpf;
		self.u_time.update(p, self.time);

		p.paint(self.image);
		p.paint_and_show(self.canvas);

		p.request_next_frame();
	}

	fn event(&mut self, _e: Event<()>, _p: &mut Painter) {}
}

pub fn main() {
	App::create()
		.config(AppConfig {
			show_fps: true,
			use_vsync: false,
			remember_window_dimensions: true,
			..default()
		})
		.start();
}
</file>

<file path="shader_image/shader/src/lib.rs">
#![no_std]
#![allow(unexpected_cfgs)]

use spirv_std::glam::{vec2, vec4, Vec2, Vec4};
#[allow(unused_imports)]
use spirv_std::num_traits::Float;
use spirv_std::spirv;

#[spirv(fragment)]
pub fn main_fs(uv: Vec2, output: &mut Vec4) {
	let tile_size = vec2(6.0, 12.0);
	let gap_size = tile_size * 0.02;
	let mut tile = uv * tile_size;
	let y_offet = tile.y.floor() % 2.0;
	if y_offet == 1.0 {
		tile.x += 0.5;
	}
	tile -= gap_size * 0.5;
	let tile = tile - tile.floor();
	*output = if tile.x >= 1.0 - gap_size.x || tile.y >= 1.0 - gap_size.y {
		vec4(0.4, 0.6, 0.9, 1.0)
	} else {
		vec4(1.0, 0.8, 0.5, 1.0)
	}
}

#[spirv(vertex)]
pub fn main_vs(
	#[spirv(vertex_index)] vert_idx: i32,
	#[spirv(position)] builtin_pos: &mut Vec4,
	uv: &mut Vec2,
) {
	*uv = vec2(((vert_idx << 1) & 2) as f32, (vert_idx & 2) as f32);
	let pos = *uv * 2.0 - Vec2::ONE;
	*builtin_pos = pos.extend(0.0).extend(1.0);
}
</file>

<file path="shader_image/shader/Cargo.toml">
[package]
name = "shader_image_shader"
edition.workspace = true
version = "0.1.0"

[lib]
crate-type = ["rlib", "cdylib"]

[dependencies]
spirv-std.workspace = true
</file>

<file path="shader_image/shader/manifest.json">
[
  {
    "source_path": "main_fs.spv",
    "entry_point": "main_fs",
    "wgsl_entry_point": "main_fs"
  },
  {
    "source_path": "main_vs.spv",
    "entry_point": "main_vs",
    "wgsl_entry_point": "main_vs"
  }
]
</file>

<file path="shader_image/main.rs">
use std::io::Write;
use trivalibs::painter::wgpu::{self, include_spirv};

fn output_image_native(image_data: Vec<u8>, texture_dims: (usize, usize), path: String) {
	let mut png_data = Vec::<u8>::with_capacity(image_data.len());
	let mut encoder = png::Encoder::new(
		std::io::Cursor::new(&mut png_data),
		texture_dims.0 as u32,
		texture_dims.1 as u32,
	);
	encoder.set_color(png::ColorType::Rgba);
	let mut png_writer = encoder.write_header().unwrap();
	png_writer.write_image_data(&image_data[..]).unwrap();
	png_writer.finish().unwrap();
	log::info!("PNG file encoded in memory.");

	let mut file = std::fs::File::create(&path).unwrap();
	file.write_all(&png_data[..]).unwrap();
	log::info!("PNG file written to disc as \"{}\".", path);
}

const TEXTURE_DIMS: (usize, usize) = (512, 512);

async fn run(_path: Option<String>) {
	// This will later store the raw pixel value data locally. We'll create it now as
	// a convenient size reference.
	let mut texture_data = Vec::<u8>::with_capacity(TEXTURE_DIMS.0 * TEXTURE_DIMS.1 * 4);

	let instance = wgpu::Instance::default();
	let adapter = instance
		.request_adapter(&wgpu::RequestAdapterOptions::default())
		.await
		.unwrap();
	let (device, queue) = adapter
		.request_device(&wgpu::DeviceDescriptor {
			label: None,
			required_features: wgpu::Features::empty(),
			required_limits: wgpu::Limits::downlevel_defaults(),
			memory_hints: wgpu::MemoryHints::MemoryUsage,
			trace: wgpu::Trace::Off,
		})
		.await
		.unwrap();

	// Load the shaders from disk
	let vert = device.create_shader_module(include_spirv!("./shader/main_vs.spv"));
	let frag = device.create_shader_module(include_spirv!("./shader/main_fs.spv"));

	let render_target = device.create_texture(&wgpu::TextureDescriptor {
		label: None,
		size: wgpu::Extent3d {
			width: TEXTURE_DIMS.0 as u32,
			height: TEXTURE_DIMS.1 as u32,
			depth_or_array_layers: 1,
		},
		mip_level_count: 1,
		sample_count: 1,
		dimension: wgpu::TextureDimension::D2,
		format: wgpu::TextureFormat::Rgba8UnormSrgb,
		usage: wgpu::TextureUsages::RENDER_ATTACHMENT | wgpu::TextureUsages::COPY_SRC,
		view_formats: &[wgpu::TextureFormat::Rgba8UnormSrgb],
	});
	let output_staging_buffer = device.create_buffer(&wgpu::BufferDescriptor {
		label: None,
		size: texture_data.capacity() as u64,
		usage: wgpu::BufferUsages::COPY_DST | wgpu::BufferUsages::MAP_READ,
		mapped_at_creation: false,
	});

	let pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
		label: None,
		layout: None,
		vertex: wgpu::VertexState {
			module: &vert,
			entry_point: None,
			compilation_options: Default::default(),
			buffers: &[],
		},
		fragment: Some(wgpu::FragmentState {
			module: &frag,
			entry_point: None,
			compilation_options: Default::default(),
			targets: &[Some(wgpu::TextureFormat::Rgba8UnormSrgb.into())],
		}),
		primitive: wgpu::PrimitiveState::default(),
		depth_stencil: None,
		multisample: wgpu::MultisampleState::default(),
		multiview: None,
		cache: None,
	});

	log::info!("Wgpu context set up.");

	//-----------------------------------------------

	let texture_view = render_target.create_view(&wgpu::TextureViewDescriptor::default());

	let mut command_encoder =
		device.create_command_encoder(&wgpu::CommandEncoderDescriptor::default());
	{
		let mut render_pass = command_encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
			label: None,
			color_attachments: &[Some(wgpu::RenderPassColorAttachment {
				view: &texture_view,
				resolve_target: None,
				ops: wgpu::Operations {
					load: wgpu::LoadOp::Clear(wgpu::Color::GREEN),
					store: wgpu::StoreOp::Store,
				},
				depth_slice: None,
			})],
			depth_stencil_attachment: None,
			occlusion_query_set: None,
			timestamp_writes: None,
		});
		render_pass.set_pipeline(&pipeline);
		render_pass.draw(0..3, 0..1);
	}
	// The texture now contains our rendered image
	command_encoder.copy_texture_to_buffer(
		wgpu::TexelCopyTextureInfo {
			texture: &render_target,
			mip_level: 0,
			origin: wgpu::Origin3d::ZERO,
			aspect: wgpu::TextureAspect::All,
		},
		wgpu::TexelCopyBufferInfo {
			buffer: &output_staging_buffer,
			layout: wgpu::TexelCopyBufferLayout {
				offset: 0,
				// This needs to be a multiple of 256. Normally we would need to pad
				// it but we here know it will work out anyways.
				bytes_per_row: Some((TEXTURE_DIMS.0 * 4) as u32),
				rows_per_image: Some(TEXTURE_DIMS.1 as u32),
			},
		},
		wgpu::Extent3d {
			width: TEXTURE_DIMS.0 as u32,
			height: TEXTURE_DIMS.1 as u32,
			depth_or_array_layers: 1,
		},
	);
	queue.submit(Some(command_encoder.finish()));
	log::info!("Commands submitted.");

	//-----------------------------------------------

	// Time to get our image.
	let buffer_slice = output_staging_buffer.slice(..);
	let (sender, receiver) = flume::bounded(1);
	buffer_slice.map_async(wgpu::MapMode::Read, move |r| sender.send(r).unwrap());
	device.poll(wgpu::PollType::Wait).unwrap();
	receiver.recv_async().await.unwrap().unwrap();
	log::info!("Output buffer mapped.");
	{
		let view = buffer_slice.get_mapped_range();
		texture_data.extend_from_slice(&view[..]);
	}
	log::info!("Image data copied to local.");
	output_staging_buffer.unmap();

	output_image_native(texture_data.to_vec(), TEXTURE_DIMS, _path.unwrap());
	log::info!("Done.");
}

pub fn main() {
	env_logger::builder()
		.filter_level(log::LevelFilter::Info)
		.format_timestamp(None)
		.init();

	let path = std::env::args()
		.nth(2)
		.unwrap_or_else(|| "output.png".to_string());

	pollster::block_on(run(Some(path)));
}
</file>

<file path="simple_triangle/shader/src/lib.rs">
#![no_std]
#![allow(unexpected_cfgs)]

use spirv_std::glam::{Mat4, Vec3, Vec4};
use spirv_std::spirv;

#[spirv(vertex)]
pub fn vertex(
	position: Vec3,
	#[spirv(uniform, descriptor_set = 0, binding = 0)] vp_mat: &Mat4,
	#[spirv(uniform, descriptor_set = 0, binding = 1)] model_mat: &Mat4,
	#[spirv(position)] clip_pos: &mut Vec4,
) {
	*clip_pos = *vp_mat * *model_mat * position.extend(1.0);
}

#[spirv(fragment)]
pub fn fragment(
	#[spirv(uniform, descriptor_set = 0, binding = 2)] color: &Vec4,
	frag_color: &mut Vec4,
) {
	*frag_color = *color * 1.0;
}
</file>

<file path="simple_triangle/shader/Cargo.toml">
[package]
name = "simple_triangle_shader"
edition.workspace = true
version = "0.1.0"

[lib]
crate-type = ["rlib", "cdylib"]

[dependencies]
spirv-std.workspace = true
</file>

<file path="simple_triangle/shader/manifest.json">
[
  {
    "source_path": "fragment.spv",
    "entry_point": "fragment",
    "wgsl_entry_point": "fragment"
  },
  {
    "source_path": "vertex.spv",
    "entry_point": "vertex",
    "wgsl_entry_point": "vertex"
  }
]
</file>

<file path="simple_triangle/main.rs">
use trivalibs::{
	map,
	math::transform::Transform,
	painter::prelude::*,
	prelude::*,
	rendering::{
		camera::{CamProps, PerspectiveCamera},
		scene::SceneObject,
	},
};

const VERTICES: &[Vec3] = &[vec3(0.0, 5.0, 0.0), vec3(-2.5, 0., 0.0), vec3(2.5, 0., 0.0)];

struct App {
	cam: PerspectiveCamera,
	transform: Transform,
	model_mat: BindingBuffer<Mat4>,
	vp_mat: BindingBuffer<Mat4>,

	canvas: Layer,
}

impl CanvasApp<()> for App {
	fn init(p: &mut Painter) -> Self {
		let shade = p
			.shade([Float32x3])
			.with_bindings([
				BINDING_BUFFER_VERT,
				BINDING_BUFFER_VERT,
				BINDING_BUFFER_FRAG,
			])
			.create();
		load_vertex_shader!(shade, p, "./shader/vertex.spv");
		load_fragment_shader!(shade, p, "./shader/fragment.spv");

		let form = p.form(VERTICES).create();

		let model_mat = p.bind_mat4();
		let cam = p.bind_mat4();

		let color = p.bind_const_vec4(vec4(1.0, 0.0, 0.0, 1.0));
		let shape = p
			.shape(form, shade)
			.with_bindings(map! {
				0 => cam.binding(),
				1 => model_mat.binding(),
				2 => color,
			})
			.with_cull_mode(None)
			.create();

		let canvas = p
			.layer()
			.with_shape(shape)
			.with_clear_color(wgpu::Color::BLACK)
			.with_multisampling()
			.create();

		let transform =
			Transform::from_translation(vec3(0.0, -20.0, 0.0)).with_scale(Vec3::splat(8.0));

		Self {
			cam: PerspectiveCamera::create(CamProps {
				fov: Some(0.6),
				translation: Some(vec3(0.0, 0.0, 80.0)),
				..default()
			}),
			transform,
			model_mat,
			vp_mat: cam,

			canvas,
		}
	}

	fn resize(&mut self, p: &mut Painter, width: u32, height: u32) {
		self.cam.set_aspect_ratio(width as f32 / height as f32);

		self.vp_mat.update(p, self.cam.view_proj_mat());
	}

	fn frame(&mut self, p: &mut Painter, tpf: f32) {
		self.transform.rotate_y(tpf * 0.5);
		self.model_mat.update(p, self.transform.model_mat());

		p.paint_and_show(self.canvas);

		p.request_next_frame();
	}

	fn event(&mut self, _e: Event<()>, _p: &mut Painter) {}
}

pub fn main() {
	App::create()
		.config(AppConfig {
			show_fps: true,
			use_vsync: false,
			remember_window_dimensions: true,
			..default()
		})
		.start();
}
</file>

<file path="triangle/shader/src/lib.rs">
#![no_std]
#![allow(unexpected_cfgs)]

#[cfg(target_arch = "spirv")]
use spirv_std::glam::{vec4, Vec2, Vec3, Vec4};
use spirv_std::{glam::vec2, spirv, Image, Sampler};
#[cfg(not(target_arch = "spirv"))]
use trivalibs::glam::{vec4, Vec2, Vec3, Vec4};
#[cfg(not(target_arch = "spirv"))]
use trivalibs::macros::*;

#[cfg(not(target_arch = "spirv"))]
#[apply(gpu_data)]
pub struct Vertex {
	pub position: Vec3,
	pub color: Vec3,
	pub uv: Vec2,
}

#[spirv(vertex)]
pub fn vertex(
	position: Vec3,
	color: Vec3,
	uv: Vec2,
	#[spirv(position)] clip_pos: &mut Vec4,
	out_color: &mut Vec3,
	out_uv: &mut Vec2,
) {
	*out_color = color;
	*out_uv = uv;
	*clip_pos = position.extend(1.0);
}

#[spirv(fragment)]
pub fn fragment(
	in_color: Vec3,
	in_uv: Vec2,
	#[spirv(descriptor_set = 0, binding = 0)] tex: &Image!(2D, type=f32, sampled),
	#[spirv(descriptor_set = 0, binding = 1)] sampler: &Sampler,
	frag_color: &mut Vec4,
) {
	let col = tex.sample(*sampler, vec2(in_uv.x, in_uv.y));
	*frag_color = vec4(col.x, col.y, col.z, 1.0) * in_color.extend(1.0);
}
</file>

<file path="triangle/shader/Cargo.toml">
[package]
name = "test_triangle_shader"
edition.workspace = true
version = "0.1.0"

[lib]
crate-type = ["rlib", "cdylib"]

# Dependencies for CPU and GPU code
[dependencies]
spirv-std.workspace = true

# dependencies for CPU code
[target.'cfg(not(target_arch = "spirv"))'.dependencies]
trivalibs.workspace = true
bytemuck.workspace = true
</file>

<file path="triangle/shader/manifest.json">
[
  {
    "source_path": "fragment.spv",
    "entry_point": "fragment",
    "wgsl_entry_point": "fragment"
  },
  {
    "source_path": "vertex.spv",
    "entry_point": "vertex",
    "wgsl_entry_point": "vertex"
  }
]
</file>

<file path="triangle/src/main.rs">
use shader::Vertex;
use trivalibs::painter::{
	Painter,
	app::{CanvasApp, Event},
	wgpu::{self, include_spirv, util::DeviceExt},
};
use trivalibs::prelude::*;

const VERTICES: &[Vertex] = &[
	Vertex {
		position: vec3(0.0, 0.5, 0.0),
		color: vec3(1.0, 0.0, 0.0),
		uv: vec2(0.5, 1.0),
	},
	Vertex {
		position: vec3(-0.5, -0.5, 0.0),
		color: vec3(0.0, 1.0, 0.0),
		uv: vec2(0.0, 0.0),
	},
	Vertex {
		position: vec3(0.5, -0.5, 0.0),
		color: vec3(0.0, 0.0, 1.0),
		uv: vec2(1.0, 0.0),
	},
];

struct App {
	pipeline: wgpu::RenderPipeline,
	buffer: wgpu::Buffer,
	diffuse_bind_group: wgpu::BindGroup,
}

impl CanvasApp<()> for App {
	fn init(p: &mut Painter) -> Self {
		// Initialize the app

		let buffer = p
			.device
			.create_buffer_init(&wgpu::util::BufferInitDescriptor {
				label: Some("Vertex Buffer"),
				contents: bytemuck::cast_slice(VERTICES),
				usage: wgpu::BufferUsages::VERTEX,
			});

		let tex_bytes = include_bytes!("../texture.png");
		let mut reader = png::Decoder::new(std::io::Cursor::new(tex_bytes))
			.read_info()
			.unwrap();
		// Allocate the output buffer.
		let mut buf = vec![0; reader.output_buffer_size().unwrap()];
		// Read the next frame. An APNG might contain multiple frames.
		let info = reader.next_frame(&mut buf).unwrap();
		// Grab the bytes of the image.
		let tex_rgba = &buf[..info.buffer_size()];
		let dimensions = (info.width, info.height);

		let texture_size = wgpu::Extent3d {
			width: dimensions.0,
			height: dimensions.1,
			depth_or_array_layers: 1,
		};

		let diffuse_texture = p.device.create_texture(&wgpu::TextureDescriptor {
			// All textures are stored as 3D, we represent our 2D texture
			// by setting depth to 1.
			size: texture_size,
			mip_level_count: 1, // We'll talk about this a little later
			sample_count: 1,
			dimension: wgpu::TextureDimension::D2,
			// Most images are stored using sRGB, so we need to reflect that here.
			format: wgpu::TextureFormat::Rgba8UnormSrgb,
			// TEXTURE_BINDING tells wgpu that we want to use this texture in shaders
			// COPY_DST means that we want to copy data to this texture
			usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
			label: Some("diffuse_texture"),
			// This is the same as with the SurfaceConfig. It
			// specifies what texture formats can be used to
			// create TextureViews for this texture. The base
			// texture format (Rgba8UnormSrgb in this case) is
			// always supported. Note that using a different
			// texture format is not supported on the WebGL2
			// backend.
			view_formats: &[],
		});

		p.queue.write_texture(
			// Tells wgpu where to copy the pixel data
			wgpu::TexelCopyTextureInfo {
				texture: &diffuse_texture,
				mip_level: 0,
				origin: wgpu::Origin3d::ZERO,
				aspect: wgpu::TextureAspect::All,
			},
			// The actual pixel data
			&tex_rgba,
			// The layout of the texture
			wgpu::TexelCopyBufferLayout {
				offset: 0,
				bytes_per_row: Some(4 * dimensions.0),
				rows_per_image: Some(dimensions.1),
			},
			texture_size,
		);

		// We don't need to configure the texture view much, so let's
		// let wgpu define it.
		let diffuse_texture_view =
			diffuse_texture.create_view(&wgpu::TextureViewDescriptor::default());
		let diffuse_sampler = p.device.create_sampler(&wgpu::SamplerDescriptor {
			address_mode_u: wgpu::AddressMode::ClampToEdge,
			address_mode_v: wgpu::AddressMode::ClampToEdge,
			address_mode_w: wgpu::AddressMode::ClampToEdge,
			mag_filter: wgpu::FilterMode::Linear,
			min_filter: wgpu::FilterMode::Nearest,
			mipmap_filter: wgpu::FilterMode::Nearest,
			..Default::default()
		});

		let texture_bind_group_layout =
			p.device
				.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
					entries: &[
						wgpu::BindGroupLayoutEntry {
							binding: 0,
							visibility: wgpu::ShaderStages::FRAGMENT,
							ty: wgpu::BindingType::Texture {
								multisampled: false,
								view_dimension: wgpu::TextureViewDimension::D2,
								sample_type: wgpu::TextureSampleType::Float { filterable: true },
							},
							count: None,
						},
						wgpu::BindGroupLayoutEntry {
							binding: 1,
							visibility: wgpu::ShaderStages::FRAGMENT,
							// This should match the filterable field of the
							// corresponding Texture entry above.
							ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
							count: None,
						},
					],
					label: Some("texture_bind_group_layout"),
				});

		let diffuse_bind_group = p.device.create_bind_group(&wgpu::BindGroupDescriptor {
			layout: &texture_bind_group_layout,
			entries: &[
				wgpu::BindGroupEntry {
					binding: 0,
					resource: wgpu::BindingResource::TextureView(&diffuse_texture_view),
				},
				wgpu::BindGroupEntry {
					binding: 1,
					resource: wgpu::BindingResource::Sampler(&diffuse_sampler),
				},
			],
			label: Some("diffuse_bind_group"),
		});

		let pipeline_layout = p
			.device
			.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
				label: None,
				bind_group_layouts: &[&texture_bind_group_layout],
				push_constant_ranges: &[],
			});

		// Load the shaders from disk
		let vert_shader = p
			.device
			.create_shader_module(include_spirv!("../shader/vertex.spv"));
		let frag_shader = p
			.device
			.create_shader_module(include_spirv!("../shader/fragment.spv"));

		let pipeline = p
			.device
			.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
				label: None,
				layout: Some(&pipeline_layout),
				vertex: wgpu::VertexState {
					module: &vert_shader,
					entry_point: None,
					buffers: &[wgpu::VertexBufferLayout {
						array_stride: std::mem::size_of::<Vertex>() as wgpu::BufferAddress,
						step_mode: wgpu::VertexStepMode::Vertex,
						attributes: &wgpu::vertex_attr_array![0 => Float32x3, 1 => Float32x3, 2 => Float32x2],
					}],
					compilation_options: Default::default(),
				},
				fragment: Some(wgpu::FragmentState {
					module: &frag_shader,
					entry_point: None,
					compilation_options: Default::default(),
					targets: &[Some(wgpu::ColorTargetState {
						format: p.config.format, // for direct rendering into te surface
						blend: Some(wgpu::BlendState::REPLACE),
						write_mask: wgpu::ColorWrites::ALL,
					})],
				}),
				primitive: Default::default(),
				depth_stencil: None,
				multisample: Default::default(),
				multiview: None,
				cache: None,
			});

		Self {
			pipeline,
			buffer,
			diffuse_bind_group,
		}
	}

	fn frame(&mut self, p: &mut Painter, _tpf: f32) {
		let frame = p.surface.get_current_texture().unwrap();

		let view = frame
			.texture
			.create_view(&wgpu::TextureViewDescriptor::default());

		let mut encoder = p
			.device
			.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: None });
		{
			let mut rpass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
				label: None,
				color_attachments: &[Some(wgpu::RenderPassColorAttachment {
					view: &view,
					resolve_target: None,
					ops: wgpu::Operations {
						load: wgpu::LoadOp::Clear(wgpu::Color::BLACK),
						store: wgpu::StoreOp::Store,
					},
					depth_slice: None,
				})],
				depth_stencil_attachment: None,
				timestamp_writes: None,
				occlusion_query_set: None,
			});
			rpass.set_pipeline(&self.pipeline);
			rpass.set_bind_group(0, &self.diffuse_bind_group, &[]);
			rpass.set_vertex_buffer(0, self.buffer.slice(..));
			rpass.draw(0..3, 0..1);
		}

		p.queue.submit(Some(encoder.finish()));
		frame.present();
	}

	fn event(&mut self, _e: Event<()>, _p: &mut Painter) {}
	fn resize(&mut self, _p: &mut Painter, _w: u32, _h: u32) {}
}

pub fn main() {
	App::create().start();
}
</file>

<file path="triangle/Cargo.toml">
[package]
name = "test_triangle"
edition.workspace = true
version = "0.1.0"

[dependencies]
trivalibs.workspace = true
shader = { path = "./shader", package = "test_triangle_shader" }
png.workspace = true
bytemuck.workspace = true
</file>

<file path="user_event/shader/src/lib.rs">
#![no_std]
#![allow(unexpected_cfgs)]

use spirv_std::{
	glam::{vec2, vec4, Vec2, Vec4},
	spirv,
};

pub const CLIP_SPACE_COORD_QUAD_CCW: [Vec4; 6] = {
	let tl = vec4(-1.0, 1.0, 0.5, 1.0);
	let tr = vec4(1.0, 1.0, 0.5, 1.0);
	let bl = vec4(-1.0, -1.0, 0.5, 1.0);
	let br = vec4(1.0, -1.0, 0.5, 1.0);
	[bl, br, tr, tr, tl, bl]
};

pub const UV_COORD_QUAD_CCW: [Vec2; 6] = {
	let tl = vec2(0.0, 0.0);
	let tr = vec2(1.0, 0.0);
	let bl = vec2(0.0, 1.0);
	let br = vec2(1.0, 1.0);
	[bl, br, tr, tr, tl, bl]
};

/// Vertex shader that renders an implicit quad.
#[spirv(vertex)]
pub fn vertex(
	#[spirv(vertex_index)] vertex_id: u32,
	out_uv: &mut Vec2,
	#[spirv(position)] clip_pos: &mut Vec4,
) {
	let index = vertex_id as usize % 6;
	*out_uv = UV_COORD_QUAD_CCW[index];
	*clip_pos = CLIP_SPACE_COORD_QUAD_CCW[index];
}

/// Fragment shader that uses UV coords passed in from the vertex shader
/// to render a simple gradient.
#[spirv(fragment)]
pub fn fragment(in_uv: Vec2, frag_color: &mut Vec4) {
	*frag_color = vec4(in_uv.x, 1.0 - in_uv.y, 0.0, 1.0);
}
</file>

<file path="user_event/shader/Cargo.toml">
[package]
name = "user_event_shader"
edition.workspace = true
version = "0.1.0"

[lib]
crate-type = ["rlib", "cdylib"]

[dependencies]
spirv-std.workspace = true
</file>

<file path="user_event/shader/manifest.json">
[
  {
    "source_path": "fragment.spv",
    "entry_point": "fragment",
    "wgsl_entry_point": "fragment"
  },
  {
    "source_path": "vertex.spv",
    "entry_point": "vertex",
    "wgsl_entry_point": "vertex"
  }
]
</file>

<file path="user_event/main.rs">
use trivalibs::painter::{
	Painter,
	app::{CanvasApp, Event},
	wgpu::{self, include_spirv},
};

struct App {
	color: wgpu::Color,
	pipeline: wgpu::RenderPipeline,
}

struct UserEvent(wgpu::Color);

impl CanvasApp<UserEvent> for App {
	fn init(p: &mut Painter) -> Self {
		// Initialize the app

		let pipeline_layout = p
			.device
			.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
				label: None,
				bind_group_layouts: &[],
				push_constant_ranges: &[],
			});

		// let capabilities = painter.surface.get_capabilities(&painter.adapter);
		// let format = capabilities.formats[0];

		// Load the shaders from disk
		let vert_shader = p
			.device
			.create_shader_module(include_spirv!("./shader/vertex.spv"));
		let frag_shader = p
			.device
			.create_shader_module(include_spirv!("./shader/fragment.spv"));

		let pipeline = p
			.device
			.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
				label: None,
				layout: Some(&pipeline_layout),
				vertex: wgpu::VertexState {
					module: &vert_shader,
					entry_point: None,
					buffers: &[],
					compilation_options: Default::default(),
				},
				fragment: Some(wgpu::FragmentState {
					module: &frag_shader,
					entry_point: None,
					compilation_options: Default::default(),
					targets: &[Some(wgpu::ColorTargetState {
						format: p.config.format, // for direct rendering into te surface
						blend: Some(wgpu::BlendState::REPLACE),
						write_mask: wgpu::ColorWrites::ALL,
					})],
				}),
				primitive: wgpu::PrimitiveState::default(),
				depth_stencil: None,
				multisample: wgpu::MultisampleState::default(),
				multiview: None,
				cache: None,
			});

		Self {
			color: wgpu::Color::BLUE,
			pipeline,
		}
	}

	fn frame(&mut self, painter: &mut Painter, _tpf: f32) {
		let frame = painter.surface.get_current_texture().unwrap();

		let view = frame
			.texture
			.create_view(&wgpu::TextureViewDescriptor::default());

		let mut encoder = painter
			.device
			.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: None });
		{
			let mut rpass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
				label: None,
				color_attachments: &[Some(wgpu::RenderPassColorAttachment {
					view: &view,
					resolve_target: None,
					ops: wgpu::Operations {
						load: wgpu::LoadOp::Clear(self.color),
						store: wgpu::StoreOp::Store,
					},
					depth_slice: None,
				})],
				depth_stencil_attachment: None,
				timestamp_writes: None,
				occlusion_query_set: None,
			});
			rpass.set_pipeline(&self.pipeline);
			rpass.draw(0..3, 0..1);
		}

		painter.queue.submit(Some(encoder.finish()));
		frame.present();
	}

	fn event(&mut self, event: Event<UserEvent>, painter: &mut Painter) {
		match event {
			Event::UserEvent(event) => {
				self.color = event.0;
				painter.request_next_frame();
			}
			_ => {}
		}
	}

	fn resize(&mut self, _p: &mut Painter, _w: u32, _h: u32) {}
}

pub fn main() {
	let app = App::create();
	let handle = app.get_handle();

	std::thread::spawn(move || {
		loop {
			std::thread::sleep(std::time::Duration::from_secs(2));
			let _ = handle.send_event(UserEvent(wgpu::Color::RED));
			std::thread::sleep(std::time::Duration::from_secs(2));
			let _ = handle.send_event(UserEvent(wgpu::Color::GREEN));
			std::thread::sleep(std::time::Duration::from_secs(2));
			let _ = handle.send_event(UserEvent(wgpu::Color::BLUE));
		}
	});

	app.start();
}
</file>

<file path="src/utils/input_state.rs">
use crate::app::{Event, KeyCode, PointerButton};
use std::collections::BTreeSet;

pub struct DraggingState {
	pub delta_x: f32,
	pub delta_y: f32,
}

pub struct InputState {
	pub pressed_keys: BTreeSet<KeyCode>,
	pub pressed_pointer_buttons: BTreeSet<PointerButton>,
	pub dragging: Option<DraggingState>,
}

impl Default for InputState {
	fn default() -> Self {
		Self {
			pressed_keys: BTreeSet::new(),
			pressed_pointer_buttons: BTreeSet::new(),
			dragging: None,
		}
	}
}

impl InputState {
	pub fn process_event<U>(&mut self, event: Event<U>) {
		match event {
			Event::KeyDown { key } => {
				self.pressed_keys.insert(key);
			}

			Event::KeyUp { key } => {
				self.pressed_keys.remove(&key);
			}

			Event::PointerDown { button, .. } => {
				self.pressed_pointer_buttons.insert(button);

				// Start dragging when any button is pressed
				if self.dragging.is_none() {
					self.dragging = Some(DraggingState {
						delta_x: 0.0,
						delta_y: 0.0,
					});
				}
			}

			Event::PointerUp { button, .. } => {
				self.pressed_pointer_buttons.remove(&button);

				// Stop dragging when all buttons are released
				if self.pressed_pointer_buttons.is_empty() {
					self.dragging = None;
				}
			}

			Event::PointerMove {
				delta_x,
				delta_y,
				mouse_lock,
				..
			} => {
				// Accumulate deltas while dragging
				// Use mouse_lock events for raw motion (FPS-style controls)
				if let Some(dragging) = &mut self.dragging {
					dragging.delta_x += delta_x as f32;
					dragging.delta_y += delta_y as f32;
				} else if mouse_lock {
					// Even without dragging, raw motion might be useful for FPS controls
					// For now, we only track it when dragging
				}
			}

			_ => {}
		}
	}

	/// Check if a key is currently pressed
	pub fn is_key_pressed(&self, key: KeyCode) -> bool {
		self.pressed_keys.contains(&key)
	}

	/// Check if a pointer button is currently pressed
	pub fn is_button_pressed(&self, button: PointerButton) -> bool {
		self.pressed_pointer_buttons.contains(&button)
	}
}
</file>

<file path="src/utils/mod.rs">
pub mod input_state;
</file>

<file path="src/app.rs">
use crate::layer::Layer;
#[cfg(not(target_arch = "wasm32"))]
use crate::window_dimensions::WindowDimensions;
use crate::{Painter, painter::PainterConfig};
#[cfg(all(debug_assertions, not(target_arch = "wasm32")))]
use notify::Watcher;
#[cfg(all(debug_assertions, not(target_arch = "wasm32")))]
use std::collections::BTreeMap;
use std::sync::Arc;
#[cfg(target_arch = "wasm32")]
use wasm_bindgen_futures::spawn_local;
use web_time::Instant;
#[cfg(not(target_arch = "wasm32"))]
use winit::dpi::PhysicalPosition;
use winit::{
	application::ApplicationHandler,
	dpi::PhysicalSize,
	event::{DeviceEvent, DeviceId, ElementState, KeyEvent, WindowEvent},
	event_loop::{ActiveEventLoop, EventLoop, EventLoopProxy},
	keyboard::PhysicalKey,
	window::{Window, WindowId},
};

// Re-export custom event types
pub use crate::events::{Event, KeyCode, PointerButton};

pub trait CanvasApp<UserEvent> {
	fn init(painter: &mut Painter) -> Self;
	fn resize(&mut self, painter: &mut Painter, width: u32, height: u32);
	fn frame(&mut self, painter: &mut Painter, tpf: f32);
	fn event(&mut self, event: Event<UserEvent>, painter: &mut Painter);

	fn create() -> CanvasAppStarter<UserEvent, Self>
	where
		Self: Sized,
	{
		#[cfg(not(target_arch = "wasm32"))]
		env_logger::init();

		#[cfg(target_arch = "wasm32")]
		{
			std::panic::set_hook(Box::new(console_error_panic_hook::hook));
			let _ = console_log::init(); // Ignore error if already initialized
		}

		let event_loop = EventLoop::<CustomEvent<UserEvent>>::with_user_event()
			.build()
			.unwrap();

		let event_loop_proxy = event_loop.create_proxy();

		let runner = CanvasAppRunner {
			state: WindowState::Uninitialized,
			event_loop_proxy,
			is_running: true,
			is_resizing: false,
			frame_count: 0,
			frame_time: 0.0,
			now: Instant::now(),
			config: AppConfig::default(),
			last_cursor: None,
		};

		CanvasAppStarter { runner, event_loop }
	}
}

enum WindowState<UserEvent, App: CanvasApp<UserEvent>> {
	Uninitialized,
	Initializing,
	Initialized(Painter, App),
	_PHANTOM(std::marker::PhantomData<UserEvent>),
}

pub enum CustomEvent<UserEvent> {
	StateInitializationEvent(Painter),
	UserEvent(UserEvent),
	ReloadShaders(String),
}

pub struct CanvasAppRunner<UserEvent, App>
where
	UserEvent: 'static,
	App: CanvasApp<UserEvent>,
{
	state: WindowState<UserEvent, App>,
	event_loop_proxy: EventLoopProxy<CustomEvent<UserEvent>>,
	is_running: bool,
	is_resizing: bool,
	frame_count: u32,
	frame_time: f32,
	now: Instant,
	config: AppConfig,
	last_cursor: Option<(f64, f64)>,
}

impl<UserEvent, App> CanvasAppRunner<UserEvent, App>
where
	UserEvent: 'static,
	App: CanvasApp<UserEvent>,
{
	pub fn pause(&mut self) {
		self.is_running = false;
	}

	pub fn play(&mut self) {
		self.is_running = true;
		self.now = Instant::now();
		if let WindowState::Initialized(painter, _) = &mut self.state {
			painter.request_next_frame();
		}
	}
}

pub struct CanvasHandle<UserEvent>
where
	UserEvent: 'static,
{
	event_loop_proxy: EventLoopProxy<CustomEvent<UserEvent>>,
}

impl<UserEvent> CanvasHandle<UserEvent> {
	pub fn send_event(
		&self,
		event: UserEvent,
	) -> Result<(), winit::event_loop::EventLoopClosed<CustomEvent<UserEvent>>> {
		self.event_loop_proxy
			.send_event(CustomEvent::UserEvent(event))
	}
}

#[derive(Debug)]
pub struct AppConfig {
	pub show_fps: bool,
	pub use_vsync: bool,
	pub remember_window_dimensions: bool,
	pub features: Option<wgpu::Features>,
	#[cfg(target_arch = "wasm32")]
	pub canvas: Option<web_sys::HtmlCanvasElement>,
}

impl Default for AppConfig {
	fn default() -> Self {
		Self {
			show_fps: false,
			use_vsync: true,
			remember_window_dimensions: false,
			features: None,
			#[cfg(target_arch = "wasm32")]
			canvas: None,
		}
	}
}

pub struct CanvasAppStarter<UserEvent, App>
where
	UserEvent: 'static,
	App: CanvasApp<UserEvent>,
{
	runner: CanvasAppRunner<UserEvent, App>,
	event_loop: EventLoop<CustomEvent<UserEvent>>,
}

impl<UserEvent, App> CanvasAppStarter<UserEvent, App>
where
	UserEvent: std::marker::Send,
	App: CanvasApp<UserEvent> + std::marker::Send + 'static,
{
	pub fn config(mut self, config: AppConfig) -> Self {
		self.runner.config = config;
		self
	}

	pub fn start(self) {
		let event_loop = self.event_loop;
		let mut runner = self.runner;

		#[cfg(all(debug_assertions, not(target_arch = "wasm32")))]
		let (tx, rx) = std::sync::mpsc::channel::<notify::Result<notify::Event>>();

		#[cfg(all(debug_assertions, not(target_arch = "wasm32")))]
		let mut watcher = notify::recommended_watcher(tx).unwrap();

		#[cfg(all(debug_assertions, not(target_arch = "wasm32")))]
		let path = std::env::current_dir().unwrap();

		#[cfg(all(debug_assertions, not(target_arch = "wasm32")))]
		println!("Watching: {:?}", path);

		#[cfg(all(debug_assertions, not(target_arch = "wasm32")))]
		watcher
			.watch(&path, notify::RecursiveMode::Recursive)
			.unwrap();

		#[cfg(all(debug_assertions, not(target_arch = "wasm32")))]
		let proxy = runner.event_loop_proxy.clone();

		#[cfg(all(debug_assertions, not(target_arch = "wasm32")))]
		std::thread::spawn(move || {
			let mut current_shaders = BTreeMap::new();
			// Block forever, printing out events as they come in
			for res in rx {
				match res {
					Ok(event) => {
						if event.kind.is_modify() {
							let current_time = std::time::SystemTime::now();

							event.paths.iter().for_each(|path| {
								if let Some(ext) = path.extension() {
									if ext != "spv" {
										return;
									}

									if let Some(last_event_time) = current_shaders.get(path) {
										if current_time
											.duration_since(*last_event_time)
											.unwrap()
											.as_millis() < 500
										{
											return;
										}
									}

									proxy
										.send_event(CustomEvent::ReloadShaders(
											path.display().to_string(),
										))
										.unwrap_or_else(|_| {
											panic!("Failed to send shader reload event");
										});

									current_shaders.insert(path.clone(), current_time);
								}
							});
						}
					}

					Err(e) => println!("watch error: {:?}", e),
				}
			}
		});

		let _ = event_loop.run_app(&mut runner);
	}

	pub fn get_handle(&self) -> CanvasHandle<UserEvent> {
		CanvasHandle {
			event_loop_proxy: self.runner.event_loop_proxy.clone(),
		}
	}
}

impl<UserEvent, App> ApplicationHandler<CustomEvent<UserEvent>> for CanvasAppRunner<UserEvent, App>
where
	App: CanvasApp<UserEvent>,
{
	// This is a common indicator that you can create a window.
	fn resumed(&mut self, event_loop: &ActiveEventLoop) {
		match self.state {
			WindowState::Uninitialized => {
				self.state = WindowState::Initializing;

				#[cfg(not(target_arch = "wasm32"))]
				let mut window_attributes = Window::default_attributes();
				#[cfg(target_arch = "wasm32")]
				let window_attributes = Window::default_attributes();

				// Load and apply saved window state
				#[cfg(not(target_arch = "wasm32"))]
				if self.config.remember_window_dimensions {
					if let Some(state) = WindowDimensions::load() {
						window_attributes = window_attributes
							.with_inner_size(PhysicalSize::new(state.size.0, state.size.1));
						window_attributes = window_attributes.with_position(PhysicalPosition::new(
							state.position.0,
							state.position.1,
						));
					}
				} else {
					let _ = WindowDimensions::cleanup();
				}

				#[cfg(target_arch = "wasm32")]
				let window = {
					use winit::platform::web::WindowAttributesExtWebSys;

					if let Some(canvas) = &self.config.canvas {
						// Use the provided canvas
						let window = event_loop
							.create_window(window_attributes.with_canvas(Some(canvas.clone())))
							.unwrap();
						let window = Arc::new(window);

						// Set canvas attributes even for provided canvas
						canvas
							.set_attribute("tabindex", "0")
							.expect("failed to set tabindex");
						canvas.focus().expect("Unable to focus on canvas");

						window
					} else {
						// Create a new canvas as before
						let window = event_loop.create_window(window_attributes).unwrap();
						let window = Arc::new(window);

						use winit::platform::web::WindowExtWebSys;

						web_sys::window()
							.and_then(|win| win.document())
							.and_then(|doc| {
								let body = doc.body()?;
								let canvas = window.canvas().expect("Failed to get canvas");
								canvas
									.set_attribute("tabindex", "0")
									.expect("failed to set tabindex");
								// Set canvas size to fill the window
								canvas.style().set_property("width", "100%").ok();
								canvas.style().set_property("height", "100%").ok();
								canvas.style().set_property("display", "block").ok();
								body.append_child(&canvas).ok()?;
								canvas.focus().expect("Unable to focus on canvas");
								Some(())
							})
							.expect("Couldn't append canvas to document body.");

						window
					}
				};

				#[cfg(not(target_arch = "wasm32"))]
				let window = {
					let window = event_loop.create_window(window_attributes).unwrap();
					Arc::new(window)
				};

				let renderer_future = Painter::new(
					window,
					PainterConfig {
						use_vsync: self.config.use_vsync,
						features: self.config.features,
					},
				);

				#[cfg(target_arch = "wasm32")]
				{
					let event_loop_proxy = self.event_loop_proxy.clone();
					spawn_local(async move {
						let painter = renderer_future.await;

						event_loop_proxy
							.send_event(CustomEvent::StateInitializationEvent(painter))
							.unwrap_or_else(|_| {
								panic!("Failed to send initialization event");
							});
					});
				}

				#[cfg(not(target_arch = "wasm32"))]
				{
					let painter = pollster::block_on(renderer_future);

					self.event_loop_proxy
						.send_event(CustomEvent::StateInitializationEvent(painter))
						.unwrap_or_else(|_| {
							panic!("Failed to send initialization event");
						});
				}
			}
			_ => {}
		}
	}

	fn user_event(&mut self, _event_loop: &ActiveEventLoop, event: CustomEvent<UserEvent>) {
		match event {
			CustomEvent::StateInitializationEvent(mut painter) => {
				let mut app = App::init(&mut painter);

				for i in 0..painter.layers.len() {
					Layer(i).init_gpu_pipelines(&mut painter);
				}

				let size = painter.canvas_size();
				app.resize(&mut painter, size.width, size.height);
				painter.request_next_frame();
				self.state = WindowState::Initialized(painter, app);
			}
			CustomEvent::UserEvent(user_event) => {
				if let WindowState::Initialized(painter, app) = &mut self.state {
					if self.is_running {
						app.event(Event::UserEvent(user_event), painter);
					}
				}
			}
			CustomEvent::ReloadShaders(path) => {
				#[cfg(target_arch = "wasm32")]
				let _ = path; // Use the path if needed
				#[cfg(not(target_arch = "wasm32"))]
				#[cfg(debug_assertions)]
				{
					if let WindowState::Initialized(painter, app) = &mut self.state {
						painter.reload_shader(path);
						app.event(Event::ShaderReloadEvent, painter);
						app.frame(painter, 0.0);
					}
				}
			}
		}
	}

	fn window_event(
		&mut self,
		event_loop: &ActiveEventLoop,
		_window_id: WindowId,
		event: WindowEvent,
	) {
		match &mut self.state {
			WindowState::Initialized(painter, app) => {
				match event {
					WindowEvent::Resized(new_size) => {
						// Reconfigure the surface with the new size
						painter.resize(new_size);
						app.resize(painter, new_size.width, new_size.height);
						// On macos the window needs to be redrawn manually after resizing
						painter.request_next_frame();
						self.is_resizing = true;

						#[cfg(not(target_arch = "wasm32"))]
						{
							let window = painter.window();
							if self.config.remember_window_dimensions {
								let dim = WindowDimensions::from_window(
									new_size,
									window.outer_position().unwrap_or_default(),
								);
								let _ = dim.save();
							}
						}
					}

					#[cfg(not(target_arch = "wasm32"))]
					WindowEvent::Moved(new_position) => {
						let window = painter.window();
						if self.config.remember_window_dimensions {
							let dim =
								WindowDimensions::from_window(window.inner_size(), new_position);
							let _ = dim.save();
						}
					}

					WindowEvent::RedrawRequested => {
						if self.is_running || self.is_resizing {
							let elapsed = self.now.elapsed().as_secs_f32();
							self.now = Instant::now();

							let elapsed = if self.is_running { elapsed } else { 0.0 };

							if self.config.show_fps && self.is_running {
								self.frame_count += 1;
								self.frame_time += elapsed;
								if self.frame_time >= 2.0 {
									// TODO: setup logger
									println!("FPS: {}", self.frame_count as f32 / self.frame_time);
									self.frame_count = 0;
									self.frame_time = 0.0;
								}
							}

							app.frame(painter, elapsed);

							if let Some(err) = &painter.surface_error {
								match err {
									wgpu::SurfaceError::Lost | wgpu::SurfaceError::Outdated => {
										painter.resize(PhysicalSize {
											width: painter.config.width,
											height: painter.config.height,
										});
										app.resize(
											painter,
											painter.config.width,
											painter.config.height,
										);
										log::error!("Surface lost or outdated, resizing");
									}
									// The system is out of memory, we should probably quit
									wgpu::SurfaceError::OutOfMemory => {
										log::error!("OutOfMemory");
										event_loop.exit();
									}

									// This happens when the a frame takes too long to present
									wgpu::SurfaceError::Timeout => {
										log::warn!("Surface timeout")
									}

									other => {
										log::error!("Other error: {:?}", other);
									}
								}
								painter.surface_error = None;
							}

							self.is_resizing = false;
						}
					}

					WindowEvent::CloseRequested => event_loop.exit(),

					WindowEvent::CursorMoved { position, .. } => {
						let x = position.x;
						let y = position.y;
						let (delta_x, delta_y) = if let Some((last_x, last_y)) = self.last_cursor {
							(x - last_x, y - last_y)
						} else {
							(0.0, 0.0)
						};
						self.last_cursor = Some((x, y));

						if self.is_running {
							app.event(
								Event::PointerMove {
									x,
									y,
									delta_x,
									delta_y,
									mouse_lock: false,
								},
								painter,
							);
						}
					}

					WindowEvent::MouseInput { state, button, .. } => {
						let button = PointerButton::from(button);
						let (x, y) = self.last_cursor.unwrap_or((0.0, 0.0));

						if self.is_running {
							match state {
								ElementState::Pressed => {
									app.event(Event::PointerDown { button, x, y }, painter);
								}
								ElementState::Released => {
									app.event(Event::PointerUp { button, x, y }, painter);
								}
							}
						}
					}

					WindowEvent::KeyboardInput {
						event:
							KeyEvent {
								state: ElementState::Released,
								physical_key: PhysicalKey::Code(code),
								..
							},
						..
					} => {
						let key = KeyCode::from(code);

						// Handle exit with Escape on native
						#[cfg(not(target_arch = "wasm32"))]
						if matches!(key, KeyCode::Escape) {
							event_loop.exit();
						}

						if self.is_running {
							app.event(Event::KeyUp { key }, painter);
						}

						// Handle internal pause/play with Space after event processing
						if matches!(key, KeyCode::Space) {
							if self.is_running {
								self.is_running = false;
							} else {
								self.is_running = true;
								self.now = Instant::now();
								painter.request_next_frame();
							}
						}
					}

					WindowEvent::KeyboardInput {
						event:
							KeyEvent {
								state: ElementState::Pressed,
								physical_key: PhysicalKey::Code(code),
								..
							},
						..
					} => {
						if self.is_running {
							let key = KeyCode::from(code);
							app.event(Event::KeyDown { key }, painter);
						}
					}

					_ => {
						// Ignore other window events (focus, hover, etc.)
					}
				};
			}
			_ => {}
		}
	}

	fn device_event(
		&mut self,
		_event_loop: &ActiveEventLoop,
		_device_id: DeviceId,
		event: DeviceEvent,
	) {
		if let WindowState::Initialized(painter, app) = &mut self.state {
			if self.is_running {
				match event {
					DeviceEvent::MouseMotion { delta } => {
						// Raw mouse motion - typically from mouse lock / FPS mode
						app.event(
							Event::PointerMove {
								x: 0.0,
								y: 0.0,
								delta_x: delta.0,
								delta_y: delta.1,
								mouse_lock: true,
							},
							painter,
						);
					}
					_ => {
						// Ignore other device events for now
					}
				}
			}
		}
	}
}
</file>

<file path="src/bind_group.rs">
use crate::{
	Painter,
	binding::{BindingLayout, InstanceBinding, LayerBinding, LayerLayout, ValueBinding},
	texture::TexViewKey,
};
use std::collections::btree_map;

#[derive(Clone, Copy)]
pub(crate) struct BindGroupLayout(pub(crate) usize);

impl BindGroupLayout {
	pub(crate) fn layers(painter: &mut Painter, layouts: &[LayerLayout]) -> Option<Self> {
		if layouts.is_empty() {
			return None;
		}

		let layout = painter
			.device
			.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
				entries: layouts
					.iter()
					.enumerate()
					.map(|(i, l)| wgpu::BindGroupLayoutEntry {
						binding: i as u32,
						visibility: l.visibility,
						ty: wgpu::BindingType::Texture {
							multisampled: false,
							view_dimension: wgpu::TextureViewDimension::D2,
							sample_type: wgpu::TextureSampleType::Float { filterable: true },
						},
						count: None,
					})
					.collect::<Vec<_>>()
					.as_slice(),
				label: None,
			});

		painter.bind_group_layouts.push(layout);

		Some(BindGroupLayout(painter.bind_group_layouts.len() - 1))
	}

	pub(crate) fn values(painter: &mut Painter, layouts: &[BindingLayout]) -> Option<Self> {
		if layouts.is_empty() {
			return None;
		}

		let layout = painter
			.device
			.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
				entries: layouts
					.iter()
					.enumerate()
					.map(|(i, u)| wgpu::BindGroupLayoutEntry {
						binding: i as u32,
						visibility: u.visibility,
						ty: u.binding_type,
						count: None,
					})
					.collect::<Vec<_>>()
					.as_slice(),
				label: None,
			});

		painter.bind_group_layouts.push(layout);

		Some(BindGroupLayout(painter.bind_group_layouts.len() - 1))
	}
}

#[derive(Clone)]
pub(crate) struct ValuesBindGroupData {
	pub layout: BindGroupLayout,
	pub data: Vec<Vec<ValueBinding>>,
}

impl ValuesBindGroupData {
	pub(crate) fn from_bindings(
		bindings_length: usize,
		bind_group_layout: Option<BindGroupLayout>,
		shape_bindings: &[(u32, ValueBinding)],
		shape_instances: &[InstanceBinding],
		layer_bindings: &[(u32, ValueBinding)],
	) -> Option<Self> {
		if bindings_length == 0 || bind_group_layout.is_none() {
			return None;
		}

		let layout = bind_group_layout.unwrap();

		// Build base binding map from layer and shape bindings (shape overrides layer)
		let mut binding_map = btree_map::BTreeMap::new();

		for (i, u) in layer_bindings.iter() {
			binding_map.insert(*i, *u);
		}

		for (i, u) in shape_bindings.iter() {
			binding_map.insert(*i, *u);
		}

		// Check if any instance has value bindings
		let has_instance_values = shape_instances.iter().any(|inst| !inst.bindings.is_empty());

		if shape_instances.is_empty() || !has_instance_values {
			// No instances or all instances have empty value bindings
			// Return single bind group with base (layer+shape) bindings
			let mut bindings = binding_map.iter().collect::<Vec<_>>();
			bindings.sort_by(|(a, _), (b, _)| a.cmp(b));
			let bindings = bindings.iter().map(|(_, b)| **b).collect::<Vec<_>>();

			Some(Self {
				layout,
				data: vec![bindings],
			})
		} else {
			// At least one instance has value bindings
			// Create per-instance bind groups (instance bindings override shape/layer)
			let mut instances = Vec::with_capacity(shape_instances.len());

			for instance in shape_instances {
				let mut instance_map = binding_map.clone();

				for (i, u) in instance.bindings.iter() {
					instance_map.insert(*i, *u);
				}

				let mut bindings = instance_map.iter().collect::<Vec<_>>();
				bindings.sort_by(|(a, _), (b, _)| a.cmp(b));
				let bindings = bindings.iter().map(|(_, b)| **b).collect::<Vec<_>>();

				instances.push(bindings);
			}

			Some(Self {
				layout,
				data: instances,
			})
		}
	}

	pub(crate) fn to_gpu_bind_groups(&self, painter: &Painter) -> Vec<wgpu::BindGroup> {
		self.data
			.iter()
			.map(|u| {
				let entries = u
					.iter()
					.enumerate()
					.map(|(i, u)| wgpu::BindGroupEntry {
						binding: i as u32,
						resource: value_to_resource(u, painter),
					})
					.collect::<Vec<_>>();

				painter
					.device
					.create_bind_group(&wgpu::BindGroupDescriptor {
						label: None,
						layout: &painter.bind_group_layouts[self.layout.0],
						entries: &entries,
					})
			})
			.collect::<Vec<_>>()
	}
}

#[derive(Clone)]
pub(crate) struct LayerBindGroupData {
	pub layout: BindGroupLayout,
	pub data: Vec<Vec<LayerBinding>>,
}

impl LayerBindGroupData {
	/// Helper function to create bind group entries from an iterator of LayerBindings
	fn create_layer_entries<'a>(
		bindings: impl Iterator<Item = &'a LayerBinding>,
		painter: &'a Painter,
	) -> Vec<wgpu::BindGroupEntry<'a>> {
		bindings
			.enumerate()
			.map(|(i, u)| wgpu::BindGroupEntry {
				binding: i as u32,
				resource: layer_to_resource(u, painter),
			})
			.collect()
	}

	/// Helper function to create a bind group from entries
	fn create_bind_group_from_entries<'a>(
		painter: &'a Painter,
		layout: &BindGroupLayout,
		entries: &'a [wgpu::BindGroupEntry<'a>],
	) -> wgpu::BindGroup {
		painter
			.device
			.create_bind_group(&wgpu::BindGroupDescriptor {
				label: None,
				layout: &painter.bind_group_layouts[layout.0],
				entries,
			})
	}

	pub(crate) fn from_bindings(
		bindings_length: usize,
		bind_group_layout: Option<BindGroupLayout>,
		shape_bindings: &[(u32, LayerBinding)],
		shape_instances: &[InstanceBinding],
		layer_bindings: &[(u32, LayerBinding)],
	) -> Option<Self> {
		if bindings_length == 0 || bind_group_layout.is_none() {
			return None;
		}

		let layout = bind_group_layout.unwrap();

		// Build base binding map from layer and shape bindings (shape overrides layer)
		let mut binding_map = btree_map::BTreeMap::new();

		for (i, u) in layer_bindings.iter() {
			binding_map.insert(*i, *u);
		}

		for (i, u) in shape_bindings.iter() {
			binding_map.insert(*i, *u);
		}

		// Check if any instance has layer bindings
		let has_instance_layers = shape_instances.iter().any(|inst| !inst.layers.is_empty());

		if shape_instances.is_empty() || !has_instance_layers {
			// No instances or all instances have empty layer bindings
			// Return single bind group with base (layer+shape) bindings
			let mut bindings = binding_map.iter().collect::<Vec<_>>();
			bindings.sort_by(|(a, _), (b, _)| a.cmp(b));
			let bindings = bindings.iter().map(|(_, b)| **b).collect::<Vec<_>>();

			Some(Self {
				layout,
				data: vec![bindings],
			})
		} else {
			// At least one instance has layer bindings
			// Create per-instance bind groups (instance bindings override shape/layer)
			let mut instances = Vec::with_capacity(shape_instances.len());

			for instance in shape_instances {
				let mut instance_map = binding_map.clone();

				for (i, u) in instance.layers.iter() {
					instance_map.insert(*i, *u);
				}

				let mut bindings = instance_map.iter().collect::<Vec<_>>();
				bindings.sort_by(|(a, _), (b, _)| a.cmp(b));
				let bindings = bindings.iter().map(|(_, b)| **b).collect::<Vec<_>>();

				instances.push(bindings);
			}

			Some(Self {
				layout,
				data: instances,
			})
		}
	}

	pub(crate) fn to_gpu_bind_groups(&self, painter: &Painter) -> Vec<wgpu::BindGroup> {
		self.data
			.iter()
			.map(|bindings| {
				let entries = Self::create_layer_entries(bindings.iter(), painter);
				Self::create_bind_group_from_entries(painter, &self.layout, &entries)
			})
			.collect()
	}

	pub(crate) fn to_gpu_bind_group(&self, painter: &Painter) -> wgpu::BindGroup {
		let entries = Self::create_layer_entries(self.data.first().unwrap().iter(), painter);
		Self::create_bind_group_from_entries(painter, &self.layout, &entries)
	}

	pub(crate) fn to_gpu_bind_group_with_first(
		&self,
		painter: &Painter,
		first: &LayerBinding,
	) -> wgpu::BindGroup {
		let entries = Self::create_layer_entries(
			std::iter::once(first).chain(self.data.first().unwrap().iter()),
			painter,
		);
		Self::create_bind_group_from_entries(painter, &self.layout, &entries)
	}

	/// Creates multiple bind groups (one per instance), each with the first binding prepended.
	/// Used for effect rendering with instances where the source texture needs to be inserted
	/// as the first binding for each instance.
	pub(crate) fn to_gpu_bind_groups_with_first(
		&self,
		painter: &Painter,
		first: &LayerBinding,
	) -> Vec<wgpu::BindGroup> {
		self.data
			.iter()
			.map(|bindings| {
				let entries = Self::create_layer_entries(
					std::iter::once(first).chain(bindings.iter()),
					painter,
				);
				Self::create_bind_group_from_entries(painter, &self.layout, &entries)
			})
			.collect()
	}
}

pub(crate) struct BindGroupStorage {
	pub(crate) bind_group: wgpu::BindGroup,
}

fn value_to_resource<'a>(
	binding: &'a ValueBinding,
	painter: &'a Painter,
) -> wgpu::BindingResource<'a> {
	match binding {
		ValueBinding::Sampler(sampler) => {
			let sampler = &painter.samplers[sampler.0];
			wgpu::BindingResource::Sampler(&sampler)
		}
		ValueBinding::Buffer(buffer) => {
			let buffer = &painter.buffers[buffer.0];
			buffer.as_entire_binding()
		}
	}
}

fn layer_to_resource<'a>(
	binding: &'a LayerBinding,
	painter: &'a Painter,
) -> wgpu::BindingResource<'a> {
	match binding {
		LayerBinding::Source(layer) => {
			let l = &painter.layers[layer.0];
			wgpu::BindingResource::TextureView(l.current_source_texture().source_view(painter))
		}
		LayerBinding::SourceAtMipLevel(layer, mip_level) => {
			let l = &painter.layers[layer.0];
			wgpu::BindingResource::TextureView(
				l.current_source_texture()
					.view(painter, &TexViewKey::AtMipLevel(*mip_level)),
			)
		}
		LayerBinding::Depth(layer) => {
			let l = &painter.layers[layer.0];
			wgpu::BindingResource::TextureView(
				l.depth_texture.unwrap().view(painter, &TexViewKey::Default),
			)
		}
		LayerBinding::AtIndex(layer, index) => {
			let l = &painter.layers[layer.0];
			wgpu::BindingResource::TextureView(
				l.target_textures[*index].view(painter, &TexViewKey::WithAllMips),
			)
		}
	}
}

#[derive(Clone, Copy, Ord, PartialOrd, Eq, PartialEq, Hash)]
pub struct BindGroup(pub(crate) usize);

impl BindGroup {
	pub(crate) fn layer_gpu_bind_group(
		painter: &mut Painter,
		layer: LayerBinding,
	) -> wgpu::BindGroup {
		painter
			.device
			.create_bind_group(&wgpu::BindGroupDescriptor {
				label: None,
				layout: &painter.bind_group_layouts[1],
				entries: &[wgpu::BindGroupEntry {
					binding: 0,
					resource: layer_to_resource(&layer, painter),
				}],
			})
	}

	pub(crate) fn values_bind_groups(
		painter: &mut Painter,
		bindings_length: usize,
		bind_group_layout: Option<BindGroupLayout>,
		shape_bindings: &[(u32, ValueBinding)],
		shape_instances: &[InstanceBinding],
		layer_bindings: &[(u32, ValueBinding)],
	) -> Vec<Self> {
		let data = ValuesBindGroupData::from_bindings(
			bindings_length,
			bind_group_layout,
			shape_bindings,
			shape_instances,
			layer_bindings,
		);

		if let Some(data) = data {
			let bind_groups = data.to_gpu_bind_groups(painter);
			let mut bind_group_indices = Vec::with_capacity(bind_groups.len());

			for bind_group in bind_groups {
				let index = painter.bind_groups.len();
				painter.bind_groups.push(BindGroupStorage { bind_group });
				bind_group_indices.push(BindGroup(index));
			}

			bind_group_indices
		} else {
			Vec::new()
		}
	}
}
</file>

<file path="src/binding_constants.rs">
use crate::binding::{BindingLayout, LayerLayout};
use wgpu::BindingType;

pub const BINDING_BUFFER_VERT: BindingLayout = BindingLayout {
	visibility: wgpu::ShaderStages::VERTEX,
	binding_type: BindingType::Buffer {
		ty: wgpu::BufferBindingType::Uniform,
		has_dynamic_offset: false,
		min_binding_size: None,
	},
};

pub const BINDING_BUFFER_FRAG: BindingLayout = BindingLayout {
	visibility: wgpu::ShaderStages::FRAGMENT,
	binding_type: BindingType::Buffer {
		ty: wgpu::BufferBindingType::Uniform,
		has_dynamic_offset: false,
		min_binding_size: None,
	},
};

pub const BINDING_BUFFER_BOTH: BindingLayout = BindingLayout {
	visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
	binding_type: BindingType::Buffer {
		ty: wgpu::BufferBindingType::Uniform,
		has_dynamic_offset: false,
		min_binding_size: None,
	},
};

pub const BINDING_SAMPLER_VERT: BindingLayout = BindingLayout {
	visibility: wgpu::ShaderStages::VERTEX,
	binding_type: BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
};

pub const BINDING_SAMPLER_FRAG: BindingLayout = BindingLayout {
	visibility: wgpu::ShaderStages::FRAGMENT,
	binding_type: BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
};

pub const BINDING_SAMPLER_BOTH: BindingLayout = BindingLayout {
	visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
	binding_type: BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
};

pub const BINDING_LAYER_VERT: LayerLayout = LayerLayout {
	visibility: wgpu::ShaderStages::VERTEX,
};

pub const BINDING_LAYER_FRAG: LayerLayout = LayerLayout {
	visibility: wgpu::ShaderStages::FRAGMENT,
};

pub const BINDING_LAYER_BOTH: LayerLayout = LayerLayout {
	visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
};
</file>

<file path="src/binding.rs">
//! # Binding System
//!
//! This module defines the binding system for shaders in the painter.
//!
//! ## Binding Types
//!
//! There are two main categories of bindings:
//!
//! - **ValueBindings**: Uniforms (buffers) and samplers that can be bound to shaders
//! - **LayerBindings**: Texture layers that can be bound as inputs to shaders
//!
//! ## Binding Override Hierarchy
//!
//! Bindings can be set at three levels, with later levels overriding earlier ones:
//!
//! 1. **Layer level** (lowest priority): Set via `Layer::set_layer_bindings()`
//! 2. **Shape/Effect level** (medium priority): Set when creating shapes/effects via `bindings` parameter
//! 3. **Instance level** (highest priority): Set via `InstanceBinding` for per-instance variation
//!
//! ### Override Rules:
//!
//! - Shape/Effect bindings override Layer bindings at the same binding slot
//! - Instance bindings override both Shape/Effect and Layer bindings at the same binding slot
//!
//! ## Instance Rendering Optimization
//!
//! The system optimizes rendering based on which binding types vary per-instance:
//!
//! - **No instances**: Set all bindings once, single draw call
//! - **Only value bindings vary**: Set layer bindings once, iterate through value bindings
//! - **Only layer bindings vary**: Set value bindings once, iterate through layer bindings
//! - **Both vary**: Iterate through all instances, setting both binding types per draw call
//!
//! This optimization is handled automatically by:
//! - `ValuesBindGroupData::from_bindings()` and `LayerBindGroupData::from_bindings()` in bind_group.rs
//! - `render_shape()` and `render_effect()` in painter.rs

use crate::{Painter, layer::Layer, painter::get_padded_size, sampler::Sampler};
use trivalibs_core::glam::{Mat3, Mat3A, Vec3, Vec3A};
use wgpu::{BindingType, ShaderStages};

#[derive(Clone, Copy)]
pub struct BindingLayout {
	pub(crate) binding_type: BindingType,
	pub(crate) visibility: ShaderStages,
}

#[derive(Clone, Copy)]
pub struct LayerLayout {
	pub(crate) visibility: ShaderStages,
}

#[derive(Clone, Copy)]
pub enum ValueBinding {
	Buffer(Buffer),
	Sampler(Sampler),
}

#[derive(Clone, Copy)]
pub enum LayerBinding {
	Source(Layer),
	AtIndex(Layer, usize),
	SourceAtMipLevel(Layer, u32),
	Depth(Layer),
}

#[derive(Clone, Copy)]
pub struct Buffer(pub(crate) usize);

impl Buffer {
	pub fn binding(&self) -> ValueBinding {
		ValueBinding::Buffer(*self)
	}
}

pub struct BindingBuffer<T> {
	buffer: Buffer,
	t: std::marker::PhantomData<T>,
}

impl<T> BindingBuffer<T>
where
	T: bytemuck::Pod,
{
	pub fn new(painter: &mut Painter, data: T) -> Self {
		let buffer = painter.device.create_buffer(&wgpu::BufferDescriptor {
			label: None,
			usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
			size: get_padded_size(std::mem::size_of::<T>() as u64),
			mapped_at_creation: false,
		});

		painter.buffers.push(buffer);

		let buffer = Buffer(painter.buffers.len() - 1);

		let binding = BindingBuffer {
			buffer,
			t: std::marker::PhantomData,
		};

		binding.update(&painter, data);

		binding
	}

	pub fn update(&self, painter: &Painter, data: T) {
		let buffer = &painter.buffers[self.buffer.0];
		painter
			.queue
			.write_buffer(buffer, 0, bytemuck::cast_slice(&[data]));
	}

	pub fn binding(&self) -> ValueBinding {
		ValueBinding::Buffer(self.buffer)
	}
}

#[repr(C)]
#[derive(Debug, Clone, Copy, bytemuck::Zeroable)]
pub struct Mat3U(pub(crate) Mat3A);
unsafe impl bytemuck::Pod for Mat3U {}

impl BindingBuffer<Mat3U> {
	pub fn new_mat3(painter: &mut Painter, data: Mat3) -> Self {
		BindingBuffer::new(painter, Mat3U(Mat3A::from(data)))
	}

	pub fn update_mat3(&self, painter: &Painter, data: Mat3) {
		self.update(painter, Mat3U(Mat3A::from(data)));
	}
}

#[repr(C)]
#[derive(Debug, Clone, Copy, bytemuck::Zeroable)]
pub struct Vec3U(pub(crate) Vec3A);
unsafe impl bytemuck::Pod for Vec3U {}

impl BindingBuffer<Vec3U> {
	pub fn new_vec3(painter: &mut Painter, data: Vec3) -> Self {
		BindingBuffer::new(painter, Vec3U(Vec3A::from(data)))
	}

	pub fn update_vec3(&self, painter: &Painter, data: Vec3) {
		self.update(painter, Vec3U(Vec3A::from(data)));
	}
}

/// Per-instance binding overrides.
///
/// Allows individual instances of shapes or effects to override the base bindings
/// set at the layer or shape/effect level.
///
/// # Fields
///
/// - `bindings`: Value bindings (buffers, samplers) to override, indexed by binding slot
/// - `layers`: Layer bindings (textures) to override, indexed by binding slot
///
/// # Override Behavior
///
/// - If `bindings` is empty for all instances, value bindings won't vary per-instance
/// - If `layers` is empty for all instances, layer bindings won't vary per-instance
/// - If both are populated in at least one instance, both binding types will be set per draw call
///
/// # Examples
///
/// ```ignore
/// // Instance with only value binding override (uniform color per instance)
/// let instance1 = InstanceBinding {
///     bindings: vec![(0, color_buffer.binding())],
///     layers: vec![],
/// };
///
/// // Instance with only layer binding override (different texture per instance)
/// let instance2 = InstanceBinding {
///     bindings: vec![],
///     layers: vec![(0, LayerBinding::Source(layer))],
/// };
///
/// // Instance with both overrides
/// let instance3 = InstanceBinding {
///     bindings: vec![(0, color_buffer.binding())],
///     layers: vec![(0, LayerBinding::Source(layer))],
/// };
/// ```
#[derive(Clone)]
pub struct InstanceBinding {
	pub bindings: Vec<(u32, ValueBinding)>,
	pub layers: Vec<(u32, LayerBinding)>,
}

impl Default for InstanceBinding {
	fn default() -> Self {
		Self {
			bindings: Vec::with_capacity(0),
			layers: Vec::with_capacity(0),
		}
	}
}
</file>

<file path="src/effect.rs">
use crate::{
	Painter,
	binding::{InstanceBinding, LayerBinding, ValueBinding},
	shade::Shade,
};

#[derive(Clone)]
pub struct EffectProps {
	pub bindings: Vec<(u32, ValueBinding)>,
	pub layers: Vec<(u32, LayerBinding)>,
	pub instances: Vec<InstanceBinding>,
	pub blend_state: wgpu::BlendState,
	pub dst_mip_level: Option<u32>,
	pub src_mip_level: Option<u32>,
}

impl Default for EffectProps {
	fn default() -> Self {
		EffectProps {
			bindings: Vec::with_capacity(0),
			layers: Vec::with_capacity(0),
			instances: Vec::with_capacity(0),
			blend_state: wgpu::BlendState::REPLACE,
			dst_mip_level: None,
			src_mip_level: None,
		}
	}
}

pub(crate) struct EffectStorage {
	pub shade: Shade,
	pub bindings: Vec<(u32, ValueBinding)>,
	pub layers: Vec<(u32, LayerBinding)>,
	pub instances: Vec<InstanceBinding>,
	pub pipeline_key: Vec<u8>,
	pub blend_state: wgpu::BlendState,
	pub dst_mip_level: Option<u32>,
	pub src_mip_level: Option<u32>,
}

#[derive(Clone, Copy, Debug)]
pub struct Effect(pub(crate) usize);

impl Effect {
	pub fn new(painter: &mut Painter, shade: Shade, props: EffectProps) -> Self {
		let pipeline_key = vec![
			(shade.0 as u16).to_le_bytes().to_vec(),
			vec![
				props.blend_state.alpha.dst_factor as u8,
				props.blend_state.alpha.src_factor as u8,
				props.blend_state.alpha.operation as u8,
				props.blend_state.color.dst_factor as u8,
				props.blend_state.color.src_factor as u8,
				props.blend_state.color.operation as u8,
			],
		]
		.into_iter()
		.flatten()
		.collect();

		let effect = EffectStorage {
			bindings: props.bindings,
			layers: props.layers,
			instances: props.instances,
			shade,
			pipeline_key,
			blend_state: props.blend_state,
			dst_mip_level: props.dst_mip_level,
			src_mip_level: props.src_mip_level,
		};

		painter.effects.push(effect);

		Self(painter.effects.len() - 1)
	}

	pub fn has_mip_target(&self, painter: &Painter) -> bool {
		let e = &painter.effects[self.0];
		e.dst_mip_level.is_some()
	}
	pub fn has_mip_source(&self, painter: &Painter) -> bool {
		let e = &painter.effects[self.0];
		e.src_mip_level.is_some()
	}
}

pub struct EffectBuilder<'a> {
	shade: Shade,
	props: EffectProps,
	painter: &'a mut Painter,
}

impl<'a> EffectBuilder<'a> {
	pub fn new(painter: &'a mut Painter, shade: Shade) -> Self {
		EffectBuilder {
			shade,
			painter,
			props: EffectProps::default(),
		}
	}

	pub fn create(self) -> Effect {
		Effect::new(self.painter, self.shade, self.props)
	}

	pub fn with_bindings<I>(mut self, bindings: I) -> Self
	where
		I: IntoIterator<Item = (u32, ValueBinding)>,
	{
		self.props.bindings = bindings.into_iter().collect();
		self
	}

	pub fn with_layers<I>(mut self, layers: I) -> Self
	where
		I: IntoIterator<Item = (u32, LayerBinding)>,
	{
		self.props.layers = layers.into_iter().collect();
		self
	}

	/// Repeatedly render this effect multiple times with different bindings into the same target without target swapping.
	/// This is useful for example for deferred lighting, where each light is rendered with custom blend state on top of the last.
	pub fn with_instances(mut self, instances: Vec<InstanceBinding>) -> Self {
		self.props.instances = instances;
		self
	}

	pub fn with_blend_state(mut self, blend_state: wgpu::BlendState) -> Self {
		self.props.blend_state = blend_state;
		self
	}

	pub fn with_mip_target(mut self, dst_mip_level: u32) -> Self {
		self.props.dst_mip_level = Some(dst_mip_level);
		self
	}

	pub fn with_mip_source(mut self, src_mip_level: u32) -> Self {
		self.props.src_mip_level = Some(src_mip_level);
		self
	}
}
</file>

<file path="src/events.rs">
/// Custom event types for painter, independent of winit

/// Pointer button types - device-agnostic naming
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum PointerButton {
	Primary,
	Secondary,
	Middle,
	Other(u16),
}

impl From<winit::event::MouseButton> for PointerButton {
	fn from(button: winit::event::MouseButton) -> Self {
		match button {
			winit::event::MouseButton::Left => PointerButton::Primary,
			winit::event::MouseButton::Right => PointerButton::Secondary,
			winit::event::MouseButton::Middle => PointerButton::Middle,
			winit::event::MouseButton::Back => PointerButton::Other(4),
			winit::event::MouseButton::Forward => PointerButton::Other(5),
			winit::event::MouseButton::Other(n) => PointerButton::Other(n),
		}
	}
}

/// Physical key codes - crate-local copy of winit's KeyCode
/// This allows WASM builds to emit events without depending on winit
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum KeyCode {
	/// <kbd>`</kbd> on a US keyboard. This is also called a backtick or grave.
	/// This is the <kbd></kbd>/<kbd></kbd>/<kbd></kbd>
	/// (hankaku/zenkaku/kanji) key on Japanese keyboards.
	Backquote,
	/// Used for both the US <kbd>\\</kbd> (on the 101-key layout) and also for the key
	/// located between the <kbd>"</kbd> and <kbd>Enter</kbd> keys on row C of the 102-,
	/// 104- and 106-key layouts.
	/// Labeled <kbd>#</kbd> on a UK (102) keyboard.
	Backslash,
	/// <kbd>[</kbd> on a US keyboard.
	BracketLeft,
	/// <kbd>]</kbd> on a US keyboard.
	BracketRight,
	/// <kbd>,</kbd> on a US keyboard.
	Comma,
	/// <kbd>0</kbd> on a US keyboard.
	Digit0,
	/// <kbd>1</kbd> on a US keyboard.
	Digit1,
	/// <kbd>2</kbd> on a US keyboard.
	Digit2,
	/// <kbd>3</kbd> on a US keyboard.
	Digit3,
	/// <kbd>4</kbd> on a US keyboard.
	Digit4,
	/// <kbd>5</kbd> on a US keyboard.
	Digit5,
	/// <kbd>6</kbd> on a US keyboard.
	Digit6,
	/// <kbd>7</kbd> on a US keyboard.
	Digit7,
	/// <kbd>8</kbd> on a US keyboard.
	Digit8,
	/// <kbd>9</kbd> on a US keyboard.
	Digit9,
	/// <kbd>=</kbd> on a US keyboard.
	Equal,
	/// Located between the left <kbd>Shift</kbd> and <kbd>Z</kbd> keys.
	/// Labeled <kbd>\\</kbd> on a UK keyboard.
	IntlBackslash,
	/// Located between the <kbd>/</kbd> and right <kbd>Shift</kbd> keys.
	/// Labeled <kbd>\\</kbd> (ro) on a Japanese keyboard.
	IntlRo,
	/// Located between the <kbd>=</kbd> and <kbd>Backspace</kbd> keys.
	/// Labeled <kbd></kbd> (yen) on a Japanese keyboard. <kbd>\\</kbd> on a
	/// Russian keyboard.
	IntlYen,
	/// <kbd>a</kbd> on a US keyboard.
	/// Labeled <kbd>q</kbd> on an AZERTY (e.g., French) keyboard.
	KeyA,
	/// <kbd>b</kbd> on a US keyboard.
	KeyB,
	/// <kbd>c</kbd> on a US keyboard.
	KeyC,
	/// <kbd>d</kbd> on a US keyboard.
	KeyD,
	/// <kbd>e</kbd> on a US keyboard.
	KeyE,
	/// <kbd>f</kbd> on a US keyboard.
	KeyF,
	/// <kbd>g</kbd> on a US keyboard.
	KeyG,
	/// <kbd>h</kbd> on a US keyboard.
	KeyH,
	/// <kbd>i</kbd> on a US keyboard.
	KeyI,
	/// <kbd>j</kbd> on a US keyboard.
	KeyJ,
	/// <kbd>k</kbd> on a US keyboard.
	KeyK,
	/// <kbd>l</kbd> on a US keyboard.
	KeyL,
	/// <kbd>m</kbd> on a US keyboard.
	KeyM,
	/// <kbd>n</kbd> on a US keyboard.
	KeyN,
	/// <kbd>o</kbd> on a US keyboard.
	KeyO,
	/// <kbd>p</kbd> on a US keyboard.
	KeyP,
	/// <kbd>q</kbd> on a US keyboard.
	/// Labeled <kbd>a</kbd> on an AZERTY (e.g., French) keyboard.
	KeyQ,
	/// <kbd>r</kbd> on a US keyboard.
	KeyR,
	/// <kbd>s</kbd> on a US keyboard.
	KeyS,
	/// <kbd>t</kbd> on a US keyboard.
	KeyT,
	/// <kbd>u</kbd> on a US keyboard.
	KeyU,
	/// <kbd>v</kbd> on a US keyboard.
	KeyV,
	/// <kbd>w</kbd> on a US keyboard.
	/// Labeled <kbd>z</kbd> on an AZERTY (e.g., French) keyboard.
	KeyW,
	/// <kbd>x</kbd> on a US keyboard.
	KeyX,
	/// <kbd>y</kbd> on a US keyboard.
	/// Labeled <kbd>z</kbd> on a QWERTZ (e.g., German) keyboard.
	KeyY,
	/// <kbd>z</kbd> on a US keyboard.
	/// Labeled <kbd>w</kbd> on an AZERTY (e.g., French) keyboard, and <kbd>y</kbd> on a
	/// QWERTZ (e.g., German) keyboard.
	KeyZ,
	/// <kbd>-</kbd> on a US keyboard.
	Minus,
	/// <kbd>.</kbd> on a US keyboard.
	Period,
	/// <kbd>'</kbd> on a US keyboard.
	Quote,
	/// <kbd>;</kbd> on a US keyboard.
	Semicolon,
	/// <kbd>/</kbd> on a US keyboard.
	Slash,
	/// <kbd>Alt</kbd>, <kbd>Option</kbd>, or <kbd></kbd>.
	AltLeft,
	/// <kbd>Alt</kbd>, <kbd>Option</kbd>, or <kbd></kbd>.
	/// This is labeled <kbd>AltGr</kbd> on many keyboard layouts.
	AltRight,
	/// <kbd>Backspace</kbd> or <kbd></kbd>.
	/// Labeled <kbd>Delete</kbd> on Apple keyboards.
	Backspace,
	/// <kbd>CapsLock</kbd> or <kbd></kbd>
	CapsLock,
	/// The application context menu key, which is typically found between the right
	/// <kbd>Super</kbd> key and the right <kbd>Control</kbd> key.
	ContextMenu,
	/// <kbd>Control</kbd> or <kbd></kbd>
	ControlLeft,
	/// <kbd>Control</kbd> or <kbd></kbd>
	ControlRight,
	/// <kbd>Enter</kbd> or <kbd></kbd>. Labeled <kbd>Return</kbd> on Apple keyboards.
	Enter,
	/// The Windows, <kbd></kbd>, <kbd>Command</kbd>, or other OS symbol key.
	SuperLeft,
	/// The Windows, <kbd></kbd>, <kbd>Command</kbd>, or other OS symbol key.
	SuperRight,
	/// <kbd>Shift</kbd> or <kbd></kbd>
	ShiftLeft,
	/// <kbd>Shift</kbd> or <kbd></kbd>
	ShiftRight,
	/// <kbd> </kbd> (space)
	Space,
	/// <kbd>Tab</kbd> or <kbd></kbd>
	Tab,
	/// Japanese: <kbd></kbd> (henkan)
	Convert,
	/// Japanese: <kbd></kbd>/<kbd></kbd>/<kbd></kbd> (katakana/hiragana/romaji)
	KanaMode,
	/// Korean: HangulMode <kbd>/</kbd> (han/yeong)
	///
	/// Japanese (Mac keyboard): <kbd></kbd> (kana)
	Lang1,
	/// Korean: Hanja <kbd></kbd> (hanja)
	///
	/// Japanese (Mac keyboard): <kbd></kbd> (eisu)
	Lang2,
	/// Japanese (word-processing keyboard): Katakana
	Lang3,
	/// Japanese (word-processing keyboard): Hiragana
	Lang4,
	/// Japanese (word-processing keyboard): Zenkaku/Hankaku
	Lang5,
	/// Japanese: <kbd></kbd> (muhenkan)
	NonConvert,
	/// <kbd></kbd>. The forward delete key.
	/// Note that on Apple keyboards, the key labelled <kbd>Delete</kbd> on the main part of
	/// the keyboard is encoded as [`Backspace`].
	///
	/// [`Backspace`]: Self::Backspace
	Delete,
	/// <kbd>Page Down</kbd>, <kbd>End</kbd>, or <kbd></kbd>
	End,
	/// <kbd>Help</kbd>. Not present on standard PC keyboards.
	Help,
	/// <kbd>Home</kbd> or <kbd></kbd>
	Home,
	/// <kbd>Insert</kbd> or <kbd>Ins</kbd>. Not present on Apple keyboards.
	Insert,
	/// <kbd>Page Down</kbd>, <kbd>PgDn</kbd>, or <kbd></kbd>
	PageDown,
	/// <kbd>Page Up</kbd>, <kbd>PgUp</kbd>, or <kbd></kbd>
	PageUp,
	/// <kbd></kbd>
	ArrowDown,
	/// <kbd></kbd>
	ArrowLeft,
	/// <kbd></kbd>
	ArrowRight,
	/// <kbd></kbd>
	ArrowUp,
	/// On the Mac, this is used for the numpad <kbd>Clear</kbd> key.
	NumLock,
	/// <kbd>0 Ins</kbd> on a keyboard. <kbd>0</kbd> on a phone or remote control
	Numpad0,
	/// <kbd>1 End</kbd> on a keyboard. <kbd>1</kbd> or <kbd>1 QZ</kbd> on a phone or remote control
	Numpad1,
	/// <kbd>2 </kbd> on a keyboard. <kbd>2 ABC</kbd> on a phone or remote control
	Numpad2,
	/// <kbd>3 PgDn</kbd> on a keyboard. <kbd>3 DEF</kbd> on a phone or remote control
	Numpad3,
	/// <kbd>4 </kbd> on a keyboard. <kbd>4 GHI</kbd> on a phone or remote control
	Numpad4,
	/// <kbd>5</kbd> on a keyboard. <kbd>5 JKL</kbd> on a phone or remote control
	Numpad5,
	/// <kbd>6 </kbd> on a keyboard. <kbd>6 MNO</kbd> on a phone or remote control
	Numpad6,
	/// <kbd>7 Home</kbd> on a keyboard. <kbd>7 PQRS</kbd> or <kbd>7 PRS</kbd> on a phone
	/// or remote control
	Numpad7,
	/// <kbd>8 </kbd> on a keyboard. <kbd>8 TUV</kbd> on a phone or remote control
	Numpad8,
	/// <kbd>9 PgUp</kbd> on a keyboard. <kbd>9 WXYZ</kbd> or <kbd>9 WXY</kbd> on a phone
	/// or remote control
	Numpad9,
	/// <kbd>+</kbd>
	NumpadAdd,
	/// Found on the Microsoft Natural Keyboard.
	NumpadBackspace,
	/// <kbd>C</kbd> or <kbd>A</kbd> (All Clear). Also for use with numpads that have a
	/// <kbd>Clear</kbd> key that is separate from the <kbd>NumLock</kbd> key. On the Mac, the
	/// numpad <kbd>Clear</kbd> key is encoded as [`NumLock`].
	///
	/// [`NumLock`]: Self::NumLock
	NumpadClear,
	/// <kbd>C</kbd> (Clear Entry)
	NumpadClearEntry,
	/// <kbd>,</kbd> (thousands separator). For locales where the thousands separator
	/// is a "." (e.g., Brazil), this key may generate a <kbd>.</kbd>.
	NumpadComma,
	/// <kbd>. Del</kbd>. For locales where the decimal separator is "," (e.g.,
	/// Brazil), this key may generate a <kbd>,</kbd>.
	NumpadDecimal,
	/// <kbd>/</kbd>
	NumpadDivide,
	NumpadEnter,
	/// <kbd>=</kbd>
	NumpadEqual,
	/// <kbd>#</kbd> on a phone or remote control device. This key is typically found
	/// below the <kbd>9</kbd> key and to the right of the <kbd>0</kbd> key.
	NumpadHash,
	/// <kbd>M</kbd> Add current entry to the value stored in memory.
	NumpadMemoryAdd,
	/// <kbd>M</kbd> Clear the value stored in memory.
	NumpadMemoryClear,
	/// <kbd>M</kbd> Replace the current entry with the value stored in memory.
	NumpadMemoryRecall,
	/// <kbd>M</kbd> Replace the value stored in memory with the current entry.
	NumpadMemoryStore,
	/// <kbd>M</kbd> Subtract current entry from the value stored in memory.
	NumpadMemorySubtract,
	/// <kbd>*</kbd> on a keyboard. For use with numpads that provide mathematical
	/// operations (<kbd>+</kbd>, <kbd>-</kbd> <kbd>*</kbd> and <kbd>/</kbd>).
	///
	/// Use `NumpadStar` for the <kbd>*</kbd> key on phones and remote controls.
	NumpadMultiply,
	/// <kbd>(</kbd> Found on the Microsoft Natural Keyboard.
	NumpadParenLeft,
	/// <kbd>)</kbd> Found on the Microsoft Natural Keyboard.
	NumpadParenRight,
	/// <kbd>*</kbd> on a phone or remote control device.
	///
	/// This key is typically found below the <kbd>7</kbd> key and to the left of
	/// the <kbd>0</kbd> key.
	///
	/// Use <kbd>"NumpadMultiply"</kbd> for the <kbd>*</kbd> key on
	/// numeric keypads.
	NumpadStar,
	/// <kbd>-</kbd>
	NumpadSubtract,
	/// <kbd>Esc</kbd> or <kbd></kbd>
	Escape,
	/// <kbd>Fn</kbd> This is typically a hardware key that does not generate a separate code.
	Fn,
	/// <kbd>FLock</kbd> or <kbd>FnLock</kbd>. Function Lock key. Found on the Microsoft
	/// Natural Keyboard.
	FnLock,
	/// <kbd>PrtScr SysRq</kbd> or <kbd>Print Screen</kbd>
	PrintScreen,
	/// <kbd>Scroll Lock</kbd>
	ScrollLock,
	/// <kbd>Pause Break</kbd>
	Pause,
	/// Some laptops place this key to the left of the <kbd></kbd> key.
	///
	/// This also the "back" button (triangle) on Android.
	BrowserBack,
	BrowserFavorites,
	/// Some laptops place this key to the right of the <kbd></kbd> key.
	BrowserForward,
	/// The "home" button on Android.
	BrowserHome,
	BrowserRefresh,
	BrowserSearch,
	BrowserStop,
	/// <kbd>Eject</kbd> or <kbd></kbd>. This key is placed in the function section on some Apple
	/// keyboards.
	Eject,
	/// Sometimes labelled <kbd>My Computer</kbd> on the keyboard
	LaunchApp1,
	/// Sometimes labelled <kbd>Calculator</kbd> on the keyboard
	LaunchApp2,
	LaunchMail,
	MediaPlayPause,
	MediaSelect,
	MediaStop,
	MediaTrackNext,
	MediaTrackPrevious,
	/// This key is placed in the function section on some Apple keyboards, replacing the
	/// <kbd>Eject</kbd> key.
	Power,
	Sleep,
	AudioVolumeDown,
	AudioVolumeMute,
	AudioVolumeUp,
	WakeUp,
	// Legacy modifier key. Also called "Super" in certain places.
	Meta,
	// Legacy modifier key.
	Hyper,
	Turbo,
	Abort,
	Resume,
	Suspend,
	/// Found on Sun's USB keyboard.
	Again,
	/// Found on Sun's USB keyboard.
	Copy,
	/// Found on Sun's USB keyboard.
	Cut,
	/// Found on Sun's USB keyboard.
	Find,
	/// Found on Sun's USB keyboard.
	Open,
	/// Found on Sun's USB keyboard.
	Paste,
	/// Found on Sun's USB keyboard.
	Props,
	/// Found on Sun's USB keyboard.
	Select,
	/// Found on Sun's USB keyboard.
	Undo,
	/// Use for dedicated <kbd></kbd> key found on some Japanese word processing keyboards.
	Hiragana,
	/// Use for dedicated <kbd></kbd> key found on some Japanese word processing keyboards.
	Katakana,
	/// General-purpose function key.
	/// Usually found at the top of the keyboard.
	F1,
	/// General-purpose function key.
	/// Usually found at the top of the keyboard.
	F2,
	/// General-purpose function key.
	/// Usually found at the top of the keyboard.
	F3,
	/// General-purpose function key.
	/// Usually found at the top of the keyboard.
	F4,
	/// General-purpose function key.
	/// Usually found at the top of the keyboard.
	F5,
	/// General-purpose function key.
	/// Usually found at the top of the keyboard.
	F6,
	/// General-purpose function key.
	/// Usually found at the top of the keyboard.
	F7,
	/// General-purpose function key.
	/// Usually found at the top of the keyboard.
	F8,
	/// General-purpose function key.
	/// Usually found at the top of the keyboard.
	F9,
	/// General-purpose function key.
	/// Usually found at the top of the keyboard.
	F10,
	/// General-purpose function key.
	/// Usually found at the top of the keyboard.
	F11,
	/// General-purpose function key.
	/// Usually found at the top of the keyboard.
	F12,
	/// General-purpose function key.
	/// Usually found at the top of the keyboard.
	F13,
	/// General-purpose function key.
	/// Usually found at the top of the keyboard.
	F14,
	/// General-purpose function key.
	/// Usually found at the top of the keyboard.
	F15,
	/// General-purpose function key.
	/// Usually found at the top of the keyboard.
	F16,
	/// General-purpose function key.
	/// Usually found at the top of the keyboard.
	F17,
	/// General-purpose function key.
	/// Usually found at the top of the keyboard.
	F18,
	/// General-purpose function key.
	/// Usually found at the top of the keyboard.
	F19,
	/// General-purpose function key.
	/// Usually found at the top of the keyboard.
	F20,
	/// General-purpose function key.
	/// Usually found at the top of the keyboard.
	F21,
	/// General-purpose function key.
	/// Usually found at the top of the keyboard.
	F22,
	/// General-purpose function key.
	/// Usually found at the top of the keyboard.
	F23,
	/// General-purpose function key.
	/// Usually found at the top of the keyboard.
	F24,
	/// General-purpose function key.
	F25,
	/// General-purpose function key.
	F26,
	/// General-purpose function key.
	F27,
	/// General-purpose function key.
	F28,
	/// General-purpose function key.
	F29,
	/// General-purpose function key.
	F30,
	/// General-purpose function key.
	F31,
	/// General-purpose function key.
	F32,
	/// General-purpose function key.
	F33,
	/// General-purpose function key.
	F34,
	/// General-purpose function key.
	F35,
}

impl From<winit::keyboard::KeyCode> for KeyCode {
	fn from(key: winit::keyboard::KeyCode) -> Self {
		match key {
			winit::keyboard::KeyCode::Backquote => KeyCode::Backquote,
			winit::keyboard::KeyCode::Backslash => KeyCode::Backslash,
			winit::keyboard::KeyCode::BracketLeft => KeyCode::BracketLeft,
			winit::keyboard::KeyCode::BracketRight => KeyCode::BracketRight,
			winit::keyboard::KeyCode::Comma => KeyCode::Comma,
			winit::keyboard::KeyCode::Digit0 => KeyCode::Digit0,
			winit::keyboard::KeyCode::Digit1 => KeyCode::Digit1,
			winit::keyboard::KeyCode::Digit2 => KeyCode::Digit2,
			winit::keyboard::KeyCode::Digit3 => KeyCode::Digit3,
			winit::keyboard::KeyCode::Digit4 => KeyCode::Digit4,
			winit::keyboard::KeyCode::Digit5 => KeyCode::Digit5,
			winit::keyboard::KeyCode::Digit6 => KeyCode::Digit6,
			winit::keyboard::KeyCode::Digit7 => KeyCode::Digit7,
			winit::keyboard::KeyCode::Digit8 => KeyCode::Digit8,
			winit::keyboard::KeyCode::Digit9 => KeyCode::Digit9,
			winit::keyboard::KeyCode::Equal => KeyCode::Equal,
			winit::keyboard::KeyCode::IntlBackslash => KeyCode::IntlBackslash,
			winit::keyboard::KeyCode::IntlRo => KeyCode::IntlRo,
			winit::keyboard::KeyCode::IntlYen => KeyCode::IntlYen,
			winit::keyboard::KeyCode::KeyA => KeyCode::KeyA,
			winit::keyboard::KeyCode::KeyB => KeyCode::KeyB,
			winit::keyboard::KeyCode::KeyC => KeyCode::KeyC,
			winit::keyboard::KeyCode::KeyD => KeyCode::KeyD,
			winit::keyboard::KeyCode::KeyE => KeyCode::KeyE,
			winit::keyboard::KeyCode::KeyF => KeyCode::KeyF,
			winit::keyboard::KeyCode::KeyG => KeyCode::KeyG,
			winit::keyboard::KeyCode::KeyH => KeyCode::KeyH,
			winit::keyboard::KeyCode::KeyI => KeyCode::KeyI,
			winit::keyboard::KeyCode::KeyJ => KeyCode::KeyJ,
			winit::keyboard::KeyCode::KeyK => KeyCode::KeyK,
			winit::keyboard::KeyCode::KeyL => KeyCode::KeyL,
			winit::keyboard::KeyCode::KeyM => KeyCode::KeyM,
			winit::keyboard::KeyCode::KeyN => KeyCode::KeyN,
			winit::keyboard::KeyCode::KeyO => KeyCode::KeyO,
			winit::keyboard::KeyCode::KeyP => KeyCode::KeyP,
			winit::keyboard::KeyCode::KeyQ => KeyCode::KeyQ,
			winit::keyboard::KeyCode::KeyR => KeyCode::KeyR,
			winit::keyboard::KeyCode::KeyS => KeyCode::KeyS,
			winit::keyboard::KeyCode::KeyT => KeyCode::KeyT,
			winit::keyboard::KeyCode::KeyU => KeyCode::KeyU,
			winit::keyboard::KeyCode::KeyV => KeyCode::KeyV,
			winit::keyboard::KeyCode::KeyW => KeyCode::KeyW,
			winit::keyboard::KeyCode::KeyX => KeyCode::KeyX,
			winit::keyboard::KeyCode::KeyY => KeyCode::KeyY,
			winit::keyboard::KeyCode::KeyZ => KeyCode::KeyZ,
			winit::keyboard::KeyCode::Minus => KeyCode::Minus,
			winit::keyboard::KeyCode::Period => KeyCode::Period,
			winit::keyboard::KeyCode::Quote => KeyCode::Quote,
			winit::keyboard::KeyCode::Semicolon => KeyCode::Semicolon,
			winit::keyboard::KeyCode::Slash => KeyCode::Slash,
			winit::keyboard::KeyCode::AltLeft => KeyCode::AltLeft,
			winit::keyboard::KeyCode::AltRight => KeyCode::AltRight,
			winit::keyboard::KeyCode::Backspace => KeyCode::Backspace,
			winit::keyboard::KeyCode::CapsLock => KeyCode::CapsLock,
			winit::keyboard::KeyCode::ContextMenu => KeyCode::ContextMenu,
			winit::keyboard::KeyCode::ControlLeft => KeyCode::ControlLeft,
			winit::keyboard::KeyCode::ControlRight => KeyCode::ControlRight,
			winit::keyboard::KeyCode::Enter => KeyCode::Enter,
			winit::keyboard::KeyCode::SuperLeft => KeyCode::SuperLeft,
			winit::keyboard::KeyCode::SuperRight => KeyCode::SuperRight,
			winit::keyboard::KeyCode::ShiftLeft => KeyCode::ShiftLeft,
			winit::keyboard::KeyCode::ShiftRight => KeyCode::ShiftRight,
			winit::keyboard::KeyCode::Space => KeyCode::Space,
			winit::keyboard::KeyCode::Tab => KeyCode::Tab,
			winit::keyboard::KeyCode::Convert => KeyCode::Convert,
			winit::keyboard::KeyCode::KanaMode => KeyCode::KanaMode,
			winit::keyboard::KeyCode::Lang1 => KeyCode::Lang1,
			winit::keyboard::KeyCode::Lang2 => KeyCode::Lang2,
			winit::keyboard::KeyCode::Lang3 => KeyCode::Lang3,
			winit::keyboard::KeyCode::Lang4 => KeyCode::Lang4,
			winit::keyboard::KeyCode::Lang5 => KeyCode::Lang5,
			winit::keyboard::KeyCode::NonConvert => KeyCode::NonConvert,
			winit::keyboard::KeyCode::Delete => KeyCode::Delete,
			winit::keyboard::KeyCode::End => KeyCode::End,
			winit::keyboard::KeyCode::Help => KeyCode::Help,
			winit::keyboard::KeyCode::Home => KeyCode::Home,
			winit::keyboard::KeyCode::Insert => KeyCode::Insert,
			winit::keyboard::KeyCode::PageDown => KeyCode::PageDown,
			winit::keyboard::KeyCode::PageUp => KeyCode::PageUp,
			winit::keyboard::KeyCode::ArrowDown => KeyCode::ArrowDown,
			winit::keyboard::KeyCode::ArrowLeft => KeyCode::ArrowLeft,
			winit::keyboard::KeyCode::ArrowRight => KeyCode::ArrowRight,
			winit::keyboard::KeyCode::ArrowUp => KeyCode::ArrowUp,
			winit::keyboard::KeyCode::NumLock => KeyCode::NumLock,
			winit::keyboard::KeyCode::Numpad0 => KeyCode::Numpad0,
			winit::keyboard::KeyCode::Numpad1 => KeyCode::Numpad1,
			winit::keyboard::KeyCode::Numpad2 => KeyCode::Numpad2,
			winit::keyboard::KeyCode::Numpad3 => KeyCode::Numpad3,
			winit::keyboard::KeyCode::Numpad4 => KeyCode::Numpad4,
			winit::keyboard::KeyCode::Numpad5 => KeyCode::Numpad5,
			winit::keyboard::KeyCode::Numpad6 => KeyCode::Numpad6,
			winit::keyboard::KeyCode::Numpad7 => KeyCode::Numpad7,
			winit::keyboard::KeyCode::Numpad8 => KeyCode::Numpad8,
			winit::keyboard::KeyCode::Numpad9 => KeyCode::Numpad9,
			winit::keyboard::KeyCode::NumpadAdd => KeyCode::NumpadAdd,
			winit::keyboard::KeyCode::NumpadBackspace => KeyCode::NumpadBackspace,
			winit::keyboard::KeyCode::NumpadClear => KeyCode::NumpadClear,
			winit::keyboard::KeyCode::NumpadClearEntry => KeyCode::NumpadClearEntry,
			winit::keyboard::KeyCode::NumpadComma => KeyCode::NumpadComma,
			winit::keyboard::KeyCode::NumpadDecimal => KeyCode::NumpadDecimal,
			winit::keyboard::KeyCode::NumpadDivide => KeyCode::NumpadDivide,
			winit::keyboard::KeyCode::NumpadEnter => KeyCode::NumpadEnter,
			winit::keyboard::KeyCode::NumpadEqual => KeyCode::NumpadEqual,
			winit::keyboard::KeyCode::NumpadHash => KeyCode::NumpadHash,
			winit::keyboard::KeyCode::NumpadMemoryAdd => KeyCode::NumpadMemoryAdd,
			winit::keyboard::KeyCode::NumpadMemoryClear => KeyCode::NumpadMemoryClear,
			winit::keyboard::KeyCode::NumpadMemoryRecall => KeyCode::NumpadMemoryRecall,
			winit::keyboard::KeyCode::NumpadMemoryStore => KeyCode::NumpadMemoryStore,
			winit::keyboard::KeyCode::NumpadMemorySubtract => KeyCode::NumpadMemorySubtract,
			winit::keyboard::KeyCode::NumpadMultiply => KeyCode::NumpadMultiply,
			winit::keyboard::KeyCode::NumpadParenLeft => KeyCode::NumpadParenLeft,
			winit::keyboard::KeyCode::NumpadParenRight => KeyCode::NumpadParenRight,
			winit::keyboard::KeyCode::NumpadStar => KeyCode::NumpadStar,
			winit::keyboard::KeyCode::NumpadSubtract => KeyCode::NumpadSubtract,
			winit::keyboard::KeyCode::Escape => KeyCode::Escape,
			winit::keyboard::KeyCode::Fn => KeyCode::Fn,
			winit::keyboard::KeyCode::FnLock => KeyCode::FnLock,
			winit::keyboard::KeyCode::PrintScreen => KeyCode::PrintScreen,
			winit::keyboard::KeyCode::ScrollLock => KeyCode::ScrollLock,
			winit::keyboard::KeyCode::Pause => KeyCode::Pause,
			winit::keyboard::KeyCode::BrowserBack => KeyCode::BrowserBack,
			winit::keyboard::KeyCode::BrowserFavorites => KeyCode::BrowserFavorites,
			winit::keyboard::KeyCode::BrowserForward => KeyCode::BrowserForward,
			winit::keyboard::KeyCode::BrowserHome => KeyCode::BrowserHome,
			winit::keyboard::KeyCode::BrowserRefresh => KeyCode::BrowserRefresh,
			winit::keyboard::KeyCode::BrowserSearch => KeyCode::BrowserSearch,
			winit::keyboard::KeyCode::BrowserStop => KeyCode::BrowserStop,
			winit::keyboard::KeyCode::Eject => KeyCode::Eject,
			winit::keyboard::KeyCode::LaunchApp1 => KeyCode::LaunchApp1,
			winit::keyboard::KeyCode::LaunchApp2 => KeyCode::LaunchApp2,
			winit::keyboard::KeyCode::LaunchMail => KeyCode::LaunchMail,
			winit::keyboard::KeyCode::MediaPlayPause => KeyCode::MediaPlayPause,
			winit::keyboard::KeyCode::MediaSelect => KeyCode::MediaSelect,
			winit::keyboard::KeyCode::MediaStop => KeyCode::MediaStop,
			winit::keyboard::KeyCode::MediaTrackNext => KeyCode::MediaTrackNext,
			winit::keyboard::KeyCode::MediaTrackPrevious => KeyCode::MediaTrackPrevious,
			winit::keyboard::KeyCode::Power => KeyCode::Power,
			winit::keyboard::KeyCode::Sleep => KeyCode::Sleep,
			winit::keyboard::KeyCode::AudioVolumeDown => KeyCode::AudioVolumeDown,
			winit::keyboard::KeyCode::AudioVolumeMute => KeyCode::AudioVolumeMute,
			winit::keyboard::KeyCode::AudioVolumeUp => KeyCode::AudioVolumeUp,
			winit::keyboard::KeyCode::WakeUp => KeyCode::WakeUp,
			winit::keyboard::KeyCode::Meta => KeyCode::Meta,
			winit::keyboard::KeyCode::Hyper => KeyCode::Hyper,
			winit::keyboard::KeyCode::Turbo => KeyCode::Turbo,
			winit::keyboard::KeyCode::Abort => KeyCode::Abort,
			winit::keyboard::KeyCode::Resume => KeyCode::Resume,
			winit::keyboard::KeyCode::Suspend => KeyCode::Suspend,
			winit::keyboard::KeyCode::Again => KeyCode::Again,
			winit::keyboard::KeyCode::Copy => KeyCode::Copy,
			winit::keyboard::KeyCode::Cut => KeyCode::Cut,
			winit::keyboard::KeyCode::Find => KeyCode::Find,
			winit::keyboard::KeyCode::Open => KeyCode::Open,
			winit::keyboard::KeyCode::Paste => KeyCode::Paste,
			winit::keyboard::KeyCode::Props => KeyCode::Props,
			winit::keyboard::KeyCode::Select => KeyCode::Select,
			winit::keyboard::KeyCode::Undo => KeyCode::Undo,
			winit::keyboard::KeyCode::Hiragana => KeyCode::Hiragana,
			winit::keyboard::KeyCode::Katakana => KeyCode::Katakana,
			winit::keyboard::KeyCode::F1 => KeyCode::F1,
			winit::keyboard::KeyCode::F2 => KeyCode::F2,
			winit::keyboard::KeyCode::F3 => KeyCode::F3,
			winit::keyboard::KeyCode::F4 => KeyCode::F4,
			winit::keyboard::KeyCode::F5 => KeyCode::F5,
			winit::keyboard::KeyCode::F6 => KeyCode::F6,
			winit::keyboard::KeyCode::F7 => KeyCode::F7,
			winit::keyboard::KeyCode::F8 => KeyCode::F8,
			winit::keyboard::KeyCode::F9 => KeyCode::F9,
			winit::keyboard::KeyCode::F10 => KeyCode::F10,
			winit::keyboard::KeyCode::F11 => KeyCode::F11,
			winit::keyboard::KeyCode::F12 => KeyCode::F12,
			winit::keyboard::KeyCode::F13 => KeyCode::F13,
			winit::keyboard::KeyCode::F14 => KeyCode::F14,
			winit::keyboard::KeyCode::F15 => KeyCode::F15,
			winit::keyboard::KeyCode::F16 => KeyCode::F16,
			winit::keyboard::KeyCode::F17 => KeyCode::F17,
			winit::keyboard::KeyCode::F18 => KeyCode::F18,
			winit::keyboard::KeyCode::F19 => KeyCode::F19,
			winit::keyboard::KeyCode::F20 => KeyCode::F20,
			winit::keyboard::KeyCode::F21 => KeyCode::F21,
			winit::keyboard::KeyCode::F22 => KeyCode::F22,
			winit::keyboard::KeyCode::F23 => KeyCode::F23,
			winit::keyboard::KeyCode::F24 => KeyCode::F24,
			winit::keyboard::KeyCode::F25 => KeyCode::F25,
			winit::keyboard::KeyCode::F26 => KeyCode::F26,
			winit::keyboard::KeyCode::F27 => KeyCode::F27,
			winit::keyboard::KeyCode::F28 => KeyCode::F28,
			winit::keyboard::KeyCode::F29 => KeyCode::F29,
			winit::keyboard::KeyCode::F30 => KeyCode::F30,
			winit::keyboard::KeyCode::F31 => KeyCode::F31,
			winit::keyboard::KeyCode::F32 => KeyCode::F32,
			winit::keyboard::KeyCode::F33 => KeyCode::F33,
			winit::keyboard::KeyCode::F34 => KeyCode::F34,
			winit::keyboard::KeyCode::F35 => KeyCode::F35,
			_ => KeyCode::Escape, // Fallback for any unmapped keys
		}
	}
}

/// Custom events for painter applications
#[derive(Debug)]
pub enum Event<UserEvent> {
	/// Pointer button pressed
	PointerDown {
		button: PointerButton,
		x: f64,
		y: f64,
	},
	/// Pointer button released
	PointerUp {
		button: PointerButton,
		x: f64,
		y: f64,
	},
	/// Pointer moved
	/// When mouse_lock is false: x/y are absolute cursor coordinates, delta_x/delta_y show movement
	/// When mouse_lock is true: x/y are 0, delta_x/delta_y contain raw motion deltas
	PointerMove {
		x: f64,
		y: f64,
		delta_x: f64,
		delta_y: f64,
		mouse_lock: bool,
	},
	/// Key pressed
	KeyDown { key: KeyCode },
	/// Key released
	KeyUp { key: KeyCode },
	/// User-defined event
	UserEvent(UserEvent),
	/// Shader file was reloaded (debug mode only)
	ShaderReloadEvent,
}
</file>

<file path="src/form.rs">
use crate::{Painter, painter::get_padded_size};
use trivalibs_core::rendering::BufferedGeometry;

#[derive(Clone, Copy)]
pub struct FormProps {
	pub topology: wgpu::PrimitiveTopology,
	pub front_face: wgpu::FrontFace,
}

impl Default for FormProps {
	fn default() -> Self {
		FormProps {
			topology: wgpu::PrimitiveTopology::TriangleList,
			front_face: wgpu::FrontFace::Ccw,
		}
	}
}

pub(crate) struct FormGPUBuffers {
	pub vertex_buffer: wgpu::Buffer,
	pub vertex_buffer_max_size: u64,
	pub vertex_buffer_current_size: u64,
	pub vertex_count: u32,

	pub index_buffer: Option<wgpu::Buffer>,
	pub index_buffer_max_size: u64,
	pub index_buffer_current_size: u64,
	pub index_count: u32,
}

pub(crate) struct FormStorage {
	pub buffers: Vec<FormGPUBuffers>,
	pub currently_active_buffers: usize,
	pub props: FormProps,
}

fn create_form_gpu_buffers(device: &wgpu::Device, vertex_size: u64) -> FormGPUBuffers {
	let padded_size = get_padded_size(vertex_size);
	let vertex_buffer = device.create_buffer(&wgpu::BufferDescriptor {
		label: None,
		usage: wgpu::BufferUsages::VERTEX | wgpu::BufferUsages::COPY_DST,
		size: padded_size,
		mapped_at_creation: false,
	});

	FormGPUBuffers {
		vertex_buffer,
		vertex_buffer_max_size: padded_size,
		vertex_buffer_current_size: 0,
		vertex_count: 0,
		index_buffer: None,
		index_buffer_max_size: 0,
		index_buffer_current_size: 0,
		index_count: 0,
	}
}

pub struct FormData<'a, T>
where
	T: bytemuck::Pod + bytemuck::Zeroable,
{
	pub vertex_buffer: &'a [T],
	pub index_buffer: Option<&'a [u32]>,
}

pub struct FormBuffer<'a> {
	vertex_buffer: &'a [u8],
	vertex_count: u32,
	index_buffer: Option<&'a [u8]>,
	index_count: u32,
}

impl<'a, T> Into<FormBuffer<'a>> for FormData<'a, T>
where
	T: bytemuck::Pod + bytemuck::Zeroable,
{
	fn into(self) -> FormBuffer<'a> {
		FormBuffer {
			vertex_buffer: bytemuck::cast_slice(self.vertex_buffer),
			vertex_count: self.vertex_buffer.len() as u32,
			index_buffer: self.index_buffer.map(|i| bytemuck::cast_slice(i)),
			index_count: self.index_buffer.map(|i| i.len() as u32).unwrap_or(0),
		}
	}
}

impl<'a> Into<FormBuffer<'a>> for &'a BufferedGeometry {
	fn into(self) -> FormBuffer<'a> {
		FormBuffer {
			vertex_buffer: self.vertex_buffer.as_slice(),
			vertex_count: self.vertex_count,
			index_buffer: self.index_buffer.as_deref(),
			index_count: self.index_count,
		}
	}
}

impl<'a, T: bytemuck::Pod> Into<FormBuffer<'a>> for &'a [T] {
	fn into(self) -> FormBuffer<'a> {
		FormBuffer {
			vertex_buffer: bytemuck::cast_slice(self),
			index_buffer: None,
			vertex_count: self.len() as u32,
			index_count: 0,
		}
	}
}

impl<'a, T: bytemuck::Pod> Into<FormBuffer<'a>> for &'a Vec<T> {
	fn into(self) -> FormBuffer<'a> {
		FormBuffer {
			vertex_buffer: bytemuck::cast_slice(self.as_slice()),
			index_buffer: None,
			vertex_count: self.len() as u32,
			index_count: 0,
		}
	}
}

#[derive(Clone, Copy)]
pub struct Form(pub(crate) usize);

impl Form {
	pub fn update_all<'a, I, B>(&self, painter: &mut Painter, buffers: I)
	where
		I: IntoIterator<Item = B>,
		B: Into<FormBuffer<'a>>,
	{
		let f = &mut painter.forms[self.0];
		let buffers: Vec<FormBuffer<'a>> = buffers.into_iter().map(|b| b.into()).collect();

		// Allocate new buffers if we need more than we currently have
		while f.buffers.len() < buffers.len() {
			let buf_index = f.buffers.len();
			let vertex_size = buffers[buf_index].vertex_buffer.len() as u64;
			f.buffers
				.push(create_form_gpu_buffers(&painter.device, vertex_size));
		}

		for (i, buf) in buffers.iter().enumerate() {
			let f_buf = &mut f.buffers[i];

			// Handle vertex buffer
			let vertex_size = buf.vertex_buffer.len() as u64;
			let padded_vertex_size = get_padded_size(vertex_size);

			// If the new data is larger than max_size, recreate the vertex buffer
			if f_buf.vertex_buffer_max_size < padded_vertex_size {
				f_buf.vertex_buffer.destroy();
				f_buf.vertex_buffer = painter.device.create_buffer(&wgpu::BufferDescriptor {
					label: None,
					usage: wgpu::BufferUsages::VERTEX | wgpu::BufferUsages::COPY_DST,
					size: padded_vertex_size,
					mapped_at_creation: false,
				});
				f_buf.vertex_buffer_max_size = padded_vertex_size;
			}

			f_buf.vertex_count = buf.vertex_count;
			f_buf.vertex_buffer_current_size = vertex_size;

			painter
				.queue
				.write_buffer(&f_buf.vertex_buffer, 0, &buf.vertex_buffer);

			// Handle index buffer
			if let Some(index_data) = buf.index_buffer {
				let index_size = index_data.len() as u64;
				let padded_index_size = get_padded_size(index_size);

				// If buffer doesn't exist yet (lazy init) or new data is larger, (re)create it
				if f_buf.index_buffer.is_none() || f_buf.index_buffer_max_size < padded_index_size {
					f_buf.index_buffer.as_ref().map(|b| b.destroy());
					f_buf.index_buffer =
						Some(painter.device.create_buffer(&wgpu::BufferDescriptor {
							label: None,
							usage: wgpu::BufferUsages::INDEX | wgpu::BufferUsages::COPY_DST,
							size: padded_index_size,
							mapped_at_creation: false,
						}));
					f_buf.index_buffer_max_size = padded_index_size;
				}

				f_buf.index_count = buf.index_count;
				f_buf.index_buffer_current_size = index_size;

				let index_buffer = f_buf.index_buffer.as_ref().unwrap();
				painter.queue.write_buffer(index_buffer, 0, &index_data);
			} else {
				f_buf.index_count = 0;
				f_buf.index_buffer_current_size = 0;
			}
		}

		// Update the count of buffers that contain valid data
		f.currently_active_buffers = buffers.len();
	}

	pub fn update<'a>(&self, painter: &mut Painter, buffer: impl Into<FormBuffer<'a>>) {
		self.update_all(painter, vec![buffer.into()]);
	}

	pub fn new_with_sizes(painter: &mut Painter, sizes: &[u64], props: FormProps) -> Self {
		let mut buffers = Vec::with_capacity(sizes.len());
		for size in sizes {
			buffers.push(create_form_gpu_buffers(&painter.device, *size));
		}

		let f = FormStorage {
			buffers,
			currently_active_buffers: 0, // No data yet - will be set by update_all
			props,
		};

		let i = painter.forms.len();
		painter.forms.push(f);

		return Form(i);
	}

	pub fn new<'a, I, B>(painter: &mut Painter, buffers: I, props: FormProps) -> Self
	where
		I: IntoIterator<Item = B>,
		B: Into<FormBuffer<'a>>,
	{
		let form = Form::new_with_sizes(painter, &[], props);

		form.update_all(painter, buffers);

		form
	}
}

pub struct FormBuilder<'a, 'b> {
	painter: &'a mut Painter,
	buffers: Vec<FormBuffer<'b>>,
	sizes: Vec<u64>,
	props: FormProps,
}

impl<'a, 'b> FormBuilder<'a, 'b> {
	pub fn new(painter: &'a mut Painter) -> Self {
		FormBuilder {
			painter,
			buffers: Vec::with_capacity(1),
			sizes: Vec::with_capacity(1),
			props: FormProps::default(),
		}
	}

	pub fn create(self) -> Form {
		if self.sizes.len() == 0 {
			return Form::new(self.painter, self.buffers, self.props);
		}
		let f = Form::new_with_sizes(self.painter, &self.sizes, self.props);
		f.update_all(self.painter, self.buffers);
		f
	}

	pub fn with_sizes<I>(mut self, sizes: I) -> Self
	where
		I: IntoIterator<Item = u64>,
	{
		self.sizes = sizes.into_iter().collect();
		self
	}

	pub fn with_size(mut self, size: u64) -> Self {
		self.sizes.push(size);
		self
	}

	pub fn with_buffer(mut self, buffer: impl Into<FormBuffer<'b>>) -> Self {
		self.buffers.push(buffer.into());
		self
	}

	pub fn with_buffers<I, B>(mut self, buffers: I) -> Self
	where
		I: IntoIterator<Item = B>,
		B: Into<FormBuffer<'b>>,
	{
		self.buffers = buffers.into_iter().map(|b| b.into()).collect();
		self
	}

	pub fn with_topology(mut self, topology: wgpu::PrimitiveTopology) -> Self {
		self.props.topology = topology;
		self
	}

	pub fn with_front_face(mut self, front_face: wgpu::FrontFace) -> Self {
		self.props.front_face = front_face;
		self
	}
}
</file>

<file path="src/layer.rs">
use crate::{
	Painter,
	bind_group::{BindGroup, LayerBindGroupData},
	binding::{InstanceBinding, LayerBinding, LayerLayout, ValueBinding},
	effect::Effect,
	prelude::{BINDING_LAYER_BOTH, BINDING_LAYER_FRAG, BINDING_LAYER_VERT},
	shade::Shade,
	shape::Shape,
	texture::{MipMapCount, Texture, Texture2DProps},
	texture_utils::map_format_to_u8,
};

/// Describes the instance rendering strategy to use based on binding configurations.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub(crate) enum InstanceRenderingStrategy {
	/// No instances - both value and layer bindings  1
	/// Set both bind groups once and do single draw
	NoInstances,
	/// Only value bindings vary - values > 1, layers  1
	/// Set layer bindings once, iterate through value bindings
	ValueBindingsVary,
	/// Only layer bindings vary - layers > 1, values  1
	/// Set value bindings once, iterate through layer bindings
	LayerBindingsVary,
	/// Both bindings vary - both > 1
	/// Iterate through all instances, setting both bind groups per draw
	BothBindingsVary,
}

impl InstanceRenderingStrategy {
	/// Determines the rendering strategy based on bind group counts.
	pub(crate) fn from_counts(value_count: usize, layer_count: usize) -> Self {
		match (value_count <= 1, layer_count <= 1) {
			(true, true) => Self::NoInstances,
			(false, true) => Self::ValueBindingsVary,
			(true, false) => Self::LayerBindingsVary,
			(false, false) => Self::BothBindingsVary,
		}
	}
}

#[derive(Clone)]
pub struct LayerProps<'a> {
	pub static_texture: bool,
	pub static_texture_data: Option<&'a [u8]>,
	pub shapes: Vec<Shape>,
	pub effects: Vec<Effect>,
	pub bindings: Vec<(u32, ValueBinding)>,
	pub layers: Vec<(u32, LayerBinding)>,
	pub width: u32,
	pub height: u32,
	pub formats: Vec<wgpu::TextureFormat>,
	pub clear_color: Option<wgpu::Color>,
	pub depth_test: bool,
	pub layer_layout: LayerLayout,
	pub multisampled: bool,
	pub mips: Option<MipMapCount>,
}

impl Default for LayerProps<'_> {
	fn default() -> Self {
		LayerProps {
			static_texture: false,
			static_texture_data: None,
			shapes: Vec::with_capacity(0),
			effects: Vec::with_capacity(0),
			bindings: Vec::with_capacity(0),
			layers: Vec::with_capacity(0),
			width: 0,
			height: 0,
			formats: Vec::with_capacity(1),
			layer_layout: BINDING_LAYER_FRAG,
			clear_color: None,
			depth_test: false,
			multisampled: false,
			mips: None,
		}
	}
}

/// Encapsulates a single shape and its per-layer binding state.
#[derive(Clone)]
pub(crate) struct ShapeData {
	pub shape: Shape,
	pub bind_groups: Vec<BindGroup>,
	pub layer_bind_group_data: Option<LayerBindGroupData>,
	pub rendering_strategy: InstanceRenderingStrategy,
}

impl ShapeData {
	/// Creates a new ShapeData with bindings prepared using explicit layer data.
	pub(crate) fn new(
		painter: &mut Painter,
		shape: Shape,
		layer_bindings: &[(u32, ValueBinding)],
		layer_layers: &[(u32, LayerBinding)],
	) -> Self {
		let mut shape_data = ShapeData {
			shape,
			bind_groups: Vec::new(),
			layer_bind_group_data: None,
			rendering_strategy: InstanceRenderingStrategy::NoInstances,
		};

		shape_data.prepare_value_bindings(painter, layer_bindings);
		shape_data.prepare_layer_bindings(painter, layer_layers);
		shape_data.update_rendering_strategy();

		shape_data
	}

	/// Updates the rendering strategy based on current bind group counts.
	fn update_rendering_strategy(&mut self) {
		let value_count = self.bind_groups.len();
		let layer_count = self
			.layer_bind_group_data
			.as_ref()
			.map(|d| d.data.len())
			.unwrap_or(0);
		self.rendering_strategy = InstanceRenderingStrategy::from_counts(value_count, layer_count);
	}

	/// Prepares value bindings (expensive - creates GPU resources).
	pub(crate) fn prepare_value_bindings(
		&mut self,
		painter: &mut Painter,
		layer_bindings: &[(u32, ValueBinding)],
	) {
		// Extract necessary data from storage
		let sp = &painter.shapes[self.shape.0];
		let shade_idx = sp.shade.0;
		let value_bindings = sp.bindings.clone();
		let instances = sp.instances.clone();

		let sd = &painter.shades[shade_idx];
		let value_bindings_length = sd.value_bindings_length;
		let binding_layout = sd.binding_layout;

		// Create GPU bind groups (expensive operation)
		self.bind_groups = BindGroup::values_bind_groups(
			painter,
			value_bindings_length,
			binding_layout,
			&value_bindings,
			&instances,
			layer_bindings,
		);
	}

	/// Prepares layer bindings (cheap - only descriptors).
	pub(crate) fn prepare_layer_bindings(
		&mut self,
		painter: &Painter,
		layer_layers: &[(u32, LayerBinding)],
	) {
		// Extract necessary data from storage
		let sp = &painter.shapes[self.shape.0];
		let shade_idx = sp.shade.0;
		let shape_layers = sp.layers.as_slice();
		let shape_instances = sp.instances.as_slice();

		let sd = &painter.shades[shade_idx];
		let layer_bindings_length = sd.layer_bindings_length;
		let layers_layout = sd.layers_layout;

		// Create layer bind group data (cheap operation)
		self.layer_bind_group_data = LayerBindGroupData::from_bindings(
			layer_bindings_length,
			layers_layout,
			shape_layers,
			shape_instances,
			layer_layers,
		);
	}
}

/// Encapsulates a single effect and its per-layer binding state.
#[derive(Clone)]
pub(crate) struct EffectData {
	pub effect: Effect,
	pub bind_groups: Vec<BindGroup>,
	pub layer_bind_group_data: Option<LayerBindGroupData>,
	pub rendering_strategy: InstanceRenderingStrategy,
}

impl EffectData {
	/// Creates a new EffectData with bindings prepared using explicit layer data.
	pub(crate) fn new(
		painter: &mut Painter,
		effect: Effect,
		layer_bindings: &[(u32, ValueBinding)],
		layer_layers: &[(u32, LayerBinding)],
	) -> Self {
		let mut effect_data = EffectData {
			effect,
			bind_groups: Vec::new(),
			layer_bind_group_data: None,
			rendering_strategy: InstanceRenderingStrategy::NoInstances,
		};

		effect_data.prepare_value_bindings(painter, layer_bindings);
		effect_data.prepare_layer_bindings(painter, layer_layers);
		effect_data.update_rendering_strategy();

		effect_data
	}

	/// Updates the rendering strategy based on current bind group counts.
	fn update_rendering_strategy(&mut self) {
		let value_count = self.bind_groups.len();
		let layer_count = self
			.layer_bind_group_data
			.as_ref()
			.map(|d| d.data.len())
			.unwrap_or(0);
		self.rendering_strategy = InstanceRenderingStrategy::from_counts(value_count, layer_count);
	}

	/// Prepares value bindings (expensive - creates GPU resources).
	pub(crate) fn prepare_value_bindings(
		&mut self,
		painter: &mut Painter,
		layer_bindings: &[(u32, ValueBinding)],
	) {
		// Extract necessary data from storage
		let ep = &painter.effects[self.effect.0];
		let shade_idx = ep.shade.0;
		let value_bindings = ep.bindings.clone();
		let instances = ep.instances.clone();

		let sd = &painter.shades[shade_idx];
		let value_bindings_length = sd.value_bindings_length;
		let binding_layout = sd.binding_layout;

		// Convert slice to Vec for API compatibility
		let layer_bindings_vec = layer_bindings.to_vec();

		// Create GPU bind groups (expensive operation)
		self.bind_groups = BindGroup::values_bind_groups(
			painter,
			value_bindings_length,
			binding_layout,
			&value_bindings,
			&instances,
			&layer_bindings_vec,
		);
	}

	/// Prepares layer bindings (cheap - only descriptors).
	pub(crate) fn prepare_layer_bindings(
		&mut self,
		painter: &Painter,
		layer_layers: &[(u32, LayerBinding)],
	) {
		// Extract necessary data from storage
		let ep = &painter.effects[self.effect.0];
		let shade_idx = ep.shade.0;
		let effect_layers = ep.layers.clone();
		let effect_instances = ep.instances.as_slice();

		let sd = &painter.shades[shade_idx];
		let layer_bindings_length = sd.layer_bindings_length;
		let layers_layout = sd.layers_layout;

		// Convert slice to Vec for API compatibility
		let layer_layers_vec = layer_layers.to_vec();

		// Create layer bind group data (cheap operation)
		self.layer_bind_group_data = LayerBindGroupData::from_bindings(
			layer_bindings_length,
			layers_layout,
			&effect_layers,
			effect_instances,
			&layer_layers_vec,
		);
	}
}

pub(crate) struct LayerStorage {
	pub shapes: Vec<ShapeData>,
	pub effects: Vec<EffectData>,
	pub target_textures: Vec<Texture>,
	pub depth_texture: Option<Texture>,
	pub width: u32,
	pub height: u32,
	pub use_window_size: bool,
	pub clear_color: Option<wgpu::Color>,
	pub pipeline_key: Vec<u8>,
	pub formats: Vec<wgpu::TextureFormat>,
	pub multisampled_textures: Vec<Texture>,
	pub current_target: usize,
	pub texture_count: usize,
	pub is_multi_target: bool,
	pub bindings: Vec<(u32, ValueBinding)>,
	pub layers: Vec<(u32, LayerBinding)>,
	pub mips: Option<MipMapCount>,
}

impl LayerStorage {
	pub(crate) fn swap_targets(&mut self) {
		let next = (self.current_target + 1) % self.texture_count;
		self.current_target = next;
	}

	pub(crate) fn current_target_texture<'a>(&'a self) -> &'a Texture {
		&self.target_textures[self.current_target]
	}

	pub(crate) fn current_source_texture<'a>(&'a self) -> &'a Texture {
		let mut idx = self.current_target;
		if idx == 0 {
			idx = self.texture_count;
		}

		&self.target_textures[idx - 1]
	}
}

#[derive(Clone, Copy)]
pub struct Layer(pub(crate) usize);

impl Layer {
	pub fn new(painter: &mut Painter, props: LayerProps) -> Self {
		if props.static_texture && props.shapes.len() > 0 {
			panic!("A layer can only either contain a static texture or render shapes, not both")
		}

		let use_window_size = props.width == 0 || props.height == 0;
		let width = if use_window_size {
			painter.config.width
		} else {
			props.width
		};
		let height = if use_window_size {
			painter.config.height
		} else {
			props.height
		};

		let depth_texture = props
			.depth_test
			.then(|| Texture::create_depth(painter, width, height, props.multisampled));

		let pipeline_key = vec![
			vec![(props.depth_test as u8)],
			vec![props.multisampled as u8],
			props.formats.iter().map(|f| map_format_to_u8(*f)).collect(),
		]
		.into_iter()
		.flatten()
		.collect();

		let layer = Layer(painter.layers.len());

		let swapping_effect_count = props
			.effects
			.iter()
			.filter(|e| !e.has_mip_target(painter) && !e.has_mip_source(painter))
			.count();

		let use_swap_targets = swapping_effect_count > 1
			|| ((props.shapes.len() > 0 || props.static_texture) && swapping_effect_count > 0);

		let format_len = props.formats.len();
		let is_multi_target = format_len > 1;

		let texture_count = if is_multi_target {
			format_len
		} else {
			if use_swap_targets { 2 } else { 1 }
		};

		let mut target_textures = Vec::with_capacity(texture_count);
		let mut multisampled_textures =
			Vec::with_capacity(if props.multisampled { texture_count } else { 0 });
		let mut formats = Vec::with_capacity(texture_count);

		let mut usage =
			wgpu::TextureUsages::RENDER_ATTACHMENT | wgpu::TextureUsages::TEXTURE_BINDING;
		if props.static_texture {
			usage |= wgpu::TextureUsages::COPY_DST;
		}

		if is_multi_target {
			if use_swap_targets {
				panic!(
					"Postprocessing is not supported with multiple targets. Only sketches or one effect can be used."
				);
			}

			for format in props.formats {
				let tex = Texture::create_2d(
					painter,
					width,
					height,
					Texture2DProps {
						format,
						usage,
						mips: props.mips,
					},
					false,
				);
				target_textures.push(tex);

				if props.multisampled {
					multisampled_textures.push(Texture::create_2d(
						painter,
						width,
						height,
						Texture2DProps {
							format,
							usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
							mips: None,
						},
						true,
					));
				}

				formats.push(format);
			}
		} else {
			let format = *props.formats.get(0).unwrap_or(&painter.config.format);

			for _ in 0..texture_count {
				let tex = Texture::create_2d(
					painter,
					width,
					height,
					Texture2DProps {
						format,
						usage,
						mips: props.mips,
					},
					false,
				);

				target_textures.push(tex);
			}

			if props.multisampled {
				multisampled_textures.push(Texture::create_2d(
					painter,
					width,
					height,
					Texture2DProps {
						format,
						usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
						mips: None,
					},
					true,
				));
			}

			formats.push(format);
		}

		let shape_data: Vec<ShapeData> = props
			.shapes
			.into_iter()
			.map(|shape| ShapeData::new(painter, shape, &props.bindings, &props.layers))
			.collect();

		let effect_data: Vec<EffectData> = props
			.effects
			.iter()
			.map(|effect| EffectData::new(painter, *effect, &props.bindings, &props.layers))
			.collect();

		let storage = LayerStorage {
			shapes: shape_data,
			effects: effect_data,
			width,
			height,
			target_textures,
			depth_texture,
			multisampled_textures,
			use_window_size,
			clear_color: props.clear_color,
			formats,
			pipeline_key,
			current_target: 0,
			texture_count,
			is_multi_target,
			bindings: props.bindings,
			layers: props.layers,
			mips: props.mips,
		};

		painter.layers.push(storage);

		if props.effects.iter().any(|e| e.has_mip_target(painter)) {
			let textures = painter.layers[layer.0].target_textures.clone();
			for t in textures {
				t.prepare_mip_level_views(painter);
			}
		}

		if let Some(data) = props.static_texture_data {
			layer.update_static_data(painter, data);
		}

		layer
	}

	/// This function is called by after the CanvasApp::init function automatically.
	///
	/// If Layers are created dynamically during App runtime,
	/// or if they need to be rendered directly inside CanvasApp::init,
	/// this method must to be called manually after all shaders are loaded.
	///
	/// Alternatively, LayerBuilder::create_and_init can be used to create and initialize.
	/// Or Painter::init_and_paint can be used to initialize and paint in one call.
	pub fn init_gpu_pipelines(&self, painter: &mut Painter) {
		let shapes: Vec<Shape> = painter.layers[self.0]
			.shapes
			.iter()
			.map(|sd| sd.shape)
			.collect();

		let effects: Vec<Effect> = painter.layers[self.0]
			.effects
			.iter()
			.map(|ed| ed.effect)
			.collect();

		for s in shapes {
			let key = painter.get_shape_pipeline_key(s, *self);
			painter.ensure_shape_pipeline(&key, s, *self);
		}

		for e in effects {
			let key = painter.get_effect_pipeline_key(e, *self);
			painter.ensure_effect_pipeline(&key, e, *self);
		}
	}

	pub fn update_static_data(&self, painter: &Painter, data: &[u8]) {
		painter.layers[self.0]
			.current_source_texture()
			.fill_2d(painter, data);
	}

	pub fn binding(&self) -> LayerBinding {
		LayerBinding::Source(*self)
	}

	pub fn binding_at_mip_level(&self, mip_level: u32) -> LayerBinding {
		LayerBinding::SourceAtMipLevel(*self, mip_level)
	}

	pub fn depth_binding(&self) -> LayerBinding {
		LayerBinding::Depth(*self)
	}

	pub fn binding_at(&self, index: usize) -> LayerBinding {
		LayerBinding::AtIndex(*self, index)
	}

	pub fn set_clear_color(&mut self, painter: &mut Painter, color: Option<wgpu::Color>) {
		painter.layers[self.0].clear_color = color;
	}

	/// Updates all layer-level bindings at once.
	///
	/// Layer-level bindings serve as defaults for all shapes and effects in this layer.
	/// These bindings are merged with shape/effect-specific bindings during rendering,
	/// with shape/effect bindings taking precedence.
	///
	/// This method automatically re-prepares all shapes and effects in the layer
	/// to reflect the new bindings.
	///
	/// # Arguments
	/// * `painter` - The painter instance
	/// * `layers` - Vector of (slot_index, LayerBinding) pairs
	///
	pub fn set_layer_bindings(&self, painter: &mut Painter, layers: Vec<(u32, LayerBinding)>) {
		painter.layers[self.0].layers = layers.clone();

		// Clone the shapes and effects to avoid borrow conflicts
		let mut shapes = painter.layers[self.0].shapes.clone();
		let mut effects = painter.layers[self.0].effects.clone();

		// Update ONLY layer bindings (cheap operation - no GPU resource regeneration)
		for sd in &mut shapes {
			sd.prepare_layer_bindings(painter, &layers);
		}

		// Update ONLY layer bindings for effects
		for ed in &mut effects {
			ed.prepare_layer_bindings(painter, &layers);
		}

		// Write back
		painter.layers[self.0].shapes = shapes;
		painter.layers[self.0].effects = effects;
	}

	/// Updates a single layer-level binding by slot index.
	///
	/// This is a convenience method for updating just one binding without
	/// replacing the entire bindings vector. If the slot doesn't exist,
	/// it will be added. If it exists, it will be updated.
	///
	/// # Arguments
	/// * `painter` - The painter instance
	/// * `slot` - The binding slot index
	/// * `binding` - The new LayerBinding for this slot
	///
	pub fn set_layer_binding(&self, painter: &mut Painter, slot: u32, binding: LayerBinding) {
		let mut layers = painter.layers[self.0].layers.clone();

		// Find and update or insert
		if let Some(pos) = layers.iter().position(|(i, _)| *i == slot) {
			layers[pos].1 = binding;
		} else {
			layers.push((slot, binding));
			layers.sort_by_key(|(s, _)| *s);
		}

		self.set_layer_bindings(painter, layers);
	}

	/// Replaces all shapes in the layer with a new list of shapes.
	///
	/// This is useful for dynamically changing which shapes are rendered in a layer at runtime.
	/// The method will prepare bindings for the new shapes and ensure their GPU pipelines exist.
	/// Pipelines are cached and reused, so adding shapes that share configurations with existing
	/// shapes is efficient.
	///
	pub fn set_shapes(&self, painter: &mut Painter, shapes: Vec<Shape>) {
		let layer_bindings = painter.layers[self.0].bindings.clone();
		let layer_layers = painter.layers[self.0].layers.clone();

		painter.layers[self.0].shapes = shapes
			.iter()
			.map(|&shape| ShapeData::new(painter, shape, &layer_bindings, &layer_layers))
			.collect();

		// Ensure pipelines exist for all shapes (will reuse cached if available)
		for shape in shapes {
			let key = painter.get_shape_pipeline_key(shape, *self);
			painter.ensure_shape_pipeline(&key, shape, *self);
		}
	}

	/// Adds a single shape to the layer.
	///
	/// This is a convenience method for appending a shape to the existing shapes vector.
	/// If you need to replace all shapes or add multiple shapes at once, use `set_shapes()` instead.
	///
	pub fn add_shape(&self, painter: &mut Painter, shape: Shape) {
		let layer_bindings = painter.layers[self.0].bindings.clone();
		let layer_layers = painter.layers[self.0].layers.clone();

		let shape_data = ShapeData::new(painter, shape, &layer_bindings, &layer_layers);
		painter.layers[self.0].shapes.push(shape_data);

		// Ensure pipeline exists for this shape
		let key = painter.get_shape_pipeline_key(shape, *self);
		painter.ensure_shape_pipeline(&key, shape, *self);
	}

	/// Removes a specific shape from the layer.
	///
	/// This filters out all occurrences of the given shape from the layer's shape list.
	/// If the shape appears multiple times, all instances will be removed.
	///
	pub fn remove_shape(&self, painter: &mut Painter, shape: Shape) {
		painter.layers[self.0]
			.shapes
			.retain(|sd| sd.shape.0 != shape.0);
	}

	pub fn resize(&mut self, painter: &mut Painter, width: u32, height: u32) {
		let use_window_size = width == 0 || height == 0;
		let width = if use_window_size {
			painter.config.width
		} else {
			width
		};
		let height = if use_window_size {
			painter.config.height
		} else {
			height
		};

		let storage = &mut painter.layers[self.0];
		if storage.width == width && storage.height == height {
			return;
		}

		storage.width = width;
		storage.height = height;
		storage.use_window_size = use_window_size;

		let targets = storage.target_textures.clone();
		let depth_texture = storage.depth_texture.clone();
		let multisampled_textures = storage.multisampled_textures.clone();
		let mips = storage.mips;

		for texture in targets.iter() {
			let format = painter.textures[texture.0].texture.format();
			texture.replace_2d(
				painter,
				width,
				height,
				Texture2DProps {
					format,
					usage: wgpu::TextureUsages::RENDER_ATTACHMENT
						| wgpu::TextureUsages::TEXTURE_BINDING,
					mips,
				},
				false,
			);
		}

		if let Some(depth_texture) = depth_texture {
			depth_texture.replace_depth(painter, width, height, !multisampled_textures.is_empty());
		}

		for t in multisampled_textures {
			let format = painter.textures[t.0].texture.format();
			t.replace_2d(
				painter,
				width,
				height,
				Texture2DProps {
					format,
					usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
					mips: None,
				},
				true,
			);
		}

		let prepare_effect_mips = painter.layers[self.0]
			.effects
			.iter()
			.any(|ed| ed.effect.has_mip_target(painter));

		if prepare_effect_mips {
			let textures = painter.layers[self.0].target_textures.clone();
			for t in textures {
				t.prepare_mip_level_views(painter);
			}
		}
	}

	pub fn get_mip_levels_count(&self, painter: &Painter) -> u32 {
		let storage = &painter.layers[self.0];
		storage.target_textures[0].get_mip_level_count(painter)
	}
}

/// A builder for creating a new [`Layer`].
///
/// # Default Configuration values:
/// - `sampler`: Nearest / ClampToEdge
/// - `layer_layout`: BINDING_LAYER_FRAG
/// - `clear_color`: None
/// - `depth_test`: false
/// - `multisampled`: false
///
/// # Example
/// ```
/// let layer = LayerBuilder::new(painter)
///     .with_size(800, 600)
///     .with_shape(rectangle)
///     .with_clear_color(wgpu::Color::BLACK)
///     .create();
/// ```
///
pub struct LayerBuilder<'a, 'b> {
	props: LayerProps<'b>,
	painter: &'a mut Painter,
}

impl<'a, 'b> LayerBuilder<'a, 'b> {
	pub fn new(painter: &'a mut Painter) -> Self {
		LayerBuilder {
			props: LayerProps::default(),
			painter,
		}
	}

	pub fn create(self) -> Layer {
		Layer::new(self.painter, self.props)
	}

	/// Creates a layer and initializes the its gpu pipelines.
	///
	/// Layers created in the App::init function are automatically initialized.
	/// They can use `create` method to create the layer.
	///
	/// Layers created during runtime must be initialized manually.
	/// Alternatively, use Painter::init_and_paint method to initialize and paint in one call.
	pub fn create_and_init(self) -> Layer {
		let layer = Layer::new(self.painter, self.props);
		layer.init_gpu_pipelines(self.painter);
		layer
	}

	/// Creates a layer, initializes the its gpu pipelines and immediately renders it.
	pub fn create_and_paint(self) -> Layer {
		let layer = Layer::new(self.painter, self.props);
		layer.init_gpu_pipelines(self.painter);
		self.painter.paint(layer);
		layer
	}

	pub fn with_static_texture(mut self) -> Self {
		self.props.static_texture = true;
		self
	}

	pub fn with_static_texture_data(mut self, data: &'b [u8]) -> Self {
		self.props.static_texture = true;
		self.props.static_texture_data = Some(data);
		self
	}

	pub fn with_shapes<I>(mut self, shapes: I) -> Self
	where
		I: IntoIterator<Item = Shape>,
	{
		self.props.shapes = shapes.into_iter().collect();
		self
	}

	pub fn with_shape(mut self, shape: Shape) -> Self {
		self.props.shapes.push(shape);
		self
	}

	pub fn with_effects<I>(mut self, effects: I) -> Self
	where
		I: IntoIterator<Item = Effect>,
	{
		self.props.effects = effects.into_iter().collect();
		self
	}

	pub fn with_effect(mut self, effect: Effect) -> Self {
		self.props.effects.push(effect);
		self
	}

	pub fn with_bindings<I>(mut self, bindings: I) -> Self
	where
		I: IntoIterator<Item = (u32, ValueBinding)>,
	{
		self.props.bindings = bindings.into_iter().collect();
		self
	}

	pub fn with_layers<I>(mut self, layers: I) -> Self
	where
		I: IntoIterator<Item = (u32, LayerBinding)>,
	{
		self.props.layers = layers.into_iter().collect();
		self
	}

	pub fn with_size(mut self, width: u32, height: u32) -> Self {
		self.props.width = width;
		self.props.height = height;
		self
	}

	pub fn with_formats<I>(mut self, formats: I) -> Self
	where
		I: IntoIterator<Item = wgpu::TextureFormat>,
	{
		self.props.formats = formats.into_iter().collect();
		self
	}

	pub fn with_format(mut self, format: wgpu::TextureFormat) -> Self {
		self.props.formats = vec![format];
		self
	}

	pub fn with_clear_color(mut self, color: wgpu::Color) -> Self {
		self.props.clear_color = Some(color);
		self
	}

	pub fn with_depth_test(mut self) -> Self {
		self.props.depth_test = true;
		self
	}

	pub fn with_layer_layout_vert(mut self) -> Self {
		self.props.layer_layout = BINDING_LAYER_VERT;
		self
	}

	pub fn with_layer_layout_both(mut self) -> Self {
		self.props.layer_layout = BINDING_LAYER_BOTH;
		self
	}

	pub fn with_multisampling(mut self) -> Self {
		self.props.multisampled = true;
		self
	}

	pub fn with_mips(mut self) -> Self {
		self.props.mips = Some(MipMapCount::Full);
		self
	}

	pub fn with_mips_max(mut self, max: u32) -> Self {
		self.props.mips = Some(MipMapCount::Max(max));
		self
	}
}

/// A builder for creating a new [`Layer`] with a single [`Effect`].
///
/// This builder merges the functionality of [`LayerBuilder`] and [`EffectBuilder`]
/// for the common case of creating a layer with exactly one effect.
///
/// # Default Configuration values:
/// - `blend_state`: wgpu::BlendState::REPLACE
/// - `clear_color`: None
///
/// # Example
/// ```
/// let layer = SingleEffectBuilder::new(painter, shade)
///     .with_size(800, 600)
///     .with_bindings(vec![(0, some_binding)])
///     .with_clear_color(wgpu::Color::BLACK)
///     .create();
/// ```
///
pub struct SingleEffectLayerBuilder<'a> {
	painter: &'a mut Painter,
	shade: Shade,

	// Effect properties
	effect_bindings: Vec<(u32, ValueBinding)>,
	effect_layers: Vec<(u32, LayerBinding)>,
	effect_instances: Vec<InstanceBinding>,
	blend_state: wgpu::BlendState,
	dst_mip_level: Option<u32>,
	src_mip_level: Option<u32>,

	// Layer properties
	width: u32,
	height: u32,
	format: Option<wgpu::TextureFormat>,
	clear_color: Option<wgpu::Color>,
	mips: Option<MipMapCount>,
}

impl<'a> SingleEffectLayerBuilder<'a> {
	pub fn new(painter: &'a mut Painter, shade: Shade) -> Self {
		SingleEffectLayerBuilder {
			painter,
			shade,
			effect_bindings: Vec::with_capacity(0),
			effect_layers: Vec::with_capacity(0),
			effect_instances: Vec::with_capacity(0),
			blend_state: wgpu::BlendState::REPLACE,
			dst_mip_level: None,
			src_mip_level: None,
			width: 0,
			height: 0,
			format: None,
			clear_color: None,
			mips: None,
		}
	}

	pub fn create(self) -> Layer {
		let (painter, props) = self.into_layer_props();
		Layer::new(painter, props)
	}

	/// Creates a layer and immediately initializes its GPU pipelines.
	///
	/// Layers created during app initialization are initialized automatically,
	/// so they can use `create`. Runtime-created layers must either call
	/// `Layer::init_gpu_pipelines` manually or use this helper instead.
	pub fn create_and_init(self) -> Layer {
		let (painter, props) = self.into_layer_props();
		let layer = Layer::new(painter, props);
		layer.init_gpu_pipelines(painter);
		layer
	}

	// Effect builder methods

	pub fn with_bindings<I>(mut self, bindings: I) -> Self
	where
		I: IntoIterator<Item = (u32, ValueBinding)>,
	{
		self.effect_bindings = bindings.into_iter().collect();
		self
	}

	pub fn with_layers<I>(mut self, layers: I) -> Self
	where
		I: IntoIterator<Item = (u32, LayerBinding)>,
	{
		self.effect_layers = layers.into_iter().collect();
		self
	}

	/// Repeatedly render this effect multiple times with different bindings into the same target without target swapping.
	/// This is useful for example for deferred lighting, where each light is rendered with custom blend state on top of the last.
	pub fn with_instances(mut self, instances: Vec<InstanceBinding>) -> Self {
		self.effect_instances = instances;
		self
	}

	pub fn with_blend_state(mut self, blend_state: wgpu::BlendState) -> Self {
		self.blend_state = blend_state;
		self
	}

	pub fn with_mip_target(mut self, dst_mip_level: u32) -> Self {
		self.dst_mip_level = Some(dst_mip_level);
		self
	}

	pub fn with_mip_source(mut self, src_mip_level: u32) -> Self {
		self.src_mip_level = Some(src_mip_level);
		self
	}

	// Layer builder methods

	pub fn with_size(mut self, width: u32, height: u32) -> Self {
		self.width = width;
		self.height = height;
		self
	}

	pub fn with_format(mut self, format: wgpu::TextureFormat) -> Self {
		self.format = Some(format);
		self
	}

	pub fn with_clear_color(mut self, color: wgpu::Color) -> Self {
		self.clear_color = Some(color);
		self
	}

	pub fn with_mips(mut self) -> Self {
		self.mips = Some(MipMapCount::Full);
		self
	}

	pub fn with_mips_max(mut self, max: u32) -> Self {
		self.mips = Some(MipMapCount::Max(max));
		self
	}

	fn into_layer_props(self) -> (&'a mut Painter, LayerProps<'a>) {
		let SingleEffectLayerBuilder {
			painter,
			shade,
			effect_bindings,
			effect_layers,
			effect_instances,
			blend_state,
			dst_mip_level,
			src_mip_level,
			width,
			height,
			format,
			clear_color,
			mips,
		} = self;

		let effect = Effect::new(
			painter,
			shade,
			crate::effect::EffectProps {
				bindings: Vec::with_capacity(0),
				layers: Vec::with_capacity(0),
				instances: effect_instances,
				blend_state,
				dst_mip_level,
				src_mip_level,
			},
		);

		let mut formats = Vec::with_capacity(1);
		if let Some(format) = format {
			formats.push(format);
		}

		(
			painter,
			LayerProps {
				static_texture: false,
				static_texture_data: None,
				shapes: Vec::with_capacity(0),
				effects: vec![effect],
				bindings: effect_bindings,
				layers: effect_layers,
				width,
				height,
				formats,
				clear_color,
				depth_test: false,
				layer_layout: BINDING_LAYER_FRAG,
				multisampled: false,
				mips,
			},
		)
	}
}
</file>

<file path="src/lib.rs">
pub use wgpu;
pub use winit;

pub mod painter;
pub use painter::Painter;
pub mod app;
pub mod bind_group;
pub mod binding;
pub mod binding_constants;
pub mod effect;
pub mod events;
pub mod form;
pub mod layer;
pub(crate) mod pipeline;
pub mod sampler;
pub mod shade;
pub mod shaders;
pub mod shape;
pub mod texture;
pub mod texture_utils;
pub mod utils;
pub(crate) mod window_dimensions;

pub mod prelude {
	pub use crate::{
		app::{AppConfig, CanvasApp, Event, KeyCode, PointerButton},
		binding::{BindingBuffer, InstanceBinding, Mat3U, Vec3U},
		binding_constants::*,
		effect::EffectProps,
		form::FormProps,
		layer::{Layer, LayerProps},
		load_fragment_shader, load_vertex_shader,
		painter::Painter,
		sampler::{Sampler, SamplerProps},
		shade::{Shade, ShadeEffectProps, ShadeProps},
		shape::{Shape, ShapeProps},
		wgpu::{self, TextureFormat::*, VertexFormat::*},
	};
}
</file>

<file path="src/painter.rs">
use crate::{
	bind_group::{BindGroup, BindGroupLayout, BindGroupStorage, LayerBindGroupData},
	binding::{BindingBuffer, LayerBinding, Mat3U, ValueBinding, Vec3U},
	effect::{Effect, EffectBuilder, EffectStorage},
	form::{Form, FormBuffer, FormBuilder, FormStorage},
	layer::{
		InstanceRenderingStrategy, Layer, LayerBuilder, LayerStorage, SingleEffectLayerBuilder,
	},
	pipeline::PipelineStorage,
	prelude::{BINDING_LAYER_FRAG, BINDING_SAMPLER_FRAG},
	sampler::{Sampler, SamplerBuilder, SamplerProps},
	shade::{AttribsFormat, Shade, ShadeBuilder, ShadeEffectBuilder, ShadeStorage},
	shaders::FULL_SCREEN_QUAD,
	shape::{Shape, ShapeBuilder, ShapeStorage},
	texture::{TexViewKey, TextureStorage},
};
use std::{collections::BTreeMap, sync::Arc};
use trivalibs_core::{
	glam::{Mat3, Mat3A, Mat4, Quat, UVec2, Vec2, Vec3, Vec3A, Vec4},
	utils::default,
};
use wgpu::RenderPassColorAttachment;
use winit::window::Window;

pub(crate) const FULL_SCREEN_TEXTURE_PIPELINE: &'static [u8] = &[0xff, 0xff];

pub struct Painter {
	pub surface: wgpu::Surface<'static>,
	pub config: wgpu::SurfaceConfiguration,
	pub adapter: wgpu::Adapter,
	pub device: wgpu::Device,
	pub queue: wgpu::Queue,

	pub surface_error: Option<wgpu::SurfaceError>,

	window: Arc<Window>,
	pub(crate) forms: Vec<FormStorage>,
	pub(crate) shades: Vec<ShadeStorage>,
	pub(crate) textures: Vec<TextureStorage>,
	pub(crate) buffers: Vec<wgpu::Buffer>,
	pub(crate) samplers: Vec<wgpu::Sampler>,
	pub(crate) shapes: Vec<ShapeStorage>,
	pub(crate) effects: Vec<EffectStorage>,
	pub(crate) layers: Vec<LayerStorage>,
	pub(crate) bind_groups: Vec<BindGroupStorage>,
	pub(crate) bind_group_layouts: Vec<wgpu::BindGroupLayout>,
	pub(crate) pipelines: BTreeMap<Vec<u8>, PipelineStorage>,
	pub(crate) fullscreen_quad_shader: wgpu::ShaderModule,
}

pub(crate) struct PainterConfig {
	pub use_vsync: bool,
	pub features: Option<wgpu::Features>,
}

impl Painter {
	pub(crate) async fn new(window: Arc<Window>, painter_config: PainterConfig) -> Self {
		let mut size = window.inner_size();
		size.width = size.width.max(1);
		size.height = size.height.max(1);

		let instance = wgpu::Instance::default();

		let surface = instance.create_surface(window.clone()).unwrap();
		let adapter = instance
			.request_adapter(&wgpu::RequestAdapterOptions {
				power_preference: wgpu::PowerPreference::default(),
				force_fallback_adapter: false,
				// Request an adapter which can render to our surface
				compatible_surface: Some(&surface),
			})
			.await
			.expect("Failed to find an appropriate adapter");

		// Create the logical device and command queue
		let (device, queue) = adapter
			.request_device(&wgpu::DeviceDescriptor {
				label: None,
				required_features: painter_config.features.unwrap_or(wgpu::Features::empty()),
				// Make sure we use the texture resolution limits from the adapter, so we can support images the size of the swapchain.
				required_limits: wgpu::Limits::downlevel_webgl2_defaults()
					.using_resolution(adapter.limits()),
				memory_hints: wgpu::MemoryHints::MemoryUsage,
				trace: wgpu::Trace::Off,
			})
			.await
			.expect("Failed to create device");

		let surface_caps = surface.get_capabilities(&adapter);
		let config = wgpu::SurfaceConfiguration {
			usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
			format: surface_caps.formats[0],
			width: size.width,
			height: size.height,
			present_mode: if painter_config.use_vsync {
				wgpu::PresentMode::AutoVsync
			} else {
				wgpu::PresentMode::AutoNoVsync
			},
			alpha_mode: surface_caps.alpha_modes[0],
			view_formats: vec![],
			desired_maximum_frame_latency: 2,
		};

		surface.configure(&device, &config);

		let fullscreen_quad_shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
			label: Some("Fullscreen Quad Shader"),
			source: wgpu::ShaderSource::Wgsl(std::borrow::Cow::Borrowed(FULL_SCREEN_QUAD)),
		});

		let mut painter = Self {
			surface,
			config,
			adapter,
			device,
			queue,
			surface_error: None,
			window: window.clone(),
			forms: Vec::with_capacity(8),
			shades: Vec::with_capacity(8),
			textures: Vec::with_capacity(8),
			buffers: Vec::with_capacity(32),
			samplers: Vec::with_capacity(8),
			shapes: Vec::with_capacity(8),
			effects: Vec::with_capacity(8),
			layers: Vec::with_capacity(8),
			bind_group_layouts: Vec::with_capacity(8),
			bind_groups: Vec::with_capacity(8),
			pipelines: BTreeMap::new(),
			fullscreen_quad_shader,
		};

		Sampler::create(&mut painter, SamplerProps::NEAREST);
		Sampler::create(&mut painter, SamplerProps::LINEAR);

		let layer_sampler_layout =
			BindGroupLayout::values(&mut painter, &[BINDING_SAMPLER_FRAG]).unwrap();
		let layer_texture_layout =
			BindGroupLayout::layers(&mut painter, &[BINDING_LAYER_FRAG]).unwrap();

		BindGroup::values_bind_groups(
			&mut painter,
			1,
			Some(layer_sampler_layout),
			&Vec::with_capacity(0),
			&Vec::with_capacity(0),
			&vec![(0, Sampler(0).binding())],
		);

		BindGroup::values_bind_groups(
			&mut painter,
			1,
			Some(layer_sampler_layout),
			&Vec::with_capacity(0),
			&Vec::with_capacity(0),
			&vec![(0, Sampler(1).binding())],
		);

		let fullscreen_quad_pipeline_layout =
			painter
				.device
				.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
					label: None,
					bind_group_layouts: &[
						&painter.bind_group_layouts[layer_sampler_layout.0],
						&painter.bind_group_layouts[layer_texture_layout.0],
					],
					push_constant_ranges: &[],
				});

		let fullscreen_quad_pipeline =
			painter
				.device
				.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
					label: None,
					layout: Some(&fullscreen_quad_pipeline_layout),
					vertex: wgpu::VertexState {
						module: &painter.fullscreen_quad_shader,
						entry_point: Some("vs_main"),
						buffers: &[],
						compilation_options: default(),
					},
					fragment: Some(wgpu::FragmentState {
						module: &painter.fullscreen_quad_shader,
						entry_point: Some("fs_main"),
						targets: &[Some(wgpu::ColorTargetState {
							format: painter.config.format,
							blend: Some(wgpu::BlendState::REPLACE),
							write_mask: wgpu::ColorWrites::ALL,
						})],
						compilation_options: default(),
					}),
					primitive: wgpu::PrimitiveState {
						topology: wgpu::PrimitiveTopology::TriangleStrip,
						strip_index_format: None,
						front_face: wgpu::FrontFace::Cw,
						cull_mode: None,
						polygon_mode: wgpu::PolygonMode::Fill,
						..default()
					},
					depth_stencil: None,
					multisample: wgpu::MultisampleState {
						count: 1,
						mask: !0,
						alpha_to_coverage_enabled: false,
					},
					multiview: None,
					cache: None,
				});

		painter.pipelines.insert(
			FULL_SCREEN_TEXTURE_PIPELINE.to_vec(),
			PipelineStorage {
				pipeline: fullscreen_quad_pipeline,
				layer: None,
				shape: None,
				effect: None,
			},
		);

		painter
	}

	pub fn window(&self) -> &Arc<Window> {
		&self.window
	}

	// form helpers

	pub fn form<'a>(&mut self, buffer: impl Into<FormBuffer<'a>>) -> FormBuilder<'_, 'a> {
		FormBuilder::new(self).with_buffer(buffer)
	}

	pub fn form_builder(&mut self) -> FormBuilder<'_, '_> {
		FormBuilder::new(self)
	}

	pub fn form_update<'a>(&mut self, form: Form, buffer: impl Into<FormBuffer<'a>>) {
		form.update(self, buffer);
	}

	// shade helpers

	pub fn shade<Format: Into<AttribsFormat>>(
		&mut self,
		attributes: Format,
	) -> ShadeBuilder<'_, Format> {
		ShadeBuilder::new(self, attributes)
	}

	pub fn shade_effect(&mut self) -> ShadeEffectBuilder<'_> {
		ShadeEffectBuilder::new(self)
	}

	// texture helpers

	pub fn sampler(&mut self) -> SamplerBuilder<'_> {
		SamplerBuilder::new(self)
	}

	pub fn sampler_nearest(&self) -> Sampler {
		Sampler(0)
	}

	pub fn sampler_linear(&self) -> Sampler {
		Sampler(1)
	}

	// shape utils

	pub fn shape(&mut self, form: Form, shade: Shade) -> ShapeBuilder<'_> {
		ShapeBuilder::new(self, form, shade)
	}

	pub fn effect(&mut self, shade: Shade) -> EffectBuilder<'_> {
		EffectBuilder::new(self, shade)
	}

	// layer utils

	pub fn layer<'b>(&mut self) -> LayerBuilder<'_, 'b> {
		LayerBuilder::new(self)
	}

	pub fn single_effect_layer(&mut self, shade: Shade) -> SingleEffectLayerBuilder<'_> {
		SingleEffectLayerBuilder::new(self, shade)
	}

	// binding utils

	pub fn bind_buff<T: bytemuck::Pod>(&mut self, data: T) -> BindingBuffer<T> {
		BindingBuffer::new(self, data)
	}
	pub fn bind_mat3(&mut self) -> BindingBuffer<Mat3U> {
		self.bind_buff(Mat3U(Mat3A::IDENTITY))
	}
	pub fn bind_mat4(&mut self) -> BindingBuffer<Mat4> {
		self.bind_buff(Mat4::IDENTITY)
	}
	pub fn bind_vec2(&mut self) -> BindingBuffer<Vec2> {
		self.bind_buff(Vec2::ZERO)
	}
	pub fn bind_vec3(&mut self) -> BindingBuffer<Vec3U> {
		self.bind_buff(Vec3U(Vec3A::ZERO))
	}
	pub fn bind_vec4(&mut self) -> BindingBuffer<Vec4> {
		self.bind_buff(Vec4::ZERO)
	}
	pub fn bind_uvec2(&mut self) -> BindingBuffer<UVec2> {
		self.bind_buff(UVec2::ZERO)
	}
	pub fn bind_f32(&mut self) -> BindingBuffer<f32> {
		self.bind_buff(0.0f32)
	}
	pub fn bind_u32(&mut self) -> BindingBuffer<u32> {
		self.bind_buff(0u32)
	}
	pub fn bind_quat(&mut self) -> BindingBuffer<Quat> {
		self.bind_buff(Quat::IDENTITY)
	}

	pub fn bind_const_buff<T: bytemuck::Pod>(&mut self, data: T) -> ValueBinding {
		self.bind_buff(data).binding()
	}
	pub fn bind_const_mat3(&mut self, mat: Mat3) -> ValueBinding {
		let u = self.bind_mat3();
		u.update_mat3(self, mat);
		u.binding()
	}
	pub fn bind_const_mat4(&mut self, mat: Mat4) -> ValueBinding {
		self.bind_const_buff(mat)
	}
	pub fn bind_const_vec2(&mut self, vec: Vec2) -> ValueBinding {
		self.bind_const_buff(vec)
	}
	pub fn bind_const_vec3(&mut self, vec: Vec3) -> ValueBinding {
		let u = self.bind_vec3();
		u.update_vec3(self, vec);
		u.binding()
	}
	pub fn bind_const_vec4(&mut self, vec: Vec4) -> ValueBinding {
		self.bind_const_buff(vec)
	}
	pub fn bind_const_uvec2(&mut self, vec: UVec2) -> ValueBinding {
		self.bind_const_buff(vec)
	}
	pub fn bind_const_f32(&mut self, f: f32) -> ValueBinding {
		self.bind_const_buff(f)
	}
	pub fn bind_const_u32(&mut self, u: u32) -> ValueBinding {
		self.bind_const_buff(u)
	}
	pub fn bind_const_quat(&mut self, quat: Quat) -> ValueBinding {
		self.bind_const_buff(quat)
	}

	// general utils

	pub fn request_next_frame(&self) {
		self.window.request_redraw();
	}

	pub fn resize(&mut self, new_size: winit::dpi::PhysicalSize<u32>) {
		self.config.width = new_size.width.max(1);
		self.config.height = new_size.height.max(1);
		self.surface.configure(&self.device, &self.config);

		let layer_idxs: Vec<usize> = self
			.layers
			.iter()
			.enumerate()
			.filter_map(|(i, l)| if l.use_window_size { Some(i) } else { None })
			.collect();

		for idx in layer_idxs {
			Layer(idx).resize(self, 0, 0);
		}
	}

	pub fn canvas_size(&self) -> winit::dpi::PhysicalSize<u32> {
		self.window.inner_size()
	}

	pub(crate) fn get_shape_pipeline_key(&self, shape: Shape, layer: Layer) -> Vec<u8> {
		let l = &self.layers[layer.0];
		let sp = &self.shapes[shape.0];
		[sp.pipeline_key.as_slice(), l.pipeline_key.as_slice()].concat()
	}

	pub(crate) fn ensure_shape_pipeline<'a>(
		&'a mut self,
		pipeline_key: &Vec<u8>,
		shape: Shape,
		layer: Layer,
	) {
		if !self.pipelines.contains_key(pipeline_key) {
			let pipeline = PipelineStorage::create_shape_pipeline(self, shape, layer);
			self.pipelines.insert(pipeline_key.clone(), pipeline);
		}
	}

	pub(crate) fn get_effect_pipeline_key(&self, effect: Effect, layer: Layer) -> Vec<u8> {
		let layer_key = self.layers[layer.0].pipeline_key.as_slice();
		let effect_key = self.effects[effect.0].pipeline_key.as_slice();
		[effect_key, layer_key].concat()
	}

	pub(crate) fn ensure_effect_pipeline<'a>(
		&mut self,
		pipeline_key: &Vec<u8>,
		effect: Effect,
		layer: Layer,
	) {
		if !self.pipelines.contains_key(pipeline_key) {
			let pipeline = PipelineStorage::create_effect_pipeline(self, effect, layer);
			self.pipelines.insert(pipeline_key.to_vec(), pipeline);
		}
	}

	/// Renders a shape with optimized instance handling.
	///
	/// # Instance Rendering Rules
	/// Based on the lengths of bind_groups (value bindings) and layer_bind_group_data (layer bindings):
	///
	/// 1. **No instances** (both  1): Set bindings once, single draw call
	/// 2. **Only value bindings vary** (values > 1, layers  1):
	///    Set layer bindings once, iterate through value bindings
	/// 3. **Only layer bindings vary** (layers > 1, values  1):
	///    Set value bindings once, iterate through layer bindings
	/// 4. **Both vary** (both > 1):
	///    Iterate through all instances, setting both bind groups per draw
	///
	/// This respects the override hierarchy: Layer  Shape  Instance
	fn render_shape(&self, pass: &mut wgpu::RenderPass<'_>, shape_index: usize, layer: Layer) {
		let shape_data = &self.layers[layer.0].shapes[shape_index];
		let shape = shape_data.shape;
		let s = &self.shapes[shape.0];
		let f = &self.forms[s.form.0];

		let draw = |pass: &mut wgpu::RenderPass, binding: Option<BindGroup>| {
			if let Some(binding) = binding {
				pass.set_bind_group(0, &self.bind_groups[binding.0].bind_group, &[]);
			}

			for i in 0..f.currently_active_buffers {
				let b = &f.buffers[i];
				pass.set_vertex_buffer(0, b.vertex_buffer.slice(..b.vertex_buffer_current_size));
				if let Some(index_buffer) = &b.index_buffer
					&& b.index_count > 0
				{
					pass.set_index_buffer(
						index_buffer.slice(..b.index_buffer_current_size),
						wgpu::IndexFormat::Uint32,
					);
					pass.draw_indexed(0..b.index_count, 0, 0..1);
				} else {
					pass.draw(0..b.vertex_count, 0..1);
				}
			}
		};

		let pipeline_key = self.get_shape_pipeline_key(shape, layer);
		let pipeline = &self.pipelines[&pipeline_key];
		pass.set_pipeline(&pipeline.pipeline);

		// Get bindings from shape_data
		let bind_groups = &shape_data.bind_groups;

		// Use pre-computed rendering strategy
		match shape_data.rendering_strategy {
			InstanceRenderingStrategy::NoInstances => {
				// Case 1: No instances - both bindings  1
				// Set both bind groups once and do single draw
				if let Some(layer_bind_group_data) = &shape_data.layer_bind_group_data {
					let layer_bind_group = layer_bind_group_data.to_gpu_bind_group(self);
					pass.set_bind_group(1, &layer_bind_group, &[]);
				}

				let value_binding = bind_groups.first().copied();
				draw(pass, value_binding);
			}
			InstanceRenderingStrategy::ValueBindingsVary => {
				// Case 2: Only value bindings vary (values > 1, layers  1)
				// Set layer bindings once, iterate through value bindings
				if let Some(layer_bind_group_data) = &shape_data.layer_bind_group_data {
					let layer_bind_group = layer_bind_group_data.to_gpu_bind_group(self);
					pass.set_bind_group(1, &layer_bind_group, &[]);
				}

				for value_bg in bind_groups {
					draw(pass, Some(*value_bg));
				}
			}
			InstanceRenderingStrategy::LayerBindingsVary => {
				// Case 3: Only layer bindings vary (layers > 1, values  1)
				// Set value bindings once, iterate through layer bindings
				if let Some(value_bg) = bind_groups.first() {
					pass.set_bind_group(0, &self.bind_groups[value_bg.0].bind_group, &[]);
				}

				if let Some(layer_bind_group_data) = &shape_data.layer_bind_group_data {
					let layer_bind_groups = layer_bind_group_data.to_gpu_bind_groups(self);
					for layer_bg in layer_bind_groups {
						pass.set_bind_group(1, &layer_bg, &[]);
						draw(pass, None);
					}
				}
			}
			InstanceRenderingStrategy::BothBindingsVary => {
				// Case 4: Both bindings vary (both > 1)
				// Iterate through all instances, setting both bind groups per draw
				if let Some(layer_bind_group_data) = &shape_data.layer_bind_group_data {
					let layer_bind_groups = layer_bind_group_data.to_gpu_bind_groups(self);

					for (value_bg, layer_bg) in bind_groups.iter().zip(layer_bind_groups.iter()) {
						pass.set_bind_group(0, &self.bind_groups[value_bg.0].bind_group, &[]);
						pass.set_bind_group(1, layer_bg, &[]);
						draw(pass, None);
					}
				}
			}
		}
	}

	/// Helper to create a single layer bind group, optionally prepending the source binding.
	fn create_layer_bind_group(
		&self,
		layer_bind_group_data: &LayerBindGroupData,
		source_binding: Option<&LayerBinding>,
	) -> wgpu::BindGroup {
		if let Some(binding) = source_binding {
			layer_bind_group_data.to_gpu_bind_group_with_first(self, binding)
		} else {
			layer_bind_group_data.to_gpu_bind_group(self)
		}
	}

	/// Helper to create multiple layer bind groups, optionally prepending the source binding to each.
	fn create_layer_bind_groups(
		&self,
		layer_bind_group_data: &LayerBindGroupData,
		source_binding: Option<&LayerBinding>,
	) -> Vec<wgpu::BindGroup> {
		if let Some(binding) = source_binding {
			layer_bind_group_data.to_gpu_bind_groups_with_first(self, binding)
		} else {
			layer_bind_group_data.to_gpu_bind_groups(self)
		}
	}

	/// Renders an effect with optimized instance handling.
	///
	/// # Instance Rendering Rules
	/// Based on the lengths of bind_groups (value bindings) and layer_bind_group_data (layer bindings):
	///
	/// 1. **No instances** (both  1): Set bindings once, single draw call
	/// 2. **Only value bindings vary** (values > 1, layers  1):
	///    Set layer bindings once, iterate through value bindings
	/// 3. **Only layer bindings vary** (layers > 1, values  1):
	///    Set value bindings once, iterate through layer bindings
	/// 4. **Both vary** (both > 1):
	///    Iterate through all instances, setting both bind groups per draw
	///
	/// This respects the override hierarchy: Layer  Effect  Instance
	fn render_effect(&self, effect_index: usize, layer: Layer, skip_source: bool) {
		let l = &self.layers[layer.0];
		let effect_data = &l.effects[effect_index];
		let effect = effect_data.effect;
		let e = &self.effects[effect.0];

		let view = if let Some(mip_level) = e.dst_mip_level {
			l.current_target_texture()
				.view(self, &TexViewKey::AtMipLevel(mip_level))
		} else {
			l.current_target_texture().target_view(self)
		};

		let mut encoder = self
			.device
			.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: None });

		{
			let mut pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
				label: None,
				color_attachments: &[Some(wgpu::RenderPassColorAttachment {
					view,
					resolve_target: None,
					ops: wgpu::Operations {
						load: l
							.clear_color
							.map_or(wgpu::LoadOp::Load, |color| wgpu::LoadOp::Clear(color)),
						store: wgpu::StoreOp::Store,
					},
					depth_slice: None,
				})],
				depth_stencil_attachment: None,
				timestamp_writes: None,
				occlusion_query_set: None,
			});

			let pipeline_key = self.get_effect_pipeline_key(effect, layer);
			let pipeline = &self.pipelines[&pipeline_key];
			pass.set_pipeline(&pipeline.pipeline);

			// Get bindings from effect_data
			let bind_groups = &effect_data.bind_groups;

			// Pre-compute source binding if needed (avoids duplicate computation in all cases)
			let source_binding = if !skip_source {
				Some(if let Some(src_mip_level) = e.src_mip_level {
					layer.binding_at_mip_level(src_mip_level)
				} else {
					layer.binding()
				})
			} else {
				None
			};

			// Use pre-computed rendering strategy
			match effect_data.rendering_strategy {
				InstanceRenderingStrategy::NoInstances => {
					// Case 1: No instances - both bindings  1
					// Set both bind groups once and do single draw
					if let Some(layer_bind_group_data) = &effect_data.layer_bind_group_data {
						let layer_bind_group = self.create_layer_bind_group(
							layer_bind_group_data,
							source_binding.as_ref(),
						);
						pass.set_bind_group(1, &layer_bind_group, &[]);
					}

					if let Some(value_bg) = bind_groups.first() {
						pass.set_bind_group(0, &self.bind_groups[value_bg.0].bind_group, &[]);
					}
					pass.draw(0..3, 0..1);
				}
				InstanceRenderingStrategy::ValueBindingsVary => {
					// Case 2: Only value bindings vary (values > 1, layers  1)
					// Set layer bindings once, iterate through value bindings
					if let Some(layer_bind_group_data) = &effect_data.layer_bind_group_data {
						let layer_bind_group = self.create_layer_bind_group(
							layer_bind_group_data,
							source_binding.as_ref(),
						);
						pass.set_bind_group(1, &layer_bind_group, &[]);
					}

					for value_bg in bind_groups {
						pass.set_bind_group(0, &self.bind_groups[value_bg.0].bind_group, &[]);
						pass.draw(0..3, 0..1);
					}
				}
				InstanceRenderingStrategy::LayerBindingsVary => {
					// Case 3: Only layer bindings vary (layers > 1, values  1)
					// Set value bindings once, iterate through layer bindings
					if let Some(value_bg) = bind_groups.first() {
						pass.set_bind_group(0, &self.bind_groups[value_bg.0].bind_group, &[]);
					}

					if let Some(layer_bind_group_data) = &effect_data.layer_bind_group_data {
						let layer_bind_groups = self.create_layer_bind_groups(
							layer_bind_group_data,
							source_binding.as_ref(),
						);
						for layer_bg in layer_bind_groups {
							pass.set_bind_group(1, &layer_bg, &[]);
							pass.draw(0..3, 0..1);
						}
					} else {
						pass.draw(0..3, 0..1);
					}
				}
				InstanceRenderingStrategy::BothBindingsVary => {
					// Case 4: Both bindings vary (both > 1)
					// Iterate through all instances, setting both bind groups per draw
					if let Some(layer_bind_group_data) = &effect_data.layer_bind_group_data {
						let layer_bind_groups = self.create_layer_bind_groups(
							layer_bind_group_data,
							source_binding.as_ref(),
						);

						for (value_bg, layer_bg) in bind_groups.iter().zip(layer_bind_groups.iter())
						{
							pass.set_bind_group(0, &self.bind_groups[value_bg.0].bind_group, &[]);
							pass.set_bind_group(1, layer_bg, &[]);
							pass.draw(0..3, 0..1);
						}
					}
				}
			}
		}

		self.queue.submit(Some(encoder.finish()));
	}

	pub fn paint(&mut self, layer: Layer) {
		let l = &self.layers[layer.0];
		let shapes_len = l.shapes.len();
		let effects_len = l.effects.len();
		let has_shapes = shapes_len > 0;

		if has_shapes {
			let color_attachments: Vec<Option<RenderPassColorAttachment<'_>>> =
				if !l.is_multi_target {
					let target_view = l.current_target_texture().target_view(self);
					let multisampled_texture = l.multisampled_textures.get(0);

					let view = multisampled_texture.map_or(target_view, |t| t.target_view(self));
					let resolve_target = multisampled_texture.map(|_| target_view);

					vec![Some(wgpu::RenderPassColorAttachment {
						view,
						resolve_target,
						ops: wgpu::Operations {
							load: l
								.clear_color
								.map_or(wgpu::LoadOp::Load, |color| wgpu::LoadOp::Clear(color)),
							store: wgpu::StoreOp::Store,
						},
						depth_slice: None,
					})]
				} else {
					l.target_textures
						.iter()
						.enumerate()
						.map(|(i, t)| {
							let target_view = t.target_view(self);
							let multisampled_texture = l.multisampled_textures.get(i);

							let view =
								multisampled_texture.map_or(target_view, |t| t.target_view(self));
							let resolve_target = multisampled_texture.map(|_| target_view);

							Some(wgpu::RenderPassColorAttachment {
								view,
								resolve_target,
								ops: wgpu::Operations {
									load: l.clear_color.map_or(wgpu::LoadOp::Load, |color| {
										wgpu::LoadOp::Clear(color)
									}),
									store: wgpu::StoreOp::Store,
								},
								depth_slice: None,
							})
						})
						.collect::<Vec<_>>()
				};

			let mut encoder = self
				.device
				.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: None });

			{
				let mut pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
					label: None,
					color_attachments: &color_attachments,
					depth_stencil_attachment: l.depth_texture.as_ref().map(|t| {
						wgpu::RenderPassDepthStencilAttachment {
							view: t.view(self, &TexViewKey::Default),
							depth_ops: Some(wgpu::Operations {
								load: wgpu::LoadOp::Clear(1.0),
								store: wgpu::StoreOp::Store,
							}),
							stencil_ops: None,
						}
					}),
					timestamp_writes: None,
					occlusion_query_set: None,
				});

				for i in 0..shapes_len {
					self.render_shape(&mut pass, i, layer);
				}
			}

			self.queue.submit(Some(encoder.finish()));
		}

		if effects_len == 0 {
			l.current_target_texture().update_mips(self);
			return;
		}

		if has_shapes {
			self.layers[layer.0].swap_targets();
		}

		let mut update_mips = true;
		for i in 0..effects_len {
			let effect = self.layers[layer.0].effects[i].effect;
			let e = &self.effects[effect.0];

			let skip_source_tex = i == 0 && !(has_shapes || e.src_mip_level.is_some());
			self.render_effect(i, layer, skip_source_tex);

			if e.dst_mip_level.is_none() {
				self.layers[layer.0].swap_targets();
			} else {
				// If the effect has a mip target, we don't swap the targets.
				// Instead, we update the mips of the current target texture.
				update_mips = false;
			}
		}

		if update_mips {
			self.layers[layer.0]
				.current_source_texture()
				.update_mips(self);
		}
	}

	pub fn compose<I>(&mut self, layers: I)
	where
		I: IntoIterator<Item = Layer>,
	{
		for layer in layers {
			self.paint(layer);
		}
	}

	pub fn show(&mut self, layer: Layer) {
		let result = self.surface.get_current_texture();

		if result.is_err() {
			self.surface_error = Some(result.err().unwrap());
			return;
		}

		let frame = result.unwrap();

		let view = frame
			.texture
			.create_view(&wgpu::TextureViewDescriptor::default());

		let mut encoder = self
			.device
			.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: None });

		let pipeline = &self.pipelines[FULL_SCREEN_TEXTURE_PIPELINE];

		{
			let mut pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
				label: None,
				color_attachments: &[Some(wgpu::RenderPassColorAttachment {
					view: &view,
					resolve_target: None,
					ops: wgpu::Operations {
						load: wgpu::LoadOp::Clear(wgpu::Color::BLACK),
						store: wgpu::StoreOp::Store,
					},
					depth_slice: None,
				})],
				depth_stencil_attachment: None,
				timestamp_writes: None,
				occlusion_query_set: None,
			});
			pass.set_pipeline(&pipeline.pipeline);
			pass.set_bind_group(0, &self.bind_groups[0].bind_group, &[]);
			pass.set_bind_group(
				1,
				&BindGroup::layer_gpu_bind_group(self, layer.binding()),
				&[],
			);
			pass.draw(0..3, 0..1);
		}

		self.queue.submit(Some(encoder.finish()));
		frame.present();
	}

	pub fn paint_and_show(&mut self, layer: Layer) {
		self.paint(layer);
		self.show(layer)
	}

	/// Initializes GPU pipelines for the layer and then renders it.
	/// Pipelines need to be initialized only once per layer, so this is a convenient method for the first paint.
	///
	/// Only needed if the layer was created outsite of CanvasApp::init, or if the layer should be rendered immediately after creation.
	/// Otherwise, all layers are initialized automatically after CanvasApp::init and before the first CanvasApp::render call.
	pub fn init_and_paint(&mut self, layer: Layer) {
		layer.init_gpu_pipelines(self);
		self.paint(layer);
	}

	#[cfg(not(target_arch = "wasm32"))]
	pub(crate) fn reload_shader(&mut self, path: String) {
		println!("Reloading shader: {}", path);
		let shade_indices = self
			.shades
			.iter()
			.enumerate()
			.filter_map(|(idx, s)| {
				if s.vertex_path.as_ref().map_or(false, |p| p.contains(&path)) {
					return Some(idx);
				}
				if s.fragment_path
					.as_ref()
					.map_or(false, |p| p.contains(&path))
				{
					return Some(idx);
				}
				None
			})
			.collect::<Vec<_>>();

		let pipeline_keys = self
			.pipelines
			.keys()
			.cloned()
			.map(|key| (u16::from_le_bytes([key[0], key[1]]), key))
			.collect::<Vec<_>>();

		for idx in shade_indices {
			Shade(idx).load_fragment_from_path(self);
			Shade(idx).load_vertex_from_path(self);

			for (shade_idx, pipeline_key) in &pipeline_keys {
				if *shade_idx == idx as u16 {
					let pipeline = self.pipelines.remove(pipeline_key);
					if let Some(pipeline) = pipeline {
						let pipeline = pipeline.recreate(self);
						self.pipelines.insert(pipeline_key.clone(), pipeline);
					}
				}
			}
		}
	}
}

pub(crate) fn get_padded_size(unpadded_size: u64) -> u64 {
	// Valid vulkan usage is
	// 1. buffer size must be a multiple of COPY_BUFFER_ALIGNMENT.
	// 2. buffer size must be greater than 0.
	// Therefore we round the value up to the nearest multiple, and ensure it's at least COPY_BUFFER_ALIGNMENT.
	let align_mask = wgpu::COPY_BUFFER_ALIGNMENT - 1;
	((unpadded_size + align_mask) & !align_mask).max(wgpu::COPY_BUFFER_ALIGNMENT)
}
</file>

<file path="src/pipeline.rs">
use trivalibs_core::utils::default;
use wgpu::{util::make_spirv, ColorTargetState};

use crate::{effect::Effect, layer::Layer, shape::Shape, Painter};

pub(crate) struct PipelineStorage {
	pub pipeline: wgpu::RenderPipeline,
	#[allow(dead_code)] // not used in WASM builds
	pub layer: Option<Layer>,
	#[allow(dead_code)] // not used in WASM builds
	pub shape: Option<Shape>,
	#[allow(dead_code)] // not used in WASM builds
	pub effect: Option<Effect>,
}

impl PipelineStorage {
	pub(crate) fn create_shape_pipeline(painter: &Painter, shape: Shape, layer: Layer) -> Self {
		let l = &painter.layers[layer.0];
		let sp = &painter.shapes[shape.0];
		let sd = &painter.shades[sp.shade.0];
		let f = &painter.forms[sp.form.0];

		let targets: Vec<Option<ColorTargetState>> = l
			.formats
			.iter()
			.map(|f| {
				Some(wgpu::ColorTargetState {
					format: *f,
					blend: Some(sp.blend_state),
					write_mask: wgpu::ColorWrites::ALL,
				})
			})
			.collect::<Vec<_>>();

		let vertex_shader = painter
			.device
			.create_shader_module(wgpu::ShaderModuleDescriptor {
				label: None,
				source: make_spirv(&sd.vertex_bytes.as_ref().unwrap()),
			});

		let fragment_shader = painter
			.device
			.create_shader_module(wgpu::ShaderModuleDescriptor {
				label: None,
				source: make_spirv(&sd.fragment_bytes.as_ref().unwrap()),
			});

		let pipeline = painter
			.device
			.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
				label: None,
				layout: Some(&sd.pipeline_layout),
				vertex: wgpu::VertexState {
					module: &vertex_shader,
					entry_point: None,
					buffers: &[wgpu::VertexBufferLayout {
						array_stride: sd.attribs.stride,
						step_mode: wgpu::VertexStepMode::Vertex,
						attributes: &sd.attribs.attributes,
					}],
					compilation_options: default(),
				},
				fragment: Some(wgpu::FragmentState {
					module: &fragment_shader,
					entry_point: None,
					targets: targets.as_slice(),
					compilation_options: default(),
				}),
				primitive: wgpu::PrimitiveState {
					topology: f.props.topology,
					strip_index_format: None,
					front_face: f.props.front_face,
					cull_mode: sp.cull_mode,
					// Setting this to anything other than Fill requires Features::NON_FILL_POLYGON_MODE
					polygon_mode: wgpu::PolygonMode::Fill,
					unclipped_depth: false,
					conservative: false,
				},
				depth_stencil: if l.depth_texture.is_some() {
					Some(wgpu::DepthStencilState {
						format: wgpu::TextureFormat::Depth24Plus,
						depth_write_enabled: true,
						depth_compare: wgpu::CompareFunction::Less,
						stencil: default(),
						bias: default(),
					})
				} else {
					None
				},
				multisample: wgpu::MultisampleState {
					count: if l.multisampled_textures.is_empty() {
						1
					} else {
						4
					},
					mask: !0,
					alpha_to_coverage_enabled: false,
				},
				multiview: None,
				cache: None,
			});

		PipelineStorage {
			pipeline,
			effect: None,
			layer: Some(layer),
			shape: Some(shape),
		}
	}

	pub(crate) fn create_effect_pipeline(painter: &Painter, effect: Effect, layer: Layer) -> Self {
		let e = &painter.effects[effect.0];
		let s = &painter.shades[e.shade.0];
		let l = &painter.layers[layer.0];

		let fragment_shader = painter
			.device
			.create_shader_module(wgpu::ShaderModuleDescriptor {
				label: None,
				source: make_spirv(&s.fragment_bytes.as_ref().unwrap()),
			});

		let targets: Vec<Option<ColorTargetState>> = l
			.formats
			.iter()
			.map(|f| {
				Some(wgpu::ColorTargetState {
					format: *f,
					blend: Some(e.blend_state),
					write_mask: wgpu::ColorWrites::ALL,
				})
			})
			.collect::<Vec<_>>();

		let pipeline = painter
			.device
			.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
				label: None,
				layout: Some(&s.pipeline_layout),
				vertex: wgpu::VertexState {
					module: &painter.fullscreen_quad_shader,
					entry_point: Some("vs_main"),
					buffers: &[],
					compilation_options: default(),
				},
				fragment: Some(wgpu::FragmentState {
					module: &fragment_shader,
					entry_point: None,
					targets: targets.as_slice(),
					compilation_options: default(),
				}),
				primitive: wgpu::PrimitiveState {
					topology: wgpu::PrimitiveTopology::TriangleStrip,
					strip_index_format: None,
					front_face: wgpu::FrontFace::Cw,
					cull_mode: None,
					polygon_mode: wgpu::PolygonMode::Fill,
					..default()
				},
				depth_stencil: None,
				multisample: wgpu::MultisampleState {
					count: 1,
					mask: !0,
					alpha_to_coverage_enabled: false,
				},
				multiview: None,
				cache: None,
			});

		PipelineStorage {
			pipeline,
			layer: Some(layer),
			effect: Some(effect),
			shape: None,
		}
	}

	#[cfg(not(target_arch = "wasm32"))]
	pub(crate) fn recreate(self, painter: &Painter) -> Self {
		if let Some(layer) = self.layer {
			if let Some(effect) = self.effect {
				return Self::create_effect_pipeline(painter, effect, layer);
			} else if let Some(shape) = self.shape {
				return Self::create_shape_pipeline(painter, shape, layer);
			}
		}

		self
	}
}
</file>

<file path="src/sampler.rs">
use crate::{binding::ValueBinding, Painter};

#[derive(Clone, Copy)]
pub struct SamplerProps {
	pub address_mode_u: wgpu::AddressMode,
	pub address_mode_v: wgpu::AddressMode,
	pub mag_filter: wgpu::FilterMode,
	pub min_filter: wgpu::FilterMode,
	pub mipmap_filter: wgpu::FilterMode,
	pub sample_depth: bool,
}

impl Default for SamplerProps {
	fn default() -> Self {
		Self::NEAREST
	}
}

impl SamplerProps {
	pub const NEAREST: SamplerProps = SamplerProps {
		address_mode_u: wgpu::AddressMode::ClampToEdge,
		address_mode_v: wgpu::AddressMode::ClampToEdge,
		mag_filter: wgpu::FilterMode::Nearest,
		min_filter: wgpu::FilterMode::Nearest,
		mipmap_filter: wgpu::FilterMode::Nearest,
		sample_depth: false,
	};

	pub const LINEAR: SamplerProps = SamplerProps {
		address_mode_u: wgpu::AddressMode::ClampToEdge,
		address_mode_v: wgpu::AddressMode::ClampToEdge,
		mag_filter: wgpu::FilterMode::Linear,
		min_filter: wgpu::FilterMode::Linear,
		mipmap_filter: wgpu::FilterMode::Nearest,
		sample_depth: false,
	};
}

#[derive(Clone, Copy)]
pub struct Sampler(pub(crate) usize);

impl Sampler {
	pub fn create(painter: &mut Painter, props: SamplerProps) -> Self {
		let sampler = painter.device.create_sampler(&wgpu::SamplerDescriptor {
			address_mode_u: props.address_mode_u,
			address_mode_v: props.address_mode_v,
			address_mode_w: wgpu::AddressMode::ClampToEdge,
			mag_filter: props.mag_filter,
			min_filter: props.min_filter,
			mipmap_filter: props.mipmap_filter,
			compare: props.sample_depth.then(|| wgpu::CompareFunction::LessEqual),
			..Default::default()
		});

		painter.samplers.push(sampler);

		Self(painter.samplers.len() - 1)
	}

	pub fn binding(&self) -> ValueBinding {
		ValueBinding::Sampler(*self)
	}
}

pub struct SamplerBuilder<'a> {
	props: SamplerProps,
	painter: &'a mut Painter,
}

impl<'a> SamplerBuilder<'a> {
	pub fn new(painter: &'a mut Painter) -> Self {
		Self {
			props: SamplerProps::default(),
			painter,
		}
	}

	pub fn create(self) -> Sampler {
		Sampler::create(self.painter, self.props)
	}

	pub fn with_address_mode_u(mut self, mode: wgpu::AddressMode) -> Self {
		self.props.address_mode_u = mode;
		self
	}

	pub fn with_address_mode_v(mut self, mode: wgpu::AddressMode) -> Self {
		self.props.address_mode_v = mode;
		self
	}

	pub fn with_address_modes(mut self, mode: wgpu::AddressMode) -> Self {
		self.props.address_mode_u = mode;
		self.props.address_mode_v = mode;
		self
	}

	pub fn with_mag_filter(mut self, filter: wgpu::FilterMode) -> Self {
		self.props.mag_filter = filter;
		self
	}

	pub fn with_min_filter(mut self, filter: wgpu::FilterMode) -> Self {
		self.props.min_filter = filter;
		self
	}

	pub fn with_filters(mut self, filter: wgpu::FilterMode) -> Self {
		self.props.mag_filter = filter;
		self.props.min_filter = filter;
		self
	}

	pub fn with_mipmap_filter(mut self, filter: wgpu::FilterMode) -> Self {
		self.props.mipmap_filter = filter;
		self
	}

	pub fn with_depth_sampling(mut self) -> Self {
		self.props.sample_depth = true;
		self
	}
}
</file>

<file path="src/shade.rs">
use crate::{
	Painter,
	bind_group::BindGroupLayout,
	binding::{BindingLayout, LayerLayout},
	prelude::BINDING_LAYER_FRAG,
};
use std::fs;

pub(crate) struct ShadeStorage {
	pub vertex_path: Option<String>,
	pub vertex_bytes: Option<Vec<u8>>,
	pub fragment_path: Option<String>,
	pub fragment_bytes: Option<Vec<u8>>,
	pub attribs: AttribsFormat,
	pub pipeline_layout: wgpu::PipelineLayout,
	pub binding_layout: Option<BindGroupLayout>,
	pub layers_layout: Option<BindGroupLayout>,
	pub value_bindings_length: usize,
	pub layer_bindings_length: usize,
}

pub struct ShadeProps<Format: Into<AttribsFormat>> {
	pub attributes: Format,
	pub bindings: Vec<BindingLayout>,
	pub layers: Vec<LayerLayout>,
}

fn layouts_from_props(
	painter: &mut Painter,
	bindings: &[BindingLayout],
	layers: &[LayerLayout],
) -> (
	wgpu::PipelineLayout,
	Option<BindGroupLayout>,
	Option<BindGroupLayout>,
) {
	let bindings_layout = BindGroupLayout::values(painter, bindings);

	let layer_layout = BindGroupLayout::layers(painter, layers);

	let mut layouts = vec![];

	if let Some(l) = &bindings_layout {
		layouts.push(&painter.bind_group_layouts[l.0]);
	}

	if let Some(l) = &layer_layout {
		layouts.push(&painter.bind_group_layouts[l.0]);
	}

	let pipeline_layout = painter
		.device
		.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
			label: None,
			bind_group_layouts: layouts.as_slice(),
			push_constant_ranges: &[],
		});

	(pipeline_layout, bindings_layout, layer_layout)
}

impl Default for ShadeProps<AttribsFormat> {
	fn default() -> Self {
		Self {
			attributes: AttribsFormat {
				attributes: vec![],
				stride: 0,
			},
			bindings: vec![],
			layers: vec![],
		}
	}
}

pub struct ShadeEffectProps {
	pub bindings: Vec<BindingLayout>,
	pub layers: Vec<LayerLayout>,
}

impl Default for ShadeEffectProps {
	fn default() -> Self {
		Self {
			bindings: vec![],
			layers: vec![],
		}
	}
}

pub struct AttribsFormat {
	pub stride: u64,
	pub attributes: Vec<wgpu::VertexAttribute>,
}

pub fn attrib(location: u32, format: wgpu::VertexFormat, offset: u64) -> wgpu::VertexAttribute {
	wgpu::VertexAttribute {
		shader_location: location,
		format,
		offset,
	}
}

impl From<&[wgpu::VertexFormat]> for AttribsFormat {
	fn from(formats: &[wgpu::VertexFormat]) -> Self {
		let mut stride = 0;
		let mut attributes = Vec::with_capacity(formats.len());
		let mut location = 0;
		for format in formats {
			attributes.push(attrib(location, *format, stride));
			stride += format.size();
			location += 1;
		}

		AttribsFormat { attributes, stride }
	}
}

// Generic implementation for all array sizes using const generics
impl<const N: usize> From<[wgpu::VertexFormat; N]> for AttribsFormat {
	fn from(formats: [wgpu::VertexFormat; N]) -> Self {
		AttribsFormat::from(formats.as_slice())
	}
}

impl<const N: usize> From<&[wgpu::VertexFormat; N]> for AttribsFormat {
	fn from(formats: &[wgpu::VertexFormat; N]) -> Self {
		AttribsFormat::from(formats.as_slice())
	}
}

impl From<Vec<wgpu::VertexFormat>> for AttribsFormat {
	fn from(formats: Vec<wgpu::VertexFormat>) -> Self {
		AttribsFormat::from(formats.as_slice())
	}
}

impl From<wgpu::VertexFormat> for AttribsFormat {
	fn from(format: wgpu::VertexFormat) -> Self {
		AttribsFormat {
			attributes: vec![attrib(0, format, 0)],
			stride: format.size(),
		}
	}
}

#[derive(Clone, Copy)]
pub struct Shade(pub(crate) usize);

impl Shade {
	pub fn new<Format: Into<AttribsFormat>>(
		painter: &mut Painter,
		props: ShadeProps<Format>,
	) -> Self {
		let format = props.attributes.into();
		let bindings_len = props.bindings.len();
		let layers_len = props.layers.len();

		let (pipeline_layout, binding_layout, layers_layout) =
			layouts_from_props(painter, &props.bindings, &props.layers);

		let s = ShadeStorage {
			vertex_path: None,
			vertex_bytes: None,
			fragment_path: None,
			fragment_bytes: None,
			attribs: format,
			pipeline_layout,
			binding_layout,
			layers_layout,
			value_bindings_length: bindings_len,
			layer_bindings_length: layers_len,
		};

		let i = painter.shades.len();
		painter.shades.push(s);

		Shade(i)
	}

	pub fn new_effect(painter: &mut Painter, props: ShadeEffectProps) -> Self {
		let bindings_len = props.bindings.len();
		let layers_len = props.layers.len();

		let (pipeline_layout, binding_layout, layers_layout) =
			layouts_from_props(painter, &props.bindings, &props.layers);

		let format = vec![].into();

		let s = ShadeStorage {
			vertex_path: None,
			vertex_bytes: None,
			fragment_path: None,
			fragment_bytes: None,
			attribs: format,
			pipeline_layout,
			binding_layout,
			layers_layout,
			value_bindings_length: bindings_len,
			layer_bindings_length: layers_len,
		};

		let i = painter.shades.len();
		painter.shades.push(s);

		Shade(i)
	}

	pub fn form_stride(&self, painter: &Painter) -> u64 {
		painter.shades[self.0].attribs.stride
	}

	pub fn set_vertex_bytes(&self, painter: &mut Painter, bytes: Vec<u8>) {
		painter.shades[self.0].vertex_bytes = Some(bytes);
	}

	pub(crate) fn load_vertex_from_path(&self, painter: &mut Painter) {
		if let Some(shader_path) = &painter.shades[self.0].vertex_path {
			let bytes = fs::read(shader_path).expect("Failed to read vertex shader file");
			self.set_vertex_bytes(painter, bytes);
		}
	}

	pub fn set_vertex_path(&self, painter: &mut Painter, path: &str) {
		painter.shades[self.0].vertex_path = Some(path.to_string());
		self.load_vertex_from_path(painter);
	}

	pub fn set_fragment_bytes(&self, painter: &mut Painter, bytes: Vec<u8>) {
		painter.shades[self.0].fragment_bytes = Some(bytes);
	}

	pub(crate) fn load_fragment_from_path(&self, painter: &mut Painter) {
		if let Some(shader_path) = &painter.shades[self.0].fragment_path {
			let bytes = fs::read(shader_path).expect("Failed to read fragment shader file");
			self.set_fragment_bytes(painter, bytes);
		}
	}

	pub fn set_fragment_path(&self, painter: &mut Painter, path: &str) {
		painter.shades[self.0].fragment_path = Some(path.to_string());
		self.load_fragment_from_path(painter);
	}
}

pub struct ShadeBuilder<'b, Format>
where
	Format: Into<AttribsFormat>,
{
	props: ShadeProps<Format>,
	painter: &'b mut Painter,
}

impl<'b, Format> ShadeBuilder<'b, Format>
where
	Format: Into<AttribsFormat>,
{
	pub fn new(painter: &'b mut Painter, attributes: Format) -> Self {
		ShadeBuilder {
			props: ShadeProps {
				attributes,
				bindings: vec![],
				layers: vec![],
			},
			painter,
		}
	}

	pub fn create(self) -> Shade {
		Shade::new(self.painter, self.props)
	}

	pub fn with_bindings<I>(mut self, bindings: I) -> Self
	where
		I: IntoIterator<Item = BindingLayout>,
	{
		self.props.bindings = bindings.into_iter().collect();
		self
	}

	pub fn with_layers<I>(mut self, layers: I) -> Self
	where
		I: IntoIterator<Item = LayerLayout>,
	{
		self.props.layers = layers.into_iter().collect();
		self
	}
}

pub struct ShadeEffectBuilder<'b> {
	props: ShadeEffectProps,
	painter: &'b mut Painter,
}

impl<'b> ShadeEffectBuilder<'b> {
	pub fn new(painter: &'b mut Painter) -> Self {
		ShadeEffectBuilder {
			props: ShadeEffectProps {
				bindings: vec![],
				layers: vec![],
			},
			painter,
		}
	}

	pub fn create(self) -> Shade {
		Shade::new_effect(self.painter, self.props)
	}

	pub fn with_bindings<I>(mut self, bindings: I) -> Self
	where
		I: IntoIterator<Item = BindingLayout>,
	{
		self.props.bindings = bindings.into_iter().collect();
		self
	}

	pub fn with_layers<I>(mut self, layers: I) -> Self
	where
		I: IntoIterator<Item = LayerLayout>,
	{
		self.props.layers = layers.into_iter().collect();
		self
	}

	pub fn with_layer(mut self) -> Self {
		self.props.layers = vec![BINDING_LAYER_FRAG];
		self
	}
}

#[macro_export]
macro_rules! load_fragment_shader {
	($shade:expr, $painter:expr, $path:expr) => {
		#[cfg(all(debug_assertions, not(target_arch = "wasm32")))]
		{
			let current_file = file!();
			let current_dir = std::path::Path::new(current_file).parent().unwrap();
			println!("try loading shader: {:?}, {:?}", current_dir, $path);
			let full_path = current_dir.join($path);
			let full_path = std::fs::canonicalize(full_path).unwrap();
			let full_path = full_path.to_str().unwrap();
			println!("loading shader: {:?}", full_path);
			$shade.set_fragment_path($painter, full_path);
		}

		#[cfg(not(debug_assertions))]
		$shade.set_fragment_bytes($painter, include_bytes!($path).to_vec());
		#[cfg(target_arch = "wasm32")]
		$shade.set_fragment_bytes($painter, include_bytes!($path).to_vec());
	};
}

#[macro_export]
macro_rules! load_vertex_shader {
	($shade:expr, $painter:expr, $path:expr) => {
		#[cfg(all(debug_assertions, not(target_arch = "wasm32")))]
		{
			let current_file = file!();
			let current_dir = std::path::Path::new(current_file).parent().unwrap();
			let full_path = current_dir.join($path);
			let full_path = std::fs::canonicalize(full_path).unwrap();
			let full_path = full_path.to_str().unwrap();
			println!("loading shader: {:?}", full_path);
			$shade.set_vertex_path($painter, full_path);
		}

		#[cfg(not(debug_assertions))]
		$shade.set_vertex_bytes($painter, include_bytes!($path).to_vec());
		#[cfg(target_arch = "wasm32")]
		$shade.set_vertex_bytes($painter, include_bytes!($path).to_vec());
	};
}
</file>

<file path="src/shaders.rs">
// Full screen triangle concept explained here:
// https://www.saschawillems.de/blog/2016/08/13/vulkan-tutorial-on-rendering-a-fullscreen-quad-without-buffers/
pub const FULL_SCREEN_QUAD: &str = r#"
struct VertexOutput {
  @builtin(position) position: vec4f,
  @location(0) coord: vec2f,
};

@vertex
fn vs_main(@builtin(vertex_index) vertex_index: u32) -> VertexOutput {
  var out: VertexOutput;
  var coord = vec2f(f32((vertex_index << 1) & 2), f32(vertex_index & 2));
  out.position = vec4f(coord * 2.0 - 1.0, 0.0, 1.0);
	coord.y = 1.0 - coord.y;
	out.coord = coord;
  return out;
}

@group(0) @binding(0) var ourSampler: sampler;
@group(1) @binding(0) var ourTexture: texture_2d<f32>;

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4f {
	return textureSample(ourTexture, ourSampler, in.coord);
}
"#;
</file>

<file path="src/shape.rs">
use crate::{
	Painter,
	binding::{InstanceBinding, LayerBinding, ValueBinding},
	form::Form,
	shade::Shade,
};

#[derive(Clone)]
pub(crate) struct ShapeStorage {
	pub form: Form,
	pub shade: Shade,
	pub bindings: Vec<(u32, ValueBinding)>,
	pub layers: Vec<(u32, LayerBinding)>,
	pub instances: Vec<InstanceBinding>,
	pub pipeline_key: Vec<u8>,
	pub cull_mode: Option<wgpu::Face>,
	pub blend_state: wgpu::BlendState,
}

#[derive(Clone)]
pub struct ShapeProps {
	pub bindings: Vec<(u32, ValueBinding)>,
	pub layers: Vec<(u32, LayerBinding)>,
	pub instances: Vec<InstanceBinding>,
	pub cull_mode: Option<wgpu::Face>,
	pub blend_state: wgpu::BlendState,
}

impl Default for ShapeProps {
	fn default() -> Self {
		ShapeProps {
			bindings: Vec::with_capacity(0),
			layers: Vec::with_capacity(0),
			instances: Vec::with_capacity(0),
			cull_mode: Some(wgpu::Face::Back),
			blend_state: wgpu::BlendState::REPLACE,
		}
	}
}

#[derive(Clone, Copy, Debug)]
pub struct Shape(pub(crate) usize);

impl Shape {
	pub fn new(painter: &mut Painter, form: Form, shade: Shade, props: ShapeProps) -> Self {
		let f = &painter.forms[form.0];

		let pipeline_key = vec![
			(shade.0 as u16).to_le_bytes().to_vec(),
			vec![
				f.props.topology as u8,
				f.props.front_face as u8,
				props.blend_state.alpha.dst_factor as u8,
				props.blend_state.alpha.src_factor as u8,
				props.blend_state.alpha.operation as u8,
				props.blend_state.color.dst_factor as u8,
				props.blend_state.color.src_factor as u8,
				props.blend_state.color.operation as u8,
				if let Some(cull_mode) = props.cull_mode {
					cull_mode as u8
				} else {
					0xff
				},
			],
		]
		.into_iter()
		.flatten()
		.collect();

		let shape = ShapeStorage {
			form,
			shade,
			pipeline_key,
			bindings: props.bindings,
			layers: props.layers,
			instances: props.instances,
			cull_mode: props.cull_mode,
			blend_state: props.blend_state,
		};

		painter.shapes.push(shape);

		Shape(painter.shapes.len() - 1)
	}
}

/// Builder for creating new [`Shape`]s with custom properties.
///
/// # Default values for [`ShapeProps`]:
/// - `cull_mode`: `Some(wgpu::Face::Back)`
/// - `blend_state`: `wgpu::BlendState::REPLACE`
///
/// # Example
/// ```
/// let shape = ShapeBuilder::new(painter, form, shade)
///     .with_bindings(bindings)
///     .with_instances(instances)
///     .create();
/// ```
pub struct ShapeBuilder<'a> {
	form: Form,
	shade: Shade,
	painter: &'a mut Painter,
	props: ShapeProps,
}

impl<'a> ShapeBuilder<'a> {
	pub fn new(painter: &'a mut Painter, form: Form, shade: Shade) -> Self {
		ShapeBuilder {
			form,
			shade,
			painter,
			props: ShapeProps::default(),
		}
	}

	pub fn create(self) -> Shape {
		Shape::new(self.painter, self.form, self.shade, self.props)
	}

	pub fn with_bindings<I>(mut self, bindings: I) -> Self
	where
		I: IntoIterator<Item = (u32, ValueBinding)>,
	{
		self.props.bindings = bindings.into_iter().collect();
		self
	}

	pub fn with_layers<I>(mut self, layers: I) -> Self
	where
		I: IntoIterator<Item = (u32, LayerBinding)>,
	{
		self.props.layers = layers.into_iter().collect();
		self
	}

	pub fn with_instances(mut self, instances: Vec<InstanceBinding>) -> Self {
		self.props.instances = instances;
		self
	}

	pub fn with_cull_mode(mut self, cull_mode: Option<wgpu::Face>) -> Self {
		self.props.cull_mode = cull_mode;
		self
	}

	pub fn with_blend_state(mut self, blend_state: wgpu::BlendState) -> Self {
		self.props.blend_state = blend_state;
		self
	}
}
</file>

<file path="src/texture_utils.rs">
use crate::{painter::FULL_SCREEN_TEXTURE_PIPELINE, Painter};
use trivalibs_core::utils::default;
use wgpu::StoreOp;

pub fn num_mip_levels(size: wgpu::Extent3d) -> u32 {
	let sizes = [size.width, size.height, size.depth_or_array_layers];
	let max_size = sizes.into_iter().max().unwrap_or(1);
	1 + (max_size as f32).log2().floor() as u32
}

pub fn generate_mipmap_2d(painter: &Painter, texture: &wgpu::Texture) {
	let mut encoder = painter
		.device
		.create_command_encoder(&wgpu::CommandEncoderDescriptor {
			label: Some("mip gen encoder"),
		});

	for base_mip_level in 1..texture.mip_level_count() {
		let src_view = texture.create_view(&wgpu::TextureViewDescriptor {
			label: None,
			dimension: Some(wgpu::TextureViewDimension::D2),
			base_mip_level: (base_mip_level - 1),
			mip_level_count: Some(1),
			..default()
		});

		let dst_view = texture.create_view(&wgpu::TextureViewDescriptor {
			label: None,
			dimension: Some(wgpu::TextureViewDimension::D2),
			base_mip_level,
			mip_level_count: Some(1),
			..default()
		});

		let pipeline = &painter.pipelines[FULL_SCREEN_TEXTURE_PIPELINE];

		let src_binding = painter
			.device
			.create_bind_group(&wgpu::BindGroupDescriptor {
				label: None,
				layout: &pipeline.pipeline.get_bind_group_layout(1),
				entries: &[wgpu::BindGroupEntry {
					binding: 0,
					resource: wgpu::BindingResource::TextureView(&src_view),
				}],
			});

		{
			let mut pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
				label: None,
				color_attachments: &[Some(wgpu::RenderPassColorAttachment {
					view: &dst_view,
					resolve_target: None,
					ops: wgpu::Operations {
						load: wgpu::LoadOp::Clear(wgpu::Color::TRANSPARENT),
						store: StoreOp::Store,
					},
					depth_slice: None,
				})],
				..Default::default()
			});

			pass.set_pipeline(&pipeline.pipeline);
			pass.set_bind_group(0, &painter.bind_groups[1].bind_group, &[]);
			pass.set_bind_group(1, &src_binding, &[]);

			pass.draw(0..3, 0..1); // Assuming a fullscreen quad
		}
	}

	painter.queue.submit(Some(encoder.finish()));
}

pub(crate) fn map_format_to_u8(format: wgpu::TextureFormat) -> u8 {
	match format {
		wgpu::TextureFormat::R8Unorm => 0,
		wgpu::TextureFormat::R8Snorm => 1,
		wgpu::TextureFormat::R8Uint => 2,
		wgpu::TextureFormat::R8Sint => 3,
		wgpu::TextureFormat::R16Uint => 4,
		wgpu::TextureFormat::R16Sint => 5,
		wgpu::TextureFormat::R16Float => 6,
		wgpu::TextureFormat::Rg8Unorm => 7,
		wgpu::TextureFormat::Rg8Snorm => 8,
		wgpu::TextureFormat::Rg8Uint => 9,
		wgpu::TextureFormat::Rg8Sint => 10,
		wgpu::TextureFormat::R32Uint => 11,
		wgpu::TextureFormat::R32Sint => 12,
		wgpu::TextureFormat::R32Float => 13,
		wgpu::TextureFormat::Rg16Uint => 14,
		wgpu::TextureFormat::Rg16Sint => 15,
		wgpu::TextureFormat::Rg16Float => 16,
		wgpu::TextureFormat::Rgba8Unorm => 17,
		wgpu::TextureFormat::Rgba8UnormSrgb => 18,
		wgpu::TextureFormat::Rgba8Snorm => 19,
		wgpu::TextureFormat::Rgba8Uint => 20,
		wgpu::TextureFormat::Rgba8Sint => 21,
		wgpu::TextureFormat::Bgra8Unorm => 22,
		wgpu::TextureFormat::Bgra8UnormSrgb => 23,
		wgpu::TextureFormat::Rgb10a2Unorm => 24,
		wgpu::TextureFormat::Rg32Uint => 26,
		wgpu::TextureFormat::Rg32Sint => 27,
		wgpu::TextureFormat::Rg32Float => 28,
		wgpu::TextureFormat::Rgba16Uint => 29,
		wgpu::TextureFormat::Rgba16Sint => 30,
		wgpu::TextureFormat::R16Unorm => 31,
		wgpu::TextureFormat::R16Snorm => 32,
		wgpu::TextureFormat::Rg16Unorm => 33,
		wgpu::TextureFormat::Rg16Snorm => 34,
		wgpu::TextureFormat::Rgb9e5Ufloat => 35,
		wgpu::TextureFormat::Rgb10a2Uint => 36,
		wgpu::TextureFormat::Rg11b10Ufloat => 37,
		wgpu::TextureFormat::Rgba16Unorm => 38,
		wgpu::TextureFormat::Rgba16Snorm => 39,
		wgpu::TextureFormat::Rgba16Float => 40,
		wgpu::TextureFormat::Rgba32Uint => 41,
		wgpu::TextureFormat::Rgba32Sint => 42,
		wgpu::TextureFormat::Rgba32Float => 43,
		wgpu::TextureFormat::Stencil8 => 44,
		wgpu::TextureFormat::Depth16Unorm => 45,
		wgpu::TextureFormat::Depth24Plus => 46,
		wgpu::TextureFormat::Depth24PlusStencil8 => 47,
		wgpu::TextureFormat::Depth32Float => 48,
		wgpu::TextureFormat::Depth32FloatStencil8 => 49,
		wgpu::TextureFormat::NV12 => 50,
		wgpu::TextureFormat::Bc1RgbaUnorm => 51,
		wgpu::TextureFormat::Bc1RgbaUnormSrgb => 52,
		wgpu::TextureFormat::Bc2RgbaUnorm => 53,
		wgpu::TextureFormat::Bc2RgbaUnormSrgb => 54,
		wgpu::TextureFormat::Bc3RgbaUnorm => 55,
		wgpu::TextureFormat::Bc3RgbaUnormSrgb => 56,
		wgpu::TextureFormat::Bc4RUnorm => 57,
		wgpu::TextureFormat::Bc4RSnorm => 58,
		wgpu::TextureFormat::Bc5RgUnorm => 59,
		wgpu::TextureFormat::Bc5RgSnorm => 60,
		wgpu::TextureFormat::Bc6hRgbUfloat => 61,
		wgpu::TextureFormat::Bc6hRgbFloat => 62,
		wgpu::TextureFormat::Bc7RgbaUnorm => 63,
		wgpu::TextureFormat::Bc7RgbaUnormSrgb => 64,
		wgpu::TextureFormat::Etc2Rgb8Unorm => 65,
		wgpu::TextureFormat::Etc2Rgb8UnormSrgb => 66,
		wgpu::TextureFormat::Etc2Rgb8A1Unorm => 67,
		wgpu::TextureFormat::Etc2Rgb8A1UnormSrgb => 68,
		wgpu::TextureFormat::Etc2Rgba8Unorm => 69,
		wgpu::TextureFormat::Etc2Rgba8UnormSrgb => 70,
		wgpu::TextureFormat::EacR11Unorm => 71,
		wgpu::TextureFormat::EacR11Snorm => 72,
		wgpu::TextureFormat::EacRg11Unorm => 73,
		wgpu::TextureFormat::EacRg11Snorm => 74,
		wgpu::TextureFormat::Astc {
			block: _,
			channel: _,
		} => 75,
		wgpu::TextureFormat::R64Uint => 76,
	}
}
</file>

<file path="src/texture.rs">
use crate::{
	texture_utils::{generate_mipmap_2d, num_mip_levels},
	Painter,
};
use std::collections::BTreeMap;
use trivalibs_core::utils::default;
use wgpu::TextureViewDescriptor;

#[derive(Clone, Copy)]
pub enum MipMapCount {
	Full,
	Max(u32),
}

/// # Default Texture2DProps
/// - Format: `Rgba8UnormSrgb` (8-bit RGBA color in sRGB color space)
/// - Usage: `TEXTURE_BINDING | COPY_DST` (can be used as texture and receive data)
#[derive(Clone, Copy)]
pub(crate) struct Texture2DProps {
	pub format: wgpu::TextureFormat,
	pub usage: wgpu::TextureUsages,
	pub mips: Option<MipMapCount>,
}

impl Default for Texture2DProps {
	fn default() -> Self {
		Texture2DProps {
			format: wgpu::TextureFormat::Rgba8UnormSrgb,
			usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
			mips: None,
		}
	}
}

#[derive(PartialEq, PartialOrd, Ord, Eq, Copy, Clone, Debug)]
pub(crate) enum TexViewKey {
	Default,
	WithAllMips,
	AtMipLevel(u32),
}

impl TexViewKey {
	pub fn make_view(&self, t: &wgpu::Texture) -> wgpu::TextureView {
		match self {
			TexViewKey::Default => t.create_view(&default()),
			TexViewKey::WithAllMips => t.create_view(&TextureViewDescriptor {
				mip_level_count: Some(t.mip_level_count()),
				..default()
			}),
			TexViewKey::AtMipLevel(mip_level) => t.create_view(&wgpu::TextureViewDescriptor {
				base_mip_level: *mip_level,
				mip_level_count: Some(1),
				..default()
			}),
		}
	}
}

pub(crate) struct TextureStorage {
	pub texture: wgpu::Texture,
	pub views: BTreeMap<TexViewKey, wgpu::TextureView>,
}

impl TextureStorage {
	pub(crate) fn prepare_view(&mut self, key: TexViewKey) {
		let view = key.make_view(&self.texture);
		self.views.insert(key, view);
	}
}

#[derive(Clone, Copy)]
pub struct Texture(pub(crate) usize);

fn create_2d(
	painter: &mut Painter,
	width: u32,
	height: u32,
	props: Texture2DProps,
	multi_sampled: bool,
) -> wgpu::Texture {
	let extent = wgpu::Extent3d {
		width,
		height,
		depth_or_array_layers: 1,
	};

	let mip_level_count = if let Some(mips) = props.mips {
		let max_mip_levels = num_mip_levels(extent);
		match mips {
			MipMapCount::Full => max_mip_levels,
			MipMapCount::Max(max) => max.min(max_mip_levels),
		}
	} else {
		1
	};

	painter.device.create_texture(&wgpu::TextureDescriptor {
		label: None,
		size: extent,
		mip_level_count,
		sample_count: if multi_sampled { 4 } else { 1 },
		dimension: wgpu::TextureDimension::D2,
		format: props.format,
		usage: if mip_level_count > 1 {
			props.usage | wgpu::TextureUsages::RENDER_ATTACHMENT
		} else {
			props.usage
		},
		view_formats: &[],
	})
}

fn create_depth(
	painter: &mut Painter,
	width: u32,
	height: u32,
	multi_sampled: bool,
) -> wgpu::Texture {
	painter.device.create_texture(&wgpu::TextureDescriptor {
		label: None,
		size: wgpu::Extent3d {
			width,
			height,
			depth_or_array_layers: 1,
		},
		mip_level_count: 1,
		sample_count: if multi_sampled { 4 } else { 1 },
		dimension: wgpu::TextureDimension::D2,
		format: wgpu::TextureFormat::Depth24Plus,
		usage: wgpu::TextureUsages::RENDER_ATTACHMENT | wgpu::TextureUsages::TEXTURE_BINDING,
		view_formats: &[],
	})
}

impl Texture {
	pub(crate) fn create_2d(
		painter: &mut Painter,
		width: u32,
		height: u32,
		props: Texture2DProps,
		multi_sampled: bool,
	) -> Self {
		let texture = create_2d(painter, width, height, props, multi_sampled);

		let mut storage = TextureStorage {
			texture,
			views: BTreeMap::new(),
		};

		storage.prepare_view(TexViewKey::AtMipLevel(0));
		storage.prepare_view(TexViewKey::WithAllMips);

		painter.textures.push(storage);

		Self(painter.textures.len() - 1)
	}

	pub(crate) fn replace_2d(
		&self,
		painter: &mut Painter,
		width: u32,
		height: u32,
		props: Texture2DProps,
		multi_sampled: bool,
	) {
		let texture = create_2d(painter, width, height, props, multi_sampled);

		let old = &mut painter.textures[self.0];

		let mut storage = TextureStorage {
			texture,
			views: BTreeMap::new(),
		};

		storage.prepare_view(TexViewKey::AtMipLevel(0));
		storage.prepare_view(TexViewKey::WithAllMips);

		old.texture.destroy();

		painter.textures[self.0] = storage;
	}

	pub fn create_depth(
		painter: &mut Painter,
		width: u32,
		height: u32,
		multi_sampled: bool,
	) -> Self {
		let texture = create_depth(painter, width, height, multi_sampled);

		let mut storage = TextureStorage {
			texture,
			views: BTreeMap::new(),
		};

		storage.prepare_view(TexViewKey::Default);

		painter.textures.push(storage);

		Self(painter.textures.len() - 1)
	}

	pub fn replace_depth(
		&self,
		painter: &mut Painter,
		width: u32,
		height: u32,
		multi_sampled: bool,
	) {
		let texture = create_depth(painter, width, height, multi_sampled);
		let old = &mut painter.textures[self.0];

		let mut storage = TextureStorage {
			texture,
			views: BTreeMap::new(),
		};

		storage.prepare_view(TexViewKey::Default);

		old.texture.destroy();

		painter.textures[self.0] = storage;
	}

	pub fn fill_2d(&self, painter: &Painter, data: &[u8]) {
		let texture = &painter.textures[self.0].texture;
		let bytes_per_pixel = texture.format().block_copy_size(None).unwrap();

		let size = texture.size();
		painter.queue.write_texture(
			// Tells wgpu where to copy the pixel data
			wgpu::TexelCopyTextureInfo {
				texture,
				mip_level: 0,
				origin: wgpu::Origin3d::ZERO,
				aspect: wgpu::TextureAspect::All,
			},
			// The actual pixel data
			data,
			// The layout of the texture
			wgpu::TexelCopyBufferLayout {
				offset: 0,
				bytes_per_row: Some(size.width * bytes_per_pixel),
				rows_per_image: Some(size.height),
			},
			size,
		);

		self.update_mips(painter);
	}

	pub fn destroy(self, painter: &mut Painter) {
		let t = &mut painter.textures[self.0];
		t.texture.destroy();
	}

	pub(crate) fn prepare_view(&self, painter: &mut Painter, key: TexViewKey) {
		let t = &painter.textures[self.0];
		if !t.views.contains_key(&key) {
			let view = key.make_view(&t.texture);
			painter.textures[self.0].views.insert(key, view);
		}
	}

	pub(crate) fn prepare_mip_level_views(&self, painter: &mut Painter) {
		let t = &painter.textures[self.0].texture;
		for i in 1..t.mip_level_count() {
			self.prepare_view(painter, TexViewKey::AtMipLevel(i));
		}
	}

	pub(crate) fn view<'a>(&self, painter: &'a Painter, key: &TexViewKey) -> &'a wgpu::TextureView {
		painter.textures[self.0].views.get(key).unwrap()
	}

	pub(crate) fn source_view<'a>(&'a self, painter: &'a Painter) -> &'a wgpu::TextureView {
		self.view(painter, &TexViewKey::WithAllMips)
	}

	pub(crate) fn target_view<'a>(&self, painter: &'a Painter) -> &'a wgpu::TextureView {
		self.view(painter, &TexViewKey::AtMipLevel(0))
	}

	pub fn update_mips(&self, painter: &Painter) {
		let t = &painter.textures[self.0].texture;
		if t.mip_level_count() > 1 {
			let texture = &t.clone();
			generate_mipmap_2d(painter, texture);
		}
	}

	pub fn get_mip_level_count(&self, painter: &Painter) -> u32 {
		painter.textures[self.0].texture.mip_level_count()
	}
}
</file>

<file path="src/window_dimensions.rs">
#[cfg(not(target_arch = "wasm32"))]
use serde::{Deserialize, Serialize};
#[cfg(not(target_arch = "wasm32"))]
use std::{fs, path::PathBuf};
#[cfg(not(target_arch = "wasm32"))]
use winit::dpi::{PhysicalPosition, PhysicalSize};

#[cfg(not(target_arch = "wasm32"))]
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct WindowDimensions {
	pub size: (u32, u32),
	pub position: (i32, i32),
}

#[cfg(not(target_arch = "wasm32"))]
impl WindowDimensions {
	pub fn get_state_path() -> PathBuf {
		let mut path = dirs::config_dir().unwrap_or_else(|| PathBuf::from("."));
		path.push("rust-graphics");
		path.push("window-state.json");
		path
	}

	pub fn load() -> Option<Self> {
		let path = Self::get_state_path();
		fs::read_to_string(path)
			.ok()
			.and_then(|json| serde_json::from_str(&json).ok())
	}

	pub fn save(&self) -> std::io::Result<()> {
		let path = Self::get_state_path();
		fs::create_dir_all(path.parent().unwrap())?;
		let json = serde_json::to_string(self)?;
		fs::write(path, json)
	}

	pub fn from_window(size: PhysicalSize<u32>, position: PhysicalPosition<i32>) -> Self {
		Self {
			size: (size.width, size.height),
			position: (position.x, position.y),
		}
	}

	pub fn cleanup() -> std::io::Result<()> {
		let path = Self::get_state_path();
		if path.exists() {
			fs::remove_file(path)?;
		}
		Ok(())
	}
}
</file>

<file path="Cargo.toml">
[package]
name = "trivalibs-painter"
version = "0.1.0"
edition.workspace = true

[dependencies]
trivalibs-core = { path = "../trivalibs_core" }
bytemuck.workspace = true
winit.workspace = true
wgpu.workspace = true
log.workspace = true
env_logger.workspace = true
pollster.workspace = true
notify.workspace = true
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
dirs = "5.0"
web-time = "1.0"

[target.'cfg(target_arch = "wasm32")'.dependencies]
wasm-bindgen-futures = "0.4"
web-sys = { version = "0.3", features = ["HtmlCanvasElement", "CssStyleDeclaration", "Document", "Element", "HtmlElement", "Node", "Window"] }
console_error_panic_hook = "0.1"
console_log = "1"
</file>

</files>
