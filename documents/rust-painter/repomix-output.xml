This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
crates/
  trivalibs/
    src/
      common_utils/
        camera_controls.rs
        mod.rs
      lib.rs
    Cargo.toml
  trivalibs_core/
    src/
      data/
        grid/
          mod.rs
          tests.rs
        neighbour_list/
          mod.rs
          tests.rs
          traits.rs
        mod.rs
        vertex_index.rs
      math/
        geometry/
          mod.rs
        interpolation/
          mod.rs
        transform/
          mod.rs
        coords.rs
        fit.rs
        mod.rs
        noise.rs
      rendering/
        camera/
          mod.rs
        line_2d/
          buffered_geometry.rs
          mod.rs
          tests.rs
        mesh_geometry/
          mod.rs
          tests.rs
          utils.rs
        scene/
          mod.rs
        shapes/
          cuboid.rs
          mod.rs
          quad.rs
          sphere.rs
        texture/
          mod.rs
        webgl_buffered_geometry/
          mod.rs
        mod.rs
      utils/
        app_state.rs
        mod.rs
        rand_utils.rs
      wasm_helpers/
        mod.rs
      lib.rs
      macros.rs
    Cargo.toml
  trivalibs_macros/
    src/
      lib.rs
    Cargo.toml
  trivalibs_nostd/
    src/
      random/
        hash.rs
        mod.rs
        simplex.rs
      bits.rs
      blur.rs
      color.rs
      coords.rs
      lib.rs
      num_ext.rs
      vec_ext.rs
    Cargo.toml
  trivalibs_painter/
    src/
      utils/
        input_state.rs
        mod.rs
      app.rs
      bind_group.rs
      binding_constants.rs
      binding.rs
      effect.rs
      events.rs
      form.rs
      layer.rs
      lib.rs
      painter.rs
      pipeline.rs
      sampler.rs
      shade.rs
      shaders.rs
      shape.rs
      texture_utils.rs
      texture.rs
      window_dimensions.rs
    Cargo.toml
examples/
  ball/
    shader/
      src/
        lib.rs
      Cargo.toml
      fragment.spv
      manifest.json
      vertex.spv
    geom.rs
    main.rs
    texture.png
  base_effect/
    shader/
      src/
        lib.rs
      Cargo.toml
      main.spv
      manifest.json
    main.rs
  blur/
    shader/
      src/
        lib.rs
      blur_fs.spv
      Cargo.toml
      manifest.json
      triangle_fs.spv
      triangle_vs.spv
    main.rs
  deferred_light/
    shader/
      src/
        lib.rs
      Cargo.toml
      light_fs.spv
      manifest.json
      scene_fs.spv
      scene_vs.spv
    geom.rs
    main.rs
  dynamic_shapes/
    shader/
      src/
        lib.rs
      Cargo.toml
      effect_fragment.spv
      fragment.spv
      manifest.json
      vertex.spv
    main.rs
  dynamic_texture/
    shader/
      src/
        lib.rs
      Cargo.toml
      col_fs.spv
      manifest.json
      tex_fs.spv
    main.rs
  geometries/
    shader/
      src/
        lib.rs
      Cargo.toml
      ground_frag.spv
      ground_vert.spv
      manifest.json
    main.rs
  instances/
    shader/
      src/
        lib.rs
      Cargo.toml
      fragment.spv
      manifest.json
      vertex.spv
    main.rs
  layer_tex/
    shader/
      src/
        lib.rs
      Cargo.toml
      color_fs.spv
      color_vs.spv
      manifest.json
      texture_fs.spv
      texture_vs.spv
    main.rs
  mipmap/
    shader/
      src/
        lib.rs
      Cargo.toml
      image.spv
      manifest.json
      mip_sampling.spv
      wave_effect.spv
    main.rs
  mouse_color/
    main.rs
  noise_tests/
    shader/
      src/
        lib.rs
      Cargo.toml
      hash_shader.spv
      manifest.json
      simplex_2d_shader.spv
      simplex_3d_shader.spv
      simplex_4d_shader.spv
      tiling_noise_2d_shader.spv
      tiling_noise_3d_shader.spv
      tiling_simplex_shader.spv
    main.rs
  random_lines/
    shader/
      src/
        lib.rs
      Cargo.toml
      fragment.spv
      manifest.json
      vertex.spv
    main.rs
  render_to_mip/
    shader/
      src/
        lib.rs
      Cargo.toml
      image.spv
      manifest.json
      mip_sampling.spv
    main.rs
  shader_image/
    shader/
      src/
        lib.rs
      Cargo.toml
      main_fs.spv
      main_vs.spv
      manifest.json
    main.rs
    output.png
  simple_triangle/
    shader/
      src/
        lib.rs
      Cargo.toml
      fragment.spv
      manifest.json
      vertex.spv
    main.rs
  triangle/
    shader/
      src/
        lib.rs
      Cargo.toml
      fragment.spv
      manifest.json
      vertex.spv
    src/
      main.rs
    Cargo.toml
    texture.png
  user_event/
    shader/
      src/
        lib.rs
      Cargo.toml
      fragment.spv
      manifest.json
      vertex.spv
    main.rs
.editorconfig
.gitignore
Cargo.toml
LICENSE
painter_technical_overview.md
README.md
run_all_examples.sh
rustfmt.toml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="crates/trivalibs/src/common_utils/mod.rs">
pub mod camera_controls;
</file>

<file path="crates/trivalibs_core/src/data/grid/tests.rs">
use lerp::Lerp;
⋮----
struct Coord(i32, i32);
⋮----
struct CoordF(f32, f32);
⋮----
fn lerp(self, other: Self, t: f32) -> Self {
CoordF(self.0.lerp(other.0, t), self.1.lerp(other.1, t))
⋮----
fn fill_grid<C: CoordOpsFn>(mut grid: Grid<Coord, C>) -> Grid<Coord, C> {
⋮----
let mut col = vec![];
⋮----
col.push(Coord(x, y));
⋮----
grid.add_col(col);
⋮----
fn get_set_clamp() {
let mut grid = fill_grid(make_grid());
⋮----
assert_eq!(grid.get(1, 1), &Coord(1, 1));
assert_eq!(grid.get(4, 4), &Coord(2, 2));
assert_eq!(grid.get(-2, -2), &Coord(0, 0));
⋮----
grid.set(1, 1, Coord(5, 5));
assert_eq!(grid.get(1, 1), &Coord(5, 5));
⋮----
grid.set(-1, -1, Coord(6, 6));
assert_eq!(grid.get(0, 0), &Coord(6, 6));
⋮----
grid.set(4, 4, Coord(7, 7));
assert_eq!(grid.get(2, 2), &Coord(7, 7));
⋮----
fn get_set_circle_all() {
let mut grid = fill_grid(make_grid_with_coord_ops(CIRCLE_ALL_COORD_OPS));
⋮----
assert_eq!(grid.get(4, 4), &Coord(1, 1));
assert_eq!(grid.get(-2, -2), &Coord(1, 1));
assert_eq!(grid.get(-1, -1), &Coord(2, 2));
⋮----
assert_eq!(grid.get(4, 4), &Coord(5, 5));
assert_eq!(grid.get(-2, -2), &Coord(5, 5));
⋮----
assert_eq!(grid.get(2, 2), &Coord(6, 6));
⋮----
assert_eq!(grid.get(1, 1), &Coord(7, 7));
⋮----
fn fill_grid_rows_cols() {
let mut grid1 = make_grid();
assert_eq!(grid1.width, 0);
assert_eq!(grid1.height, 0);
⋮----
grid1.add_col(vec![Coord(0, 0), Coord(0, 1), Coord(0, 2)]);
assert_eq!(grid1.width, 1);
assert_eq!(grid1.height, 3);
assert_eq!(*grid1.get(0, 2), Coord(0, 2));
⋮----
grid1.add_row(vec![Coord(0, 3)]);
⋮----
assert_eq!(grid1.height, 4);
assert_eq!(*grid1.get(0, 3), Coord(0, 3));
assert_eq!(*grid1.get(1, 3), Coord(0, 3));
⋮----
let mut grid2 = make_grid();
assert_eq!(grid2.width, 0);
assert_eq!(grid2.height, 0);
⋮----
grid2.add_row(vec![Coord(0, 0), Coord(1, 0), Coord(2, 0)]);
assert_eq!(grid2.width, 3);
assert_eq!(grid2.height, 1);
assert_eq!(*grid2.get(1, 0), Coord(1, 0));
assert_eq!(*grid2.get(2, 0), Coord(2, 0));
⋮----
grid2.add_col(vec![Coord(3, 0)]);
assert_eq!(grid2.width, 4);
⋮----
assert_eq!(*grid2.get(3, 0), Coord(3, 0));
assert_eq!(*grid2.get(3, 1), Coord(3, 0));
⋮----
fn grid_vertices() {
let grid = fill_grid(make_grid_with_coord_ops(CIRCLE_ALL_COORD_OPS));
let v = grid.vertex(0, 0);
⋮----
assert_eq!(v.x, 0);
assert_eq!(v.y, 0);
assert_eq!(v.val, Coord(0, 0));
⋮----
let v = v.right().unwrap();
assert_eq!(v.x, 1);
⋮----
assert_eq!(v.val, Coord(1, 0));
⋮----
assert_eq!(v.x, 2);
⋮----
assert_eq!(v.val, Coord(2, 0));
⋮----
let v = v.bottom().unwrap();
⋮----
assert_eq!(v.y, 1);
assert_eq!(v.val, Coord(0, 1));
⋮----
assert_eq!(v.y, 2);
assert_eq!(v.val, Coord(0, 2));
⋮----
let v = v.top().unwrap();
⋮----
let v = v.left().unwrap();
⋮----
assert_eq!(v.val, Coord(2, 2));
⋮----
assert_eq!(v.val, Coord(2, 1));
⋮----
assert_eq!(v.val, Coord(1, 1));
⋮----
fn test_grid_map() {
let grid1 = fill_grid(make_grid());
let grid2 = grid1.map(|vert| Coord(vert.val.0 + vert.x as i32, vert.val.1 + vert.y as i32));
assert_eq!(*grid2.get(0, 0), Coord(0, 0));
assert_eq!(*grid2.get(1, 1), Coord(2, 2));
assert_eq!(*grid1.get(1, 1), Coord(1, 1));
assert_eq!(*grid2.get(2, 2), Coord(4, 4));
assert_eq!(*grid1.get(2, 2), Coord(2, 2));
assert_eq!(*grid2.get(2, 1), Coord(4, 2));
⋮----
fn rows_and_cols() {
let grid = fill_grid(make_grid());
assert_eq!(*grid.col(1), vec![Coord(1, 0), Coord(1, 1), Coord(1, 2)]);
assert_eq!(*grid.col(4), *grid.col(2));
assert_eq!(*grid.col(-1), *grid.col(0));
⋮----
assert_eq!(grid.row(1), vec![Coord(0, 1), Coord(1, 1), Coord(2, 1)]);
assert_eq!(grid.row(4), grid.row(2));
assert_eq!(grid.row(-1), grid.row(0));
⋮----
fn flat_map() {
⋮----
let grid2 = grid.flat_map_cols(|col| {
⋮----
.iter()
.map(|vert| {
CoordF(
(vert.val.0 as f32 + vert.right().unwrap().val.0 as f32) / 2.0,
⋮----
.collect();
⋮----
vec![
⋮----
assert_eq!(grid2.width, 6);
assert_eq!(grid2.height, 3);
⋮----
assert_eq!(*grid2.get(0, y), CoordF(0.0, y as f32));
assert_eq!(*grid2.get(1, y), CoordF(0.5, y as f32));
assert_eq!(*grid2.get(2, y), CoordF(1.0, y as f32));
assert_eq!(*grid2.get(3, y), CoordF(1.5, y as f32));
assert_eq!(*grid2.get(4, y), CoordF(2.0, y as f32));
assert_eq!(*grid2.get(5, y), CoordF(1.0, y as f32));
⋮----
let grid2 = grid.flat_map_rows(|row| {
⋮----
(vert.val.1 as f32 + vert.bottom().unwrap().val.1 as f32) / 2.0,
⋮----
assert_eq!(grid2.height, 6);
⋮----
assert_eq!(*grid2.get(x, 0), CoordF(x as f32, 0.0));
assert_eq!(*grid2.get(x, 1), CoordF(x as f32, 0.5));
assert_eq!(*grid2.get(x, 2), CoordF(x as f32, 1.0));
assert_eq!(*grid2.get(x, 3), CoordF(x as f32, 1.5));
assert_eq!(*grid2.get(x, 4), CoordF(x as f32, 2.0));
assert_eq!(*grid2.get(x, 5), CoordF(x as f32, 1.0));
⋮----
fn subdivide() {
let mut grid = make_grid();
grid.add_col(vec![CoordF(0.0, 0.0), CoordF(0.0, 1.0)]);
grid.add_col(vec![CoordF(1.0, 0.0), CoordF(1.0, 1.0)]);
⋮----
let grid1 = grid.subdivide(1, 1);
assert_eq!(grid1.width, 3);
⋮----
assert_eq!(*grid1.get(0, 0), CoordF(0.0, 0.0));
assert_eq!(*grid1.get(0, 2), CoordF(0.0, 1.0));
assert_eq!(*grid1.get(2, 0), CoordF(1.0, 0.0));
assert_eq!(*grid1.get(2, 2), CoordF(1.0, 1.0));
assert_eq!(*grid1.get(0, 1), CoordF(0.0, 0.5));
assert_eq!(*grid1.get(1, 1), CoordF(0.5, 0.5));
assert_eq!(*grid1.get(2, 1), CoordF(1.0, 0.5));
assert_eq!(*grid1.get(1, 0), CoordF(0.5, 0.0));
assert_eq!(*grid1.get(1, 2), CoordF(0.5, 1.0));
⋮----
let grid2 = grid.subdivide(3, 0);
assert_eq!(grid2.width, 5);
assert_eq!(grid2.height, 2);
assert_eq!(*grid2.get(0, 0), CoordF(0.0, 0.0));
assert_eq!(*grid2.get(1, 0), CoordF(0.25, 0.0));
assert_eq!(*grid2.get(2, 0), CoordF(0.5, 0.0));
assert_eq!(*grid2.get(3, 0), CoordF(0.75, 0.0));
assert_eq!(*grid2.get(4, 0), CoordF(1.0, 0.0));
assert_eq!(*grid2.get(0, 1), CoordF(0.0, 1.0));
assert_eq!(*grid2.get(1, 1), CoordF(0.25, 1.0));
assert_eq!(*grid2.get(2, 1), CoordF(0.5, 1.0));
assert_eq!(*grid2.get(3, 1), CoordF(0.75, 1.0));
assert_eq!(*grid2.get(4, 1), CoordF(1.0, 1.0));
⋮----
let grid3 = grid.subdivide(0, 1);
assert_eq!(grid3.width, 2);
assert_eq!(grid3.height, 3);
assert_eq!(*grid3.get(0, 0), CoordF(0.0, 0.0));
assert_eq!(*grid3.get(1, 2), CoordF(1.0, 1.0));
assert_eq!(*grid3.get(0, 1), CoordF(0.0, 0.5));
assert_eq!(*grid3.get(1, 1), CoordF(1.0, 0.5));
⋮----
let mut grid_circle = make_grid_with_coord_ops(CIRCLE_ALL_COORD_OPS);
grid_circle.add_col(vec![CoordF(0.0, 0.0), CoordF(0.0, 1.0)]);
grid_circle.add_col(vec![CoordF(1.0, 0.0), CoordF(1.0, 1.0)]);
⋮----
let grid4 = grid_circle.subdivide(1, 1);
assert_eq!(grid4.width, 4);
assert_eq!(grid4.height, 4);
assert_eq!(*grid4.get(0, 0), CoordF(0.0, 0.0));
assert_eq!(*grid4.get(1, 0), CoordF(0.5, 0.0));
assert_eq!(*grid4.get(2, 0), CoordF(1.0, 0.0));
assert_eq!(*grid4.get(3, 0), CoordF(0.5, 0.0));
assert_eq!(*grid4.get(0, 1), CoordF(0.0, 0.5));
assert_eq!(*grid4.get(0, 2), CoordF(0.0, 1.0));
assert_eq!(*grid4.get(0, 3), CoordF(0.0, 0.5));
</file>

<file path="crates/trivalibs_core/src/data/neighbour_list/mod.rs">
pub mod traits;
⋮----
pub trait AdjustToNextNeighbour {
⋮----
pub struct NeighbourList<T: AdjustToNextNeighbour> {
⋮----
pub struct NeighbourListNode<T: AdjustToNextNeighbour> {
⋮----
pub struct NeighbourListIter<'a, T: AdjustToNextNeighbour> {
⋮----
pub fn new(list: &'a NeighbourList<T>) -> Self {
⋮----
impl<'a, T: AdjustToNextNeighbour> Iterator for NeighbourListIter<'a, T> {
type Item = &'a NeighbourListNode<T>;
⋮----
fn next(&mut self) -> Option<Self::Item> {
⋮----
return Some(node);
⋮----
impl<'a, T: AdjustToNextNeighbour> DoubleEndedIterator for NeighbourListIter<'a, T> {
fn next_back(&mut self) -> Option<Self::Item> {
⋮----
pub struct NeighbourListValsIter<'a, T: AdjustToNextNeighbour> {
⋮----
impl<'a, T: AdjustToNextNeighbour> Iterator for NeighbourListValsIter<'a, T> {
type Item = &'a T;
⋮----
return Some(&node.val);
⋮----
impl<'a, T: AdjustToNextNeighbour> DoubleEndedIterator for NeighbourListValsIter<'a, T> {
⋮----
pub struct NeighbourListIterMut<'a, T: AdjustToNextNeighbour> {
⋮----
pub fn new(list: &'a mut NeighbourList<T>) -> Self {
⋮----
impl<'a, T: AdjustToNextNeighbour> Iterator for NeighbourListIterMut<'a, T> {
type Item = &'a mut NeighbourListNode<T>;
⋮----
return Some(std::mem::transmute(node));
⋮----
impl<'a, T: AdjustToNextNeighbour> DoubleEndedIterator for NeighbourListIterMut<'a, T> {
⋮----
pub fn new() -> Self {
⋮----
pub fn append(&mut self, val: T) -> &Self {
let idx = self.nodes.len();
⋮----
prev: Some(last_idx),
⋮----
last_node.val.adjust_to_next(&new_node.val);
last_node.next = Some(idx);
⋮----
self.nodes.push(new_node);
⋮----
self.first = Some(idx);
self.nodes.push(NeighbourListNode {
⋮----
self.last = Some(idx);
⋮----
pub fn append_at(&mut self, curr_idx: usize, val: T) -> &Self {
⋮----
next: Some(next_idx),
prev: Some(prev_idx),
⋮----
next_node.prev = Some(idx);
⋮----
new_node.val.adjust_to_next(&next_node.val);
⋮----
prev_node.next = Some(idx);
⋮----
prev_node.val.adjust_to_next(&new_node.val);
⋮----
return self.append(val);
⋮----
pub fn len(&self) -> usize {
self.nodes.len()
⋮----
pub fn iter(&self) -> NeighbourListIter<'_, T> {
⋮----
pub fn vals(&self) -> NeighbourListValsIter<'_, T> {
⋮----
pub fn iter_mut(&mut self) -> NeighbourListIterMut<'_, T> {
⋮----
pub fn first(&self) -> Option<&NeighbourListNode<T>> {
self.first.and_then(|idx| self.nodes.get(idx))
⋮----
pub fn last(&self) -> Option<&NeighbourListNode<T>> {
self.last.and_then(|idx| self.nodes.get(idx))
⋮----
pub fn next(&self, curr_idx: usize) -> Option<&NeighbourListNode<T>> {
⋮----
.and_then(|idx| self.nodes.get(idx))
⋮----
pub fn prev(&self, curr_idx: usize) -> Option<&NeighbourListNode<T>> {
⋮----
pub fn first_mut(&mut self) -> Option<&mut NeighbourListNode<T>> {
self.first.map(|idx| &mut self.nodes[idx])
⋮----
pub fn last_mut(&mut self) -> Option<&mut NeighbourListNode<T>> {
self.last.map(|idx| &mut self.nodes[idx])
⋮----
pub fn next_mut(&mut self, curr_idx: usize) -> Option<&mut NeighbourListNode<T>> {
self.nodes[curr_idx].next.map(|idx| &mut self.nodes[idx])
⋮----
pub fn prev_mut(&mut self, curr_idx: usize) -> Option<&mut NeighbourListNode<T>> {
self.nodes[curr_idx].prev.map(|idx| &mut self.nodes[idx])
⋮----
pub fn adjust_all(self) -> Self {
todo!()
⋮----
impl<T: AdjustToNextNeighbour> PartialEq for NeighbourListNode<T> {
fn eq(&self, other: &Self) -> bool {
⋮----
impl<'a, T> IntoIterator for &'a NeighbourList<T>
⋮----
type IntoIter = NeighbourListValsIter<'a, T>;
⋮----
fn into_iter(self) -> Self::IntoIter {
self.vals()
⋮----
fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {
⋮----
list.append(item);
⋮----
mod tests;
</file>

<file path="crates/trivalibs_core/src/data/neighbour_list/tests.rs">
use super::traits::NeighbourMapTransform;
⋮----
struct Item {
⋮----
impl AdjustToNextNeighbour for Item {
fn adjust_to_next(&mut self, next: &Self) {
⋮----
fn item(idx: u8) -> Item {
⋮----
fn item_next(number: u8, next: u8) -> Item {
⋮----
fn create_append_and_iter() {
⋮----
assert_eq!(list.first(), None);
assert_eq!(list.last(), None);
assert_eq!(list.iter().nth(0), None);
assert_eq!(list.iter().nth_back(0), None);
⋮----
let item1 = item(1);
list.append(item1);
⋮----
assert_eq!(list.first().unwrap().val, item1);
assert_eq!(list.last().unwrap().val, item1);
assert_eq!(list.iter().nth(0).unwrap().val, item1);
assert_eq!(list.iter().nth_back(0).unwrap().val, item1);
⋮----
let item2 = item(2);
list.append(item2);
⋮----
assert_eq!(list.first().unwrap().val, item_next(1, 2));
assert_eq!(list.last().unwrap().val, item2);
⋮----
let item3 = item(3);
list.append(item3);
⋮----
assert_eq!(list.last().unwrap().val, item3);
⋮----
assert_eq!(
⋮----
assert_eq!(list.iter().nth(0).unwrap().val, item_next(1, 2));
assert_eq!(list.iter().nth(1).unwrap().val, item_next(2, 3));
assert_eq!(list.iter().nth(2).unwrap().val, item3);
⋮----
assert_eq!(list.iter().nth_back(0).unwrap().val, item3);
assert_eq!(list.iter().nth_back(1).unwrap().val, item_next(2, 3));
assert_eq!(list.iter().nth_back(2).unwrap().val, item_next(1, 2));
⋮----
.iter()
.map_with_prev_next(|curr, prev, next| {
⋮----
+ prev.map(|p| p.val.number).unwrap_or(0)
+ next.map(|n| n.val.number).unwrap_or(0)
⋮----
assert_eq!(v, [3, 6, 5]);
⋮----
.map(|n| n.val.number)
.map_with_prev_next(|curr, prev, next| curr + prev.unwrap_or(0) + next.unwrap_or(0))
⋮----
fn mutable_iterator() {
⋮----
for item in list.iter_mut() {
⋮----
assert_eq!(list.iter().nth(0).unwrap().val.number, 2);
assert_eq!(list.iter().nth(1).unwrap().val.number, 4);
assert_eq!(list.iter().nth(2).unwrap().val.number, 6);
⋮----
fn append_at() {
⋮----
let item1 = item(10);
let item2 = item(20);
let item3 = item(30);
⋮----
list.append_at(list.first().unwrap().idx, item(15));
list.append_at(list.last().unwrap().idx, item(35));
list.append_at(list.iter().nth(2).unwrap().idx, item(25));
⋮----
fn from_iter() {
⋮----
.map(|n| item(n * 10))
⋮----
assert_eq!(list.first().unwrap().val, item_next(10, 20));
assert_eq!(list.last().unwrap().val, item(30));
⋮----
fn into_iter_and_vals() {
⋮----
list.append(item(1));
list.append(item(2));
list.append(item(3));
⋮----
let mut vec = vec![];
⋮----
vec.push(i.number);
⋮----
assert_eq!(vec, [1, 2, 3]);
⋮----
let vec = list.vals().map(|i| i.number).collect::<Vec<_>>();
assert_eq!(vec, [1, 2, 3])
</file>

<file path="crates/trivalibs_core/src/data/neighbour_list/traits.rs">
use std::iter::Flatten;
⋮----
// With Neighbour iterator
⋮----
pub struct WithNeighbours<I>
⋮----
fn new(iter: I) -> Self {
⋮----
impl<T, I> Iterator for WithNeighbours<I>
⋮----
type Item = (Option<T>, T, Option<T>);
⋮----
fn next(&mut self) -> Option<Self::Item> {
if self.prev.is_none() && self.curr.is_none() {
self.curr = self.iter.next();
self.next = self.iter.next();
⋮----
self.prev = self.curr.clone();
self.curr = self.next.clone();
⋮----
if let Some(r) = self.curr.clone() {
Some((self.prev.clone(), r, self.next.clone()))
⋮----
pub trait WithNeighboursTransform: Iterator + Sized {
⋮----
impl<I> WithNeighboursTransform for I
⋮----
fn with_neighbours(self) -> WithNeighbours<Self> {
⋮----
// Map iterator
⋮----
pub struct NeighbourMap<I, F>
⋮----
fn new(iter: I, f: F) -> Self {
⋮----
impl<T, I, F, B> Iterator for NeighbourMap<I, F>
⋮----
type Item = B;
⋮----
Some(f(r, self.prev.clone(), self.next.clone()))
⋮----
pub trait NeighbourMapTransform: Iterator + Sized {
⋮----
impl<I> NeighbourMapTransform for I
⋮----
fn map_with_prev_next<F, B>(self, f: F) -> NeighbourMap<I, F>
⋮----
// Flatmap on iterator
⋮----
pub struct NeighbourFlatMap<T, I, U, F>
⋮----
pub fn new(iter: I, f: F) -> NeighbourFlatMap<T, I, U, F> {
⋮----
inner: NeighbourMap::new(iter, f).flatten(),
⋮----
impl<T, I, U, F> Iterator for NeighbourFlatMap<T, I, U, F>
⋮----
type Item = U::Item;
⋮----
self.inner.next()
⋮----
pub trait NeighbourFlatMapTransform: Iterator + Sized {
⋮----
impl<T, I> NeighbourFlatMapTransform for I
⋮----
fn flat_map_with_prev_next<F, U>(self, f: F) -> NeighbourFlatMap<I::Item, I, U, F>
⋮----
// Tests
⋮----
mod tests {
⋮----
fn test_map_with_prev_next() {
let v = vec![1, 2, 3];
⋮----
.iter()
.map_with_prev_next(|curr, prev, next| curr + prev.unwrap_or(&0) + next.unwrap_or(&0))
⋮----
assert_eq!(res, [3, 6, 5]);
⋮----
.map_with_prev_next(|curr, prev, next| (prev.map(|x| *x), *curr, next.map(|x| *x)))
⋮----
assert_eq!(
⋮----
struct SomeBox {
⋮----
impl Clone for SomeBox {
fn clone(&self) -> Self {
⋮----
val: self.val.clone(),
count: self.count.clone() + 1,
⋮----
fn make_box(val: usize) -> SomeBox {
⋮----
fn test_does_not_clone_ref_values() {
let v = vec![make_box(1), make_box(2), make_box(3)];
⋮----
.map_with_prev_next(|curr, prev, next| SomeBox {
⋮----
+ prev.unwrap_or(&Default::default()).val
+ next.unwrap_or(&Default::default()).val,
⋮----
fn test_flat_map() {
⋮----
.flat_map_with_prev_next(|curr, prev, next| {
let mut vs = vec![];
⋮----
vs.push(*i);
⋮----
vs.push(*curr);
⋮----
assert_eq!(res, [1, 2, 1, 2, 3, 2, 3])
⋮----
fn with_neighbours() {
let v = vec![1, 2, 3, 4];
⋮----
let res = v.iter().with_neighbours().collect::<Vec<_>>();
</file>

<file path="crates/trivalibs_core/src/math/geometry/mod.rs">
use glam::Vec3;
⋮----
use super::transform::Transform;
⋮----
pub struct Ray {
⋮----
impl Ray {
pub fn at(&self, t: f32) -> Vec3 {
⋮----
pub struct Plane {
⋮----
pub struct Sphere {
⋮----
pub enum Axis {
⋮----
pub struct Extend {
⋮----
pub struct Bound {
⋮----
impl Bound {
pub fn is_behind(&self, _transform: &Transform, _plane: &Plane) -> bool {
todo!("Implement culling")
⋮----
pub fn intersects_ray(&self, _transform: &Transform, _ray: &Ray) -> bool {
todo!("Implement ray intersection")
⋮----
pub fn has_intersection_ray_sphere(r: &Ray, s: &Sphere) -> bool {
⋮----
let a = r.direction.length_squared();
let half_b = oc.dot(r.direction);
let c = oc.length_squared() - s.radius * s.radius;
⋮----
pub fn intersect_ray_sphere_within(r: &Ray, s: &Sphere, min: f32, max: f32) -> f32 {
⋮----
let dsqrt = discriminant.sqrt();
⋮----
pub fn intersect_ray_sphere(r: &Ray, s: &Sphere) -> f32 {
intersect_ray_sphere_within(r, s, 0.0, std::f32::INFINITY)
⋮----
pub fn has_intersection_normalized_ray_sphere(r: &Ray, s: &Sphere) -> bool {
⋮----
pub fn intersect_normalized_ray_sphere_within(r: &Ray, s: &Sphere, min: f32, max: f32) -> f32 {
⋮----
pub fn intersect_normalized_ray_sphere(r: &Ray, s: &Sphere) -> f32 {
intersect_normalized_ray_sphere_within(r, s, 0.0, std::f32::INFINITY)
</file>

<file path="crates/trivalibs_core/src/math/interpolation/mod.rs">
pub trait Interpolate {
/// Linear interpolation.
	fn lerp(t: f32, a: Self, b: Self) -> Self;
⋮----
/// Cosine interpolation.
	fn cosine(t: f32, a: Self, b: Self) -> Self;
⋮----
/// Quadratic Bézier interpolation.
	///
⋮----
///
	/// `a` is the first point; `b` is the second point and `u` is the tangent of `a` to the curve.
⋮----
/// `a` is the first point; `b` is the second point and `u` is the tangent of `a` to the curve.
	fn quadratic_bezier(t: f32, a: Self, u: Self, b: Self) -> Self;
⋮----
/// Cubic Bézier interpolation.
	///
⋮----
///
	/// `a` is the first point; `b` is the second point; `u` is the output tangent of `a` to the curve and `v` is the
⋮----
/// `a` is the first point; `b` is the second point; `u` is the output tangent of `a` to the curve and `v` is the
	/// input tangent of `b` to the curve.
⋮----
/// input tangent of `b` to the curve.
	fn cubic_bezier(t: f32, a: Self, u: Self, v: Self, b: Self) -> Self;
⋮----
macro_rules! impl_Interpolate {
⋮----
impl_Interpolate!(f32);
impl_Interpolate!(Vec2);
impl_Interpolate!(Vec3);
</file>

<file path="crates/trivalibs_core/src/math/coords.rs">
use glam::Vec3;
⋮----
/// Converts cartesian coordinates to spherical angles.
///
⋮----
///
/// # Arguments
⋮----
/// # Arguments
///
⋮----
///
/// * `horizontal_angle` - The horizontal angle in range of 0 to 2 PI. Turns counter clock wise. Starts at -Z axis.
⋮----
/// * `horizontal_angle` - The horizontal angle in range of 0 to 2 PI. Turns counter clock wise. Starts at -Z axis.
/// * `vertical_angle` - The vertical angle in range of -PI/2 to PI/2.
⋮----
/// * `vertical_angle` - The vertical angle in range of -PI/2 to PI/2.
pub fn angles_to_cartesian(horizontal_angle: f32, vertical_angle: f32) -> Vec3 {
⋮----
pub fn angles_to_cartesian(horizontal_angle: f32, vertical_angle: f32) -> Vec3 {
let x = vertical_angle.cos() * horizontal_angle.sin();
let y = vertical_angle.sin();
let z = vertical_angle.cos() * horizontal_angle.cos();
</file>

<file path="crates/trivalibs_core/src/math/fit.rs">
pub fn fit1101(x: f32) -> f32 {
⋮----
pub fn fit0111(x: f32) -> f32 {
⋮----
pub trait Fit {
⋮----
impl Fit for f32 {
fn fit0111(self) -> Self {
fit0111(self)
⋮----
fn fit1101(self) -> Self {
fit1101(self)
⋮----
impl Fit for Vec2 {
⋮----
vec2(self.x.fit0111(), self.y.fit0111())
⋮----
vec2(self.x.fit1101(), self.y.fit1101())
⋮----
impl Fit for Vec3 {
⋮----
vec3(self.x.fit0111(), self.y.fit0111(), self.z.fit0111())
⋮----
vec3(self.x.fit1101(), self.y.fit1101(), self.z.fit1101())
</file>

<file path="crates/trivalibs_core/src/math/mod.rs">
pub mod coords;
pub mod fit;
pub mod geometry;
pub mod interpolation;
pub mod noise;
pub mod transform;
</file>

<file path="crates/trivalibs_core/src/math/noise.rs">
// Code included from https://github.com/johanhelsing/noisy_bevy
⋮----
fn permute_3(x: Vec3) -> Vec3 {
⋮----
// MIT License. © Ian McEwan, Stefan Gustavson, Munrocket, Johan Helsing
/// Simplex noise in two dimensions
pub fn simplex_noise_2d(v: Vec2) -> f32 {
⋮----
pub fn simplex_noise_2d(v: Vec2) -> f32 {
const C: Vec4 = vec4(
0.211_324_87,  // (3.0 - sqrt(3.0)) / 6.0
0.366_025_42,  // 0.5 * (sqrt(3.0) - 1.0)
-0.577_350_26, // -1.0 + 2.0 * C.x
⋮----
let mut i: Vec2 = (v + Vec2::dot(v, C.yy())).floor();
let x0 = v - i + Vec2::dot(i, C.xx());
⋮----
vec2(1., 0.)
⋮----
vec2(0., 1.)
⋮----
let x12: Vec4 = x0.xyxy() + C.xxzz() - vec4(i1.x, i1.y, 0., 0.);
⋮----
let p = permute_3(permute_3(i.y + vec3(0., i1.y, 1.)) + i.x + vec3(0., i1.x, 1.));
⋮----
0.5 - vec3(
⋮----
Vec2::dot(x12.xy(), x12.xy()),
Vec2::dot(x12.zw(), x12.zw()),
⋮----
let x = 2. * (p * C.www()).fract() - 1.;
let h = x.abs() - 0.5;
let ox = (x + 0.5).floor();
⋮----
let g = vec3(
⋮----
/// Simplex noise in two dimensions
pub fn simplex_noise_2d_seeded(v: Vec2, seed: f32) -> f32 {
⋮----
pub fn simplex_noise_2d_seeded(v: Vec2, seed: f32) -> f32 {
⋮----
// first corner
⋮----
// other corners
⋮----
// permutations
⋮----
let mut p = permute_3(permute_3(i.y + vec3(0., i1.y, 1.)) + i.x + vec3(0., i1.x, 1.));
p = permute_3(p + Vec3::splat(seed));
⋮----
// gradients: 41 points uniformly over a line, mapped onto a diamond
// the ring size, 17*17 = 289, is close to a multiple of 41 (41*7 = 287)
⋮----
// normalize gradients implicitly by scaling m
// approximation of: m *= inversesqrt(a0 * a0 + h * h);
⋮----
// compute final noise value at P
⋮----
fn permute_4(x: Vec4) -> Vec4 {
⋮----
fn taylor_inv_sqrt_4(r: Vec4) -> Vec4 {
⋮----
fn step_4(edge: Vec4, x: Vec4) -> Vec4 {
⋮----
fn step_3(edge: Vec3, x: Vec3) -> Vec3 {
⋮----
/// Simplex noise in three dimensions
pub fn simplex_noise_3d(v: Vec3) -> f32 {
⋮----
pub fn simplex_noise_3d(v: Vec3) -> f32 {
const C: Vec2 = vec2(1. / 6., 1. / 3.);
const D: Vec4 = vec4(0., 0.5, 1., 2.);
⋮----
let mut i = (v + Vec3::dot(v, C.yyy())).floor();
let x0 = v - i + Vec3::dot(i, C.xxx());
⋮----
let g = step_3(x0.yzx(), x0.xyz());
⋮----
let i1 = Vec3::min(g.xyz(), l.zxy());
let i2 = Vec3::max(g.xyz(), l.zxy());
⋮----
// x0 = x0 - 0. + 0. * C
let x1 = x0 - i1 + 1. * C.xxx();
let x2 = x0 - i2 + 2. * C.xxx();
let x3 = x0 - 1. + 3. * C.xxx();
⋮----
let p = permute_4(
permute_4(permute_4(i.z + vec4(0., i1.z, i2.z, 1.)) + i.y + vec4(0., i1.y, i2.y, 1.))
+ i.x + vec4(0., i1.x, i2.x, 1.),
⋮----
// gradients (NxN points uniformly over a square, mapped onto an octahedron)
let n_ = 1. / 7.; // N=7
let ns = n_ * D.wyz() - D.xzx();
⋮----
let j = p - 49. * (p * ns.z * ns.z).floor(); // mod(p, N*N)
⋮----
let x_ = (j * ns.z).floor();
let y_ = (j - 7. * x_).floor(); // mod(j, N)
⋮----
let x = x_ * ns.x + ns.yyyy();
let y = y_ * ns.x + ns.yyyy();
let h = 1. - x.abs() - y.abs();
⋮----
let b0 = vec4(x.x, x.y, y.x, y.y);
let b1 = vec4(x.w, x.w, y.z, y.w);
⋮----
let s0 = b0.floor() * 2. + 1.;
let s1 = b1.floor() * 2. + 1.;
let sh = -step_4(h, Vec4::splat(0.));
⋮----
let a0 = b0.xzyw() + s0.xzyw() * sh.xxyy();
let a1 = b1.xzyw() + s1.xzyw() * sh.zzww();
⋮----
let mut p0 = a0.xy().extend(h.x);
let mut p1 = a0.zw().extend(h.y);
let mut p2 = a1.xy().extend(h.z);
let mut p3 = a1.zw().extend(h.w);
⋮----
// normalize gradients
let norm = taylor_inv_sqrt_4(vec4(
⋮----
// mix final noise value
⋮----
- vec4(
⋮----
vec4(
⋮----
/// Fractional brownian motion (fbm) based on 2d simplex noise
pub fn fbm_simplex_2d(pos: Vec2, octaves: usize, lacunarity: f32, gain: f32) -> f32 {
⋮----
pub fn fbm_simplex_2d(pos: Vec2, octaves: usize, lacunarity: f32, gain: f32) -> f32 {
⋮----
sum += simplex_noise_2d(pos * frequency) * amplitude;
⋮----
/// Fractional brownian motion (fbm) based on seeded 2d simplex noise
pub fn fbm_simplex_2d_seeded(
⋮----
pub fn fbm_simplex_2d_seeded(
⋮----
sum += simplex_noise_2d_seeded(pos * frequency, seed) * amplitude;
⋮----
/// Fractional brownian motion (fbm) based on 3d simplex noise
pub fn fbm_simplex_3d(pos: Vec3, octaves: usize, lacunarity: f32, gain: f32) -> f32 {
⋮----
pub fn fbm_simplex_3d(pos: Vec3, octaves: usize, lacunarity: f32, gain: f32) -> f32 {
⋮----
sum += simplex_noise_3d(pos * frequency) * amplitude;
⋮----
/// Cellular noise
pub fn worley_2d(pos: Vec2, jitter: f32) -> Vec2 {
⋮----
pub fn worley_2d(pos: Vec2, jitter: f32) -> Vec2 {
⋮----
// Determine the grid cell and fractional position
let pi = pos.floor();
let pf = pos.fract_gl();
⋮----
// Define offset indices for neighboring grid cells
let oi = vec3(-1.0, 0.0, 1.0);
let of_ = vec3(-0.5, 0.5, 1.5);
⋮----
// Permute the grid cell indices to get unique values for each cell
let px = permute_3(pi.x + oi);
let mut p = permute_3(px.x + pi.y + oi); // p11, p12, p13
⋮----
let mut ox = (p * K).fract_gl() - KO;
let mut oy = (p * K).floor() % 7.0 * K - KO;
⋮----
p = permute_3(px.y + pi.y + oi); // p21, p22, p23
ox = (p * K).fract_gl() - KO;
oy = ((p * K).floor() % 7.0) * K - KO;
⋮----
let mut d2 = dx * dx + dy * dy; // d21, d22, d23, squared
⋮----
p = permute_3(px.z + pi.y + oi); // p31, p32, p33
⋮----
let d3 = dx * dx + dy * dy; // d31, d32, d33, squared
⋮----
// Find the two smallest distances (F1 and F2)
let d1a = d1.min(d2);
d2 = d1.max(d2);
d2 = d2.min(d3);
d1 = d1a.min(d2);
d2 = d1a.max(d2);
⋮----
d1.y = d1.y.min(d2.y);
d1.z = d1.z.min(d2.z);
d1.y = d1.y.min(d1.z);
d1.y = d1.y.min(d2.x);
⋮----
vec2(d1.x.sqrt(), d1.y.sqrt())
</file>

<file path="crates/trivalibs_core/src/rendering/camera/mod.rs">
use serde::Serialize;
⋮----
pub struct PerspectiveCamera {
⋮----
impl Default for PerspectiveCamera {
fn default() -> Self {
// PerspectiveCamera::from_perspective(std::f32::consts::PI / 4.0, 1.0, 0.1, 1000.0)
⋮----
pub struct CamProps {
⋮----
impl Default for CamProps {
⋮----
impl PerspectiveCamera {
pub fn create(props: CamProps) -> Self {
⋮----
cam.set(props);
⋮----
pub fn set(&mut self, opts: CamProps) {
⋮----
self.recalculate_projection();
⋮----
pub fn set_aspect_ratio(&mut self, aspect_ratio: f32) {
⋮----
pub fn reset_transform(&mut self, pos: Vec3, rot_horizontal: f32, rot_vertical: f32) {
self.set(CamProps {
rot_horizontal: Some(rot_horizontal),
rot_vertical: Some(rot_vertical),
translation: Some(pos),
..default()
⋮----
pub fn update_transform(
⋮----
rot_horizontal: Some(self.rot_horizontal + rot_hor_delta),
rot_vertical: Some(self.rot_vertical + rot_vert_delta),
⋮----
translation += vec3(-f32::sin(angle), 0.0, -f32::cos(angle)) * forward;
⋮----
translation += vec3(-f32::cos(angle), 0.0, f32::sin(angle)) * left;
⋮----
pub fn transform(&self) -> Transform {
⋮----
pub fn projection_mat(&self) -> Mat4 {
⋮----
pub fn view_mat(&self) -> Mat4 {
self.transform().compute_matrix().inverse()
⋮----
pub fn view_proj_mat(&self) -> Mat4 {
self.projection_mat() * self.view_mat()
⋮----
pub fn reflected_cam(&self, _plane: Vec4) -> PerspectiveCamera {
todo!("reflect translation and rotations around plane")
⋮----
pub fn reflected_cam_ground(&self) -> PerspectiveCamera {
⋮----
translation: vec3(self.translation.x, -self.translation.y, self.translation.z),
⋮----
pub fn recalculate_projection(&mut self) {
⋮----
/// Given a position in world space, use the camera to compute the screen space coordinates.
	///
⋮----
///
	/// To get the coordinates in Normalized Device Coordinates, you should use
⋮----
/// To get the coordinates in Normalized Device Coordinates, you should use
	/// [`world_to_ndc`](Self::world_to_ndc).
⋮----
/// [`world_to_ndc`](Self::world_to_ndc).
	pub fn world_to_screen(&self, frame_size: Vec2, world_position: Vec3) -> Option<Vec2> {
⋮----
pub fn world_to_screen(&self, frame_size: Vec2, world_position: Vec3) -> Option<Vec2> {
let ndc_space_coords = self.world_to_ndc(world_position)?;
// NDC z-values outside of 0 < z < 1 are outside the camera frustum and are thus not in screen space
⋮----
// Once in NDC space, we can discard the z element and rescale x/y to fit the screen
Some((ndc_space_coords.xy() + Vec2::ONE) / 2.0 * frame_size)
⋮----
/// Given a position in world space, use the camera to compute the Normalized Device Coordinates.
	///
⋮----
///
	/// Values returned will be between -1.0 and 1.0 when the position is in screen space.
⋮----
/// Values returned will be between -1.0 and 1.0 when the position is in screen space.
	/// To get the coordinates in the render target dimensions, you should use
⋮----
/// To get the coordinates in the render target dimensions, you should use
	/// [`world_to_screen`](Self::world_to_screen).
⋮----
/// [`world_to_screen`](Self::world_to_screen).
	pub fn world_to_ndc(&self, world_position: Vec3) -> Option<Vec3> {
⋮----
pub fn world_to_ndc(&self, world_position: Vec3) -> Option<Vec3> {
// Build a transform to convert from world to NDC using camera data
let world_to_ndc: Mat4 = self.view_proj_mat();
let ndc_space_coords: Vec3 = world_to_ndc.project_point3(world_position);
⋮----
if !ndc_space_coords.is_nan() {
Some(ndc_space_coords)
⋮----
// TODO: Implement screen_to_world_ray and ndc_to_world_ray
</file>

<file path="crates/trivalibs_core/src/rendering/line_2d/mod.rs">
use crate::data::neighbour_list::traits::NeighbourFlatMapTransform;
⋮----
use glam::Vec2;
use lerp::Lerp;
use std::cell::Cell;
use std::slice::Iter;
⋮----
pub struct EmptyData {}
impl Default for EmptyData {
fn default() -> Self {
⋮----
fn lerp(self, _: Self, _: F) -> Self {
⋮----
pub struct LineVertexData<T>
⋮----
pub type LineVertex = LineVertexData<EmptyData>;
⋮----
impl<T> Default for LineVertexData<T>
⋮----
fn lerp(self, other: Self, t: f32) -> Self {
line_vert_w_d(
self.pos.lerp(other.pos, t),
⋮----
self.data.lerp(other.data, t),
⋮----
fn new(pos: Vec2) -> Self {
LineVertexData { pos, ..default() }
⋮----
pub fn point_to(&mut self, point: &Vec2) {
⋮----
let len = vec.length();
⋮----
pub fn smouth_edge_threshold(
⋮----
let d = 1. - self.dir.dot(prev.dir);
⋮----
let v1 = prev.lerp(*self, 1.0 - ratio);
let v2 = self.lerp(*next, ratio);
⋮----
vec![v1, v2]
⋮----
vec![*self]
⋮----
pub fn smouth_edge(&self, prev: &Self, next: &Self, ratio: f32) -> Vec<Self> {
self.smouth_edge_threshold(prev, next, ratio, 0.0)
⋮----
pub fn line_vert<T: Default + Copy + Clone + Lerp<f32>>(pos: Vec2) -> LineVertexData<T> {
⋮----
pub fn line_vert_w<T: Default + Copy + Clone + Lerp<f32>>(
⋮----
..default()
⋮----
pub fn line_vert_w_d<T: Default + Copy + Clone + Lerp<f32>>(
⋮----
pub struct LineData<T>
⋮----
pub type Line = LineData<EmptyData>;
⋮----
pub fn new_offset(width: f32, offset: f32) -> Self {
⋮----
pub fn new(width: f32) -> Self {
⋮----
pub fn from_vecs<I: IntoIterator<Item = Vec2>>(line_width: f32, iter: I) -> Self {
⋮----
line.add(vert);
⋮----
pub fn line_length(&self) -> f32 {
⋮----
pub fn vert_count(&self) -> usize {
self.list.len()
⋮----
pub fn add(&mut self, pos: Vec2) {
self.add_vert(line_vert_w(pos, self.default_width));
⋮----
pub fn add_width(&mut self, pos: Vec2, width: f32) {
self.add_vert(line_vert_w(pos, width));
⋮----
pub fn add_width_data(&mut self, pos: Vec2, width: f32, data: T) {
self.add_vert(line_vert_w_d(pos, width, data));
⋮----
pub fn add_vert(&mut self, mut vert: LineVertexData<T>) {
let curr_len = self.list.len();
⋮----
prev.point_to(&vert.pos);
⋮----
self.list.push(vert);
⋮----
pub fn add_vert_raw(&mut self, vert: LineVertexData<T>) {
⋮----
pub fn iter(&self) -> Iter<'_, LineVertexData<T>> {
self.list.iter()
⋮----
pub fn get(&self, i: usize) -> &LineVertexData<T> {
⋮----
pub fn get_opt(&self, i: usize) -> Option<&LineVertexData<T>> {
self.list.get(i)
⋮----
pub fn set_raw(&mut self, i: usize, vert: LineVertexData<T>) {
⋮----
pub fn first(&self) -> &LineVertexData<T> {
⋮----
pub fn last(&self) -> &LineVertexData<T> {
&self.list[self.list.len() - 1]
⋮----
pub fn split_at_angle(&self, angle_threshold: f32) -> Vec<Self> {
let mut lines = vec![];
⋮----
line.add_vert_raw(*v);
⋮----
let dot = v.dir.dot(prev.dir);
⋮----
let mut last = line.last().clone();
⋮----
line.set_raw(line.list.len() - 1, last);
lines.push(line);
⋮----
prev = Some(v);
⋮----
pub fn flat_map_with_prev_next<
⋮----
let new_vertices = self.iter().flat_map_with_prev_next(f);
⋮----
pub fn smouth_edges_threshold(&self, ratio: f32, min_dist: f32, angle_threshold: f32) -> Self {
self.flat_map_with_prev_next(|curr, prev, next| {
if prev.is_none() || next.is_none() {
return vec![*curr];
⋮----
let prev = prev.unwrap();
let next = next.unwrap();
⋮----
return curr.smouth_edge_threshold(prev, next, ratio, angle_threshold);
⋮----
pub fn smouth_edges(&self, ratio: f32, min_dist: f32) -> Self {
self.smouth_edges_threshold(ratio, min_dist, 0.0)
⋮----
pub fn cleanup_vertices(
⋮----
return vec![curr.clone()];
⋮----
let travelled_min_length = travelled_min_length_cell.get();
⋮----
// handle min length, and skip vertices in between
⋮----
travelled_min_length_cell.set(travelled_min_length + prev.len);
return vec![];
⋮----
// TODO: Check if this is right!
⋮----
travelled_min_length_cell.set(-dist);
return vec![curr.lerp(*next, ratio)];
⋮----
travelled_min_length_cell.set(0.0);
⋮----
// handle unneeded vertices when similar width
// and similar direction as prev and next
⋮----
prev.width == curr.width || (1.0 - prev.width / curr.width).abs() < width_threshold;
⋮----
curr.width == next.width || (1.0 - next.width / curr.width).abs() < width_threshold;
let is_same_direction = 1.0 - prev.dir.dot(curr.dir) < angle_threshold;
⋮----
impl<'a, T> IntoIterator for &'a LineData<T>
⋮----
type Item = &'a LineVertexData<T>;
type IntoIter = Iter<'a, LineVertexData<T>>;
⋮----
fn into_iter(self) -> Self::IntoIter {
self.iter()
⋮----
fn from_iter<I: IntoIterator<Item = LineVertexData<T>>>(iter: I) -> Self {
⋮----
line.add_vert(vert);
⋮----
pub mod buffered_geometry;
⋮----
mod tests;
</file>

<file path="crates/trivalibs_core/src/rendering/line_2d/tests.rs">
use glam::vec2;
⋮----
fn vert_point_to() {
⋮----
vert.point_to(&vec2(2.0, 0.0));
⋮----
assert_eq!(vert.len, 2.0);
assert_eq!(vert.dir, vec2(1.0, 0.0));
⋮----
vert.point_to(&vec2(0.0, 3.0));
⋮----
assert_eq!(vert.len, 3.0);
assert_eq!(vert.dir, vec2(0.0, 1.0));
⋮----
vert.point_to(&vec2(0.0, -4.0));
⋮----
assert_eq!(vert.len, 4.0);
assert_eq!(vert.dir, vec2(0.0, -1.0));
⋮----
fn line_length() {
⋮----
line.add(vec2(0.0, 0.0));
line.add(vec2(2.0, 0.0));
line.add(vec2(2.0, 1.0));
line.add(vec2(2.0, 3.0));
⋮----
assert_eq!(line.line_length(), 5.0);
assert_eq!(line.vert_count(), 4);
assert_eq!(line.last().dir, vec2(0.0, 1.0));
assert_eq!(line.last().len, 0.0);
⋮----
fn from_vecs() {
⋮----
vec2(0.0, 0.0),
vec2(2.0, 0.0),
vec2(2.0, 1.0),
vec2(2.0, 3.0),
⋮----
fn cleanup_vertices() {
⋮----
vec2(1.0, 0.0),
⋮----
vec2(3.0, 0.0),
⋮----
let cleaned1 = line1.cleanup_vertices(0.5, 0.001, 0.001);
assert_eq!(cleaned1.vert_count(), 2);
assert_eq!(cleaned1.get(0).pos, vec2(0.0, 0.0));
assert_eq!(cleaned1.get(1).pos, vec2(3.0, 0.0));
⋮----
vec2(4.0, 1.0),
vec2(5.0, 0.0),
⋮----
let cleaned2_1 = line2.cleanup_vertices(1.0, 0.001, 0.001);
assert_eq!(cleaned2_1.vert_count(), 2);
⋮----
let cleaned2_2 = line2.cleanup_vertices(0.5, 0.001, 0.001);
assert_eq!(cleaned2_2.vert_count(), 3);
⋮----
let cleaned2_3 = line2.cleanup_vertices(0.2, 0.001, 0.001);
assert_eq!(cleaned2_3.vert_count(), 5);
⋮----
let cleaned2_4 = line2.cleanup_vertices(0.1, 0.001, 0.001);
assert_eq!(cleaned2_4.vert_count(), 6);
</file>

<file path="crates/trivalibs_core/src/rendering/scene/mod.rs">
use super::camera::PerspectiveCamera;
use crate::math::transform::Transform;
⋮----
pub fn normal_mat(mat: Mat4) -> Mat3 {
Mat3::from_mat4(mat).inverse().transpose()
⋮----
pub trait SceneObject {
⋮----
fn model_mat(&self) -> Mat4 {
let mut mat = self.transform().compute_matrix();
let mut parent = self.parent();
while parent.is_some() {
mat = parent.unwrap().transform().compute_matrix() * mat;
parent = parent.unwrap().parent();
⋮----
fn model_view_mat(&self, camera: &PerspectiveCamera) -> Mat4 {
camera.view_mat() * self.model_mat()
⋮----
fn model_view_proj_mat(&self, camera: &PerspectiveCamera) -> Mat4 {
camera.view_proj_mat() * self.model_mat()
⋮----
fn model_normal_mat(&self) -> Mat3 {
normal_mat(self.model_mat())
⋮----
fn view_normal_mat(&self, camera: &PerspectiveCamera) -> Mat3 {
normal_mat(self.model_view_mat(camera))
⋮----
impl SceneObject for Transform {
fn transform(&self) -> &Transform {
⋮----
fn parent(&self) -> Option<&Self> {
</file>

<file path="crates/trivalibs_core/src/rendering/shapes/cuboid.rs">
use crate::data::Position3D;
⋮----
use super::quad::Quad3D;
⋮----
pub struct Cuboid {
⋮----
impl Cuboid {
pub fn box_at(center: Vec3, width: f32, height: f32, depth: f32) -> Self {
⋮----
size: vec3(width, height, depth),
⋮----
front_top_left: vec3(x - hw, y + hh, z + hd),
front_top_right: vec3(x + hw, y + hh, z + hd),
front_bottom_left: vec3(x - hw, y - hh, z + hd),
front_bottom_right: vec3(x + hw, y - hh, z + hd),
⋮----
back_top_left: vec3(x - hw, y + hh, z - hd),
back_top_right: vec3(x + hw, y + hh, z - hd),
back_bottom_left: vec3(x - hw, y - hh, z - hd),
back_bottom_right: vec3(x + hw, y - hh, z - hd),
⋮----
pub fn unit_cube() -> Self {
⋮----
pub fn front_face_f<P: Position3D, F: Fn(Vec3, Vec3) -> P>(&self, f: F) -> Quad3D<P> {
⋮----
top_left: f(self.front_top_left, vec3(0.0, 0.0, 0.0)),
bottom_left: f(self.front_bottom_left, vec3(0.0, 1.0, 0.0)),
bottom_right: f(self.front_bottom_right, vec3(1.0, 1.0, 0.0)),
top_right: f(self.front_top_right, vec3(1.0, 0.0, 0.0)),
⋮----
pub fn front_face(&self) -> Quad3D<Vec3> {
self.front_face_f(|pos, _| pos)
⋮----
pub fn back_face_f<P: Position3D, F: Fn(Vec3, Vec3) -> P>(&self, f: F) -> Quad3D<P> {
⋮----
top_left: f(self.back_top_right, vec3(1.0, 0.0, 1.0)),
bottom_left: f(self.back_bottom_right, vec3(1.0, 1.0, 1.0)),
bottom_right: f(self.back_bottom_left, vec3(0.0, 1.0, 1.0)),
top_right: f(self.back_top_left, vec3(0.0, 0.0, 1.0)),
⋮----
pub fn back_face(&self) -> Quad3D<Vec3> {
self.back_face_f(|pos, _| pos)
⋮----
pub fn left_face_f<P: Position3D, F: Fn(Vec3, Vec3) -> P>(&self, f: F) -> Quad3D<P> {
⋮----
top_left: f(self.back_top_left, vec3(0.0, 0.0, 1.0)),
bottom_left: f(self.back_bottom_left, vec3(0.0, 1.0, 1.0)),
bottom_right: f(self.front_bottom_left, vec3(0.0, 1.0, 0.0)),
top_right: f(self.front_top_left, vec3(0.0, 0.0, 0.0)),
⋮----
pub fn left_face(&self) -> Quad3D<Vec3> {
self.left_face_f(|pos, _| pos)
⋮----
pub fn right_face_f<P: Position3D, F: Fn(Vec3, Vec3) -> P>(&self, f: F) -> Quad3D<P> {
⋮----
top_left: f(self.front_top_right, vec3(1.0, 0.0, 0.0)),
bottom_left: f(self.front_bottom_right, vec3(1.0, 1.0, 0.0)),
bottom_right: f(self.back_bottom_right, vec3(1.0, 1.0, 1.0)),
top_right: f(self.back_top_right, vec3(1.0, 0.0, 1.0)),
⋮----
pub fn right_face(&self) -> Quad3D<Vec3> {
self.right_face_f(|pos, _| pos)
⋮----
pub fn top_face_f<P: Position3D, F: Fn(Vec3, Vec3) -> P>(&self, f: F) -> Quad3D<P> {
⋮----
bottom_left: f(self.front_top_left, vec3(0.0, 0.0, 0.0)),
bottom_right: f(self.front_top_right, vec3(1.0, 0.0, 0.0)),
⋮----
pub fn top_face(&self) -> Quad3D<Vec3> {
self.top_face_f(|pos, _| pos)
⋮----
pub fn bottom_face_f<P: Position3D, F: Fn(Vec3, Vec3) -> P>(&self, f: F) -> Quad3D<P> {
⋮----
top_left: f(self.front_bottom_left, vec3(0.0, 1.0, 0.0)),
⋮----
top_right: f(self.front_bottom_right, vec3(1.0, 1.0, 0.0)),
⋮----
pub fn bottom_face(&self) -> Quad3D<Vec3> {
self.bottom_face_f(|pos, _| pos)
</file>

<file path="crates/trivalibs_core/src/rendering/shapes/mod.rs">
pub mod cuboid;
pub mod quad;
pub mod sphere;
</file>

<file path="crates/trivalibs_core/src/rendering/webgl_buffered_geometry/mod.rs">
use bytemuck::Pod;
use serde::Serialize;
use serde_repr::Serialize_repr;
⋮----
/// Sync with WebGL type values.
/// For possible values see: https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer
⋮----
/// For possible values see: https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer
/// For numeric values see: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants
⋮----
/// For numeric values see: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants
#[repr(u32)]
⋮----
pub enum AttributeType {
⋮----
pub enum RenderingPrimitive {
⋮----
impl Default for RenderingPrimitive {
fn default() -> Self {
⋮----
pub enum VertexFormat {
/// Two unsigned bytes (u8). `uvec2` in shaders.
	Uint8x2 = 0,
/// Four unsigned bytes (u8). `uvec4` in shaders.
	Uint8x4 = 1,
/// Two signed bytes (i8). `ivec2` in shaders.
	Sint8x2 = 2,
/// Four signed bytes (i8). `ivec4` in shaders.
	Sint8x4 = 3,
/// Two unsigned bytes (u8). [0, 255] converted to float [0, 1] `vec2` in shaders.
	Unorm8x2 = 4,
/// Four unsigned bytes (u8). [0, 255] converted to float [0, 1] `vec4` in shaders.
	Unorm8x4 = 5,
/// Two signed bytes (i8). [-127, 127] converted to float [-1, 1] `vec2` in shaders.
	Snorm8x2 = 6,
/// Four signed bytes (i8). [-127, 127] converted to float [-1, 1] `vec4` in shaders.
	Snorm8x4 = 7,
/// Two unsigned shorts (u16). `uvec2` in shaders.
	Uint16x2 = 8,
/// Four unsigned shorts (u16). `uvec4` in shaders.
	Uint16x4 = 9,
/// Two signed shorts (i16). `ivec2` in shaders.
	Sint16x2 = 10,
/// Four signed shorts (i16). `ivec4` in shaders.
	Sint16x4 = 11,
/// Two unsigned shorts (u16). [0, 65535] converted to float [0, 1] `vec2` in shaders.
	Unorm16x2 = 12,
/// Four unsigned shorts (u16). [0, 65535] converted to float [0, 1] `vec4` in shaders.
	Unorm16x4 = 13,
/// Two signed shorts (i16). [-32767, 32767] converted to float [-1, 1] `vec2` in shaders.
	Snorm16x2 = 14,
/// Four signed shorts (i16). [-32767, 32767] converted to float [-1, 1] `vec4` in shaders.
	Snorm16x4 = 15,
/// Two half-precision floats (no Rust equiv). `vec2` in shaders.
	Float16x2 = 16,
/// Four half-precision floats (no Rust equiv). `vec4` in shaders.
	Float16x4 = 17,
/// One single-precision float (f32). `float` in shaders.
	Float32 = 18,
/// Two single-precision floats (f32). `vec2` in shaders.
	Float32x2 = 19,
/// Three single-precision floats (f32). `vec3` in shaders.
	Float32x3 = 20,
/// Four single-precision floats (f32). `vec4` in shaders.
	Float32x4 = 21,
⋮----
impl VertexFormat {
/// Returns the byte size of the format.
	pub const fn byte_size(&self) -> u32 {
⋮----
pub const fn byte_size(&self) -> u32 {
⋮----
pub const fn normalized(&self) -> bool {
⋮----
pub const fn count(&self) -> u32 {
⋮----
pub const fn attr_type(&self) -> AttributeType {
⋮----
pub struct VertexType {
⋮----
impl VertexType {
pub fn new(name: &'static str, format: VertexFormat) -> VertexType {
⋮----
pub fn vert_type(name: &'static str, format: VertexFormat) -> VertexType {
⋮----
pub struct AttributeLayout {
⋮----
pub struct WebglBufferedGeometry {
⋮----
/// u32 indices converted to bytes, so they can be serialized efficiently.
	/// 4 bytes per index.
⋮----
/// 4 bytes per index.
	#[serde(with = "serde_bytes")]
⋮----
pub struct WebglBufferedGeometryLayout {
⋮----
pub fn create_buffered_geometry_layout(layout: Vec<VertexType>) -> WebglBufferedGeometryLayout {
let mut vertex_layout = vec![];
⋮----
vertex_layout.push(AttributeLayout {
⋮----
size: format.count(),
attr_type: format.attr_type(),
normalized: format.normalized(),
⋮----
vertex_size += format.byte_size();
⋮----
pub trait WebglVertexData: Pod + Clone {
</file>

<file path="crates/trivalibs_core/src/utils/app_state.rs">
pub use std::cell::OnceCell;
pub use trivalibs_macros::AppState;
⋮----
pub trait AppState: Sized + Default + 'static {
⋮----
fn read<'a>() -> &'a Self {
unsafe { AppState::state_cell().get_or_init(|| Self::default()) }
⋮----
fn mutate<F: Fn(&mut Self)>(f: F) {
⋮----
if cell.get().is_none() {
let _ = cell.set(Self::default());
⋮----
f(cell.get_mut().unwrap())
</file>

<file path="crates/trivalibs_core/src/utils/mod.rs">
pub mod app_state;
pub mod rand_utils;
⋮----
pub fn default<T: Default>() -> T {
</file>

<file path="crates/trivalibs_core/src/wasm_helpers/mod.rs">
use js_sys::Float32Array;
⋮----
pub fn mat2_to_js(mat: &Mat2) -> Float32Array {
js_sys::Float32Array::from(mat.to_cols_array().as_slice())
⋮----
pub fn mat3_to_js(mat: &Mat3) -> Float32Array {
⋮----
pub fn mat4_to_js(mat: &Mat4) -> Float32Array {
⋮----
pub fn vec2_to_js(vec: &Vec2) -> Float32Array {
js_sys::Float32Array::from(vec.to_array().as_slice())
⋮----
pub fn vec3_to_js(vec: &Vec3) -> Float32Array {
⋮----
pub fn vec4_to_js(vec: &Vec4) -> Float32Array {
⋮----
macro_rules! setup_camera_interactions {
</file>

<file path="crates/trivalibs_core/src/macros.rs">
macro_rules! attribute_alias {(
⋮----
// Let's not do the paste + module + re-export dance here since it
// is less likely for an attribute name to collide with a prelude item.
⋮----
/** Not part of the public API*/
⋮----
macro_rules! ඞ_with_dollar {( $($rules:tt)* ) => (
⋮----
attribute_alias! {
⋮----
pub use ::macro_rules_attribute::apply;
⋮----
macro_rules! hashmap {
⋮----
macro_rules! bmap {
⋮----
/// Create a `Vec` of key-value pair tuples.
///
⋮----
///
/// # Examples
⋮----
/// # Examples
///
⋮----
///
/// ```
⋮----
/// ```
/// use trivalibs_core::map;
⋮----
/// use trivalibs_core::map;
///
⋮----
///
/// let map = map! {
⋮----
/// let map = map! {
///     "a" => 1,
⋮----
///     "a" => 1,
///     "b" => 2,
⋮----
///     "b" => 2,
/// };
⋮----
/// };
///
⋮----
///
/// assert_eq!(map, vec![("a", 1), ("b", 2)]);
⋮----
/// assert_eq!(map, vec![("a", 1), ("b", 2)]);
/// ```
⋮----
/// ```
///
⋮----
/// let map = map! {
///     "x" => 10,
⋮----
///     "x" => 10,
///     "y" => 20,
⋮----
///     "y" => 20,
///     "z" => 30,
⋮----
///     "z" => 30,
/// };
///
/// assert_eq!(map, vec![("x", 10), ("y", 20), ("z", 30)]);
⋮----
/// assert_eq!(map, vec![("x", 10), ("y", 20), ("z", 30)]);
/// ```
///
#[macro_export]
macro_rules! map {
</file>

<file path="crates/trivalibs_macros/src/lib.rs">
use proc_macro::TokenStream;
use quote::quote;
use syn::parse_macro_input;
⋮----
pub fn derive_app_state(input: TokenStream) -> TokenStream {
let input = parse_macro_input!(input as syn::DeriveInput);
⋮----
let expanded = quote! {
// The generated impl.
⋮----
// Hand the output tokens back to the compiler.
</file>

<file path="crates/trivalibs_painter/src/utils/mod.rs">
pub mod input_state;
</file>

<file path="crates/trivalibs_painter/src/shaders.rs">
// Full screen triangle concept explained here:
// https://www.saschawillems.de/blog/2016/08/13/vulkan-tutorial-on-rendering-a-fullscreen-quad-without-buffers/
</file>

<file path="examples/ball/shader/Cargo.toml">
[package]
name = "ball_shader"
edition.workspace = true
version = "0.1.0"

[lib]
crate-type = ["rlib", "cdylib"]

[dependencies]
spirv-std.workspace = true
</file>

<file path="examples/ball/shader/manifest.json">
[
  {
    "source_path": "fragment.spv",
    "entry_point": "fragment",
    "wgsl_entry_point": "fragment"
  },
  {
    "source_path": "vertex.spv",
    "entry_point": "vertex",
    "wgsl_entry_point": "vertex"
  }
]
</file>

<file path="examples/base_effect/shader/manifest.json">
[
  {
    "source_path": "main.spv",
    "entry_point": "main",
    "wgsl_entry_point": "main"
  }
]
</file>

<file path="examples/blur/shader/manifest.json">
[
  {
    "source_path": "blur_fs.spv",
    "entry_point": "blur_fs",
    "wgsl_entry_point": "blur_fs"
  },
  {
    "source_path": "triangle_fs.spv",
    "entry_point": "triangle_fs",
    "wgsl_entry_point": "triangle_fs"
  },
  {
    "source_path": "triangle_vs.spv",
    "entry_point": "triangle_vs",
    "wgsl_entry_point": "triangle_vs"
  }
]
</file>

<file path="examples/deferred_light/shader/Cargo.toml">
[package]
name = "deferred_light_shader"
edition.workspace = true
version = "0.1.0"

[lib]
crate-type = ["rlib", "cdylib"]

[dependencies]
spirv-std.workspace = true
</file>

<file path="examples/deferred_light/shader/manifest.json">
[
  {
    "source_path": "light_fs.spv",
    "entry_point": "light_fs",
    "wgsl_entry_point": "light_fs"
  },
  {
    "source_path": "scene_fs.spv",
    "entry_point": "scene_fs",
    "wgsl_entry_point": "scene_fs"
  },
  {
    "source_path": "scene_vs.spv",
    "entry_point": "scene_vs",
    "wgsl_entry_point": "scene_vs"
  }
]
</file>

<file path="examples/geometries/shader/src/lib.rs">
use spirv_std::spirv;
⋮----
pub fn ground_vert(
⋮----
*out_pos = *mvp_mat * position.extend(1.0);
⋮----
pub fn ground_frag(_in_norm: Vec3, in_uv: Vec2, out: &mut Vec4) {
⋮----
let uv = uv.fract();
⋮----
vec3(in_uv.x, in_uv.y, 0.5)
⋮----
*out = col.powf(2.2).extend(1.0);
</file>

<file path="examples/geometries/shader/manifest.json">
[
  {
    "source_path": "ground_frag.spv",
    "entry_point": "ground_frag",
    "wgsl_entry_point": "ground_frag"
  },
  {
    "source_path": "ground_vert.spv",
    "entry_point": "ground_vert",
    "wgsl_entry_point": "ground_vert"
  }
]
</file>

<file path="examples/instances/shader/src/lib.rs">
use spirv_std::spirv;
⋮----
pub fn vertex(
⋮----
*clip_pos = *vp_mat * *model_mat * position.extend(1.0);
⋮----
pub fn fragment(
</file>

<file path="examples/instances/shader/Cargo.toml">
[package]
name = "instances_shader"
edition.workspace = true
version = "0.1.0"

[lib]
crate-type = ["rlib", "cdylib"]

[dependencies]
spirv-std.workspace = true
</file>

<file path="examples/instances/shader/manifest.json">
[
  {
    "source_path": "fragment.spv",
    "entry_point": "fragment",
    "wgsl_entry_point": "fragment"
  },
  {
    "source_path": "vertex.spv",
    "entry_point": "vertex",
    "wgsl_entry_point": "vertex"
  }
]
</file>

<file path="examples/layer_tex/shader/Cargo.toml">
[package]
name = "layer_tex_shader"
edition.workspace = true
version = "0.1.0"

[lib]
crate-type = ["rlib", "cdylib"]

[dependencies]
spirv-std.workspace = true
</file>

<file path="examples/layer_tex/shader/manifest.json">
[
  {
    "source_path": "color_fs.spv",
    "entry_point": "color_fs",
    "wgsl_entry_point": "color_fs"
  },
  {
    "source_path": "color_vs.spv",
    "entry_point": "color_vs",
    "wgsl_entry_point": "color_vs"
  },
  {
    "source_path": "texture_fs.spv",
    "entry_point": "texture_fs",
    "wgsl_entry_point": "texture_fs"
  },
  {
    "source_path": "texture_vs.spv",
    "entry_point": "texture_vs",
    "wgsl_entry_point": "texture_vs"
  }
]
</file>

<file path="examples/noise_tests/shader/manifest.json">
[
  {
    "source_path": "hash_shader.spv",
    "entry_point": "hash_shader",
    "wgsl_entry_point": "hash_shader"
  },
  {
    "source_path": "simplex_2d_shader.spv",
    "entry_point": "simplex_2d_shader",
    "wgsl_entry_point": "simplex_2d_shader"
  },
  {
    "source_path": "simplex_3d_shader.spv",
    "entry_point": "simplex_3d_shader",
    "wgsl_entry_point": "simplex_3d_shader"
  },
  {
    "source_path": "simplex_4d_shader.spv",
    "entry_point": "simplex_4d_shader",
    "wgsl_entry_point": "simplex_4d_shader"
  },
  {
    "source_path": "tiling_noise_2d_shader.spv",
    "entry_point": "tiling_noise_2d_shader",
    "wgsl_entry_point": "tiling_noise_2d_shader"
  },
  {
    "source_path": "tiling_noise_3d_shader.spv",
    "entry_point": "tiling_noise_3d_shader",
    "wgsl_entry_point": "tiling_noise_3d_shader"
  },
  {
    "source_path": "tiling_simplex_shader.spv",
    "entry_point": "tiling_simplex_shader",
    "wgsl_entry_point": "tiling_simplex_shader"
  }
]
</file>

<file path="examples/shader_image/shader/src/lib.rs">
use spirv_std::num_traits::Float;
use spirv_std::spirv;
⋮----
pub fn main_fs(uv: Vec2, output: &mut Vec4) {
let tile_size = vec2(6.0, 12.0);
⋮----
let y_offet = tile.y.floor() % 2.0;
⋮----
let tile = tile - tile.floor();
⋮----
vec4(0.4, 0.6, 0.9, 1.0)
⋮----
vec4(1.0, 0.8, 0.5, 1.0)
⋮----
pub fn main_vs(
⋮----
*uv = vec2(((vert_idx << 1) & 2) as f32, (vert_idx & 2) as f32);
⋮----
*builtin_pos = pos.extend(0.0).extend(1.0);
</file>

<file path="examples/shader_image/shader/Cargo.toml">
[package]
name = "shader_image_shader"
edition.workspace = true
version = "0.1.0"

[lib]
crate-type = ["rlib", "cdylib"]

[dependencies]
spirv-std.workspace = true
</file>

<file path="examples/triangle/shader/src/lib.rs">
pub struct Vertex {
⋮----
pub fn vertex(
⋮----
*clip_pos = position.extend(1.0);
⋮----
pub fn fragment(
⋮----
#[spirv(descriptor_set = 0, binding = 0)] tex: &Image!(2D, type=f32, sampled),
⋮----
let col = tex.sample(*sampler, vec2(in_uv.x, in_uv.y));
*frag_color = vec4(col.x, col.y, col.z, 1.0) * in_color.extend(1.0);
</file>

<file path="examples/triangle/shader/Cargo.toml">
[package]
name = "test_triangle_shader"
edition.workspace = true
version = "0.1.0"

[lib]
crate-type = ["rlib", "cdylib"]

# Dependencies for CPU and GPU code
[dependencies]
spirv-std.workspace = true

# dependencies for CPU code
[target.'cfg(not(target_arch = "spirv"))'.dependencies]
trivalibs.workspace = true
bytemuck.workspace = true
</file>

<file path="examples/triangle/Cargo.toml">
[package]
name = "test_triangle"
edition.workspace = true
version = "0.1.0"

[dependencies]
trivalibs.workspace = true
shader = { path = "./shader", package = "test_triangle_shader" }
png.workspace = true
bytemuck.workspace = true
</file>

<file path="examples/user_event/shader/src/lib.rs">
let tl = vec4(-1.0, 1.0, 0.5, 1.0);
let tr = vec4(1.0, 1.0, 0.5, 1.0);
let bl = vec4(-1.0, -1.0, 0.5, 1.0);
let br = vec4(1.0, -1.0, 0.5, 1.0);
⋮----
let tl = vec2(0.0, 0.0);
let tr = vec2(1.0, 0.0);
let bl = vec2(0.0, 1.0);
let br = vec2(1.0, 1.0);
⋮----
/// Vertex shader that renders an implicit quad.
#[spirv(vertex)]
pub fn vertex(
⋮----
/// Fragment shader that uses UV coords passed in from the vertex shader
/// to render a simple gradient.
⋮----
/// to render a simple gradient.
#[spirv(fragment)]
pub fn fragment(in_uv: Vec2, frag_color: &mut Vec4) {
*frag_color = vec4(in_uv.x, 1.0 - in_uv.y, 0.0, 1.0);
</file>

<file path="examples/user_event/shader/Cargo.toml">
[package]
name = "user_event_shader"
edition.workspace = true
version = "0.1.0"

[lib]
crate-type = ["rlib", "cdylib"]

[dependencies]
spirv-std.workspace = true
</file>

<file path=".editorconfig">
root = true

[*]
	charset = utf-8
	indent_style = tab
	indent_size = 2
	tab_width = 2
	trim_trailing_whitespace = true
	insert_final_newline = true
	end_of_line = lf

[*.{yml,yaml,md,json}]
	indent_style = space

[*.md]
	trim_trailing_whitespace = false
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2022 Thomas Gorny

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</file>

<file path="rustfmt.toml">
hard_tabs = true
tab_spaces = 4
</file>

<file path="crates/trivalibs/src/common_utils/camera_controls.rs">
use trivalibs_core::rendering::camera::PerspectiveCamera;
⋮----
pub struct BasicFirstPersonCameraController {
⋮----
impl BasicFirstPersonCameraController {
pub fn new(move_speed: f32, look_speed: f32) -> Self {
⋮----
pub fn set_move_speed(&mut self, speed: f32) {
⋮----
pub fn set_look_speed(&mut self, speed: f32) {
⋮----
pub fn set_screen_size(&mut self, width: u32, height: u32) {
⋮----
pub fn update_camera(
⋮----
let slow_down = self.screen_width.max(self.screen_height) as f32;
⋮----
&& dragging.delta_x.abs() < 20.0
&& dragging.delta_y.abs() < 20.0
⋮----
if input.pressed_keys.contains(&KeyCode::KeyW)
|| input.pressed_keys.contains(&KeyCode::ArrowUp)
⋮----
.contains(&PointerButton::Secondary))
⋮----
if input.pressed_keys.contains(&KeyCode::KeyS)
|| input.pressed_keys.contains(&KeyCode::ArrowDown)
⋮----
.contains(&PointerButton::Secondary)
⋮----
if input.pressed_keys.contains(&KeyCode::KeyA)
|| input.pressed_keys.contains(&KeyCode::ArrowLeft)
⋮----
if input.pressed_keys.contains(&KeyCode::KeyD)
|| input.pressed_keys.contains(&KeyCode::ArrowRight)
⋮----
camera.update_transform(forward, left, 0.0, rot_x, rot_y);
</file>

<file path="crates/trivalibs/src/lib.rs">
pub mod painter {
⋮----
pub mod nostd {
⋮----
pub mod common_utils;
⋮----
pub mod prelude {
pub use trivalibs_core::bmap;
pub use trivalibs_core::hashmap;
pub use trivalibs_core::map;
</file>

<file path="crates/trivalibs_core/src/data/grid/mod.rs">
use lerp::Lerp;
⋮----
pub trait CoordOpsFn: Clone {
⋮----
pub struct ClampToEdgeCoordOps;
impl CoordOpsFn for ClampToEdgeCoordOps {
fn adjust_coords(&self, x: i32, y: i32, width: usize, height: usize) -> (usize, usize) {
⋮----
(x.min(w - 1).max(0) as usize, y.min(h - 1).max(0) as usize)
⋮----
fn circle(&self) -> (bool, bool) {
⋮----
pub struct CircleRowsCoordOps;
impl CoordOpsFn for CircleRowsCoordOps {
⋮----
return self.adjust_coords(x, y + h, width, height);
⋮----
return self.adjust_coords(x, y - h, width, height);
⋮----
pub struct CircleColsCoordOps;
impl CoordOpsFn for CircleColsCoordOps {
⋮----
return self.adjust_coords(x + w, y, width, height);
⋮----
return self.adjust_coords(x - w, y, width, height);
⋮----
pub struct CircleAllCoordOps;
impl CoordOpsFn for CircleAllCoordOps {
⋮----
/// A two dimensional grid structure. Grid quad rotation assumes 0,0 is the lower left corner.
pub struct Grid<T, A>
⋮----
pub struct Grid<T, A>
⋮----
pub struct Vertex<'a, T, A>
⋮----
pub fn make_grid<T: Clone>() -> Grid<T, ClampToEdgeCoordOps> {
⋮----
pub fn make_grid_from_cols<T: Clone>(cols: Vec<Vec<T>>) -> Grid<T, ClampToEdgeCoordOps> {
let mut grid = make_grid();
⋮----
grid.add_col(col);
⋮----
pub fn make_grid_with_coord_ops<T: Clone, A: CoordOpsFn>(coord_ops: A) -> Grid<T, A> {
⋮----
pub fn make_grid_from_cols_with_coord_ops<T: Clone, A: CoordOpsFn>(
⋮----
let mut grid = make_grid_with_coord_ops(coord_ops);
⋮----
fn new(coord_ops: A) -> Self {
⋮----
vertices: vec![],
⋮----
pub fn get(&self, x: i32, y: i32) -> &T {
let (x, y) = self.coord_ops.adjust_coords(x, y, self.width, self.height);
⋮----
pub fn get_mut(&mut self, x: i32, y: i32) -> &mut T {
⋮----
pub fn set(&mut self, x: i32, y: i32, val: T) {
⋮----
pub fn vertex(&self, x: i32, y: i32) -> Vertex<'_, T, A> {
⋮----
let val = self.vertices[x][y].clone();
⋮----
pub fn col(&self, x: i32) -> &Vec<T> {
let (new_x, _) = self.coord_ops.adjust_coords(x, 0, self.width, self.height);
⋮----
pub fn row(&self, y: i32) -> Vec<T> {
let (_, new_y) = self.coord_ops.adjust_coords(0, y, self.width, self.height);
let mut row = vec![];
⋮----
row.push(self.vertices[x][new_y].clone());
⋮----
pub fn first_col(&self) -> &Vec<T> {
⋮----
pub fn first_row(&self) -> Vec<T> {
⋮----
row.push(self.vertices[x][0].clone());
⋮----
pub fn last_col(&self) -> &Vec<T> {
⋮----
pub fn last_row(&self) -> Vec<T> {
⋮----
row.push(self.vertices[x][self.height - 1].clone());
⋮----
pub fn add_col(&mut self, vals: Vec<T>) {
let len = vals.len();
⋮----
panic!("new column length needs to be as big as the grid height.")
⋮----
self.vertices.push(vals);
⋮----
pub fn add_row(&mut self, vals: Vec<T>) {
⋮----
self.vertices.push(vec![]);
⋮----
panic!("new row length needs to be as big as the grid width.");
⋮----
self.vertices[i].push(vals[i].clone());
⋮----
pub fn map<B, F>(&self, f: F) -> Grid<B, A>
⋮----
let mut grid = Grid::new(self.coord_ops.clone());
⋮----
let mut col = vec![];
⋮----
col.push(f(self.vertex(x as i32, y as i32)));
⋮----
pub fn quad_count(&self) -> (usize, usize) {
let (circle_cols, circle_rows) = self.coord_ops.circle();
⋮----
pub fn flat_map_cols<B, F>(&self, f: F) -> Grid<B, A>
⋮----
let mut grid = make_grid_with_coord_ops(self.coord_ops.clone());
⋮----
col.push(self.vertex(x as i32, y as i32));
⋮----
let new_colls = f(col);
for i in 0..new_colls.len() {
grid.add_col(new_colls[i].to_vec());
⋮----
pub fn flat_map_rows<B, F>(&self, f: F) -> Grid<B, A>
⋮----
row.push(self.vertex(x as i32, y as i32));
⋮----
let new_rows = f(row);
for i in 0..new_rows.len() {
grid.add_row(new_rows[i].to_vec());
⋮----
/// Get clockwise oriented quads. Grid quad orientation assumes 0,0 is the lower left corner.
	pub fn to_ccw_quads<'a>(&self) -> Vec<[T; 4]> {
⋮----
pub fn to_ccw_quads<'a>(&self) -> Vec<[T; 4]> {
let (w, h) = self.quad_count();
let mut quads = vec![];
⋮----
quads.push([
self.get(x, y).clone(),
self.get(x + 1, y).clone(),
self.get(x + 1, y + 1).clone(),
self.get(x, y + 1).clone(),
⋮----
/// Get clockwise oriented quads. Grid quad orientation assumes 0,0 is the lower left corner.
	pub fn to_cw_quads<'a>(&self) -> Vec<[T; 4]> {
⋮----
pub fn to_cw_quads<'a>(&self) -> Vec<[T; 4]> {
⋮----
pub fn subdivide(&self, count_x: u32, count_y: u32) -> Self {
let grid1 = self.flat_map_cols(|col| {
let next = col[0].right();
let col1 = col.iter().map(|v| v.val.clone()).collect();
let mut cols = vec![col1];
if !next.is_none() {
⋮----
.iter()
.map(|v| v.val.clone().lerp(v.right().unwrap().val, t))
.collect();
cols.push(col2)
⋮----
grid1.flat_map_rows(|row| {
let next = row[0].bottom();
let row1 = row.iter().map(|v| v.val.clone()).collect();
let mut rows = vec![row1];
⋮----
.map(|v| v.val.clone().lerp(v.bottom().unwrap().val, t))
⋮----
rows.push(row2)
⋮----
impl<T: Clone, A: CoordOpsFn> PartialEq for Vertex<'_, T, A> {
fn eq(&self, other: &Self) -> bool {
⋮----
pub fn next(&self, x_offset: i32, y_offset: i32) -> Option<Self> {
⋮----
.vertex(self.x as i32 + x_offset, self.y as i32 + y_offset);
⋮----
Some(vert)
⋮----
pub fn left(&self) -> Option<Self> {
self.next(-1, 0)
⋮----
pub fn right(&self) -> Option<Self> {
self.next(1, 0)
⋮----
pub fn top(&self) -> Option<Self> {
self.next(0, -1)
⋮----
pub fn bottom(&self) -> Option<Self> {
self.next(0, 1)
⋮----
mod tests;
</file>

<file path="crates/trivalibs_core/src/data/mod.rs">
pub mod grid;
pub mod neighbour_list;
pub mod vertex_index;
⋮----
pub trait Position3D {
⋮----
impl Position3D for Vec3 {
fn position(&self) -> Vec3 {
⋮----
pub trait Position2D {
⋮----
impl Position2D for Vec2 {
fn position(&self) -> Vec2 {
</file>

<file path="crates/trivalibs_core/src/data/vertex_index.rs">
use std::hash::Hash;
⋮----
use glam::Vec3;
⋮----
pub trait VertexIndex: Eq + Hash + Clone + Copy {}
⋮----
pub struct VertIdx2U(u32, u32);
impl VertexIndex for VertIdx2U {}
impl Hash for VertIdx2U {
fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
⋮----
hash_val.hash(state)
⋮----
pub struct VertIdx2Usize(pub usize, pub usize);
impl VertexIndex for VertIdx2Usize {}
impl Hash for VertIdx2Usize {
⋮----
pub struct VertIdx3f(pub f32, pub f32, pub f32);
impl VertexIndex for VertIdx3f {}
⋮----
fn from(v: Vec3) -> Self {
Self(v.x, v.y, v.z)
⋮----
impl PartialEq for VertIdx3f {
fn eq(&self, other: &Self) -> bool {
⋮----
((self.0 * SCALE).round() as i32) == ((other.0 * SCALE).round() as i32)
&& ((self.1 * SCALE).round() as i32) == ((other.1 * SCALE).round() as i32)
&& ((self.2 * SCALE).round() as i32) == ((other.2 * SCALE).round() as i32)
⋮----
impl Eq for VertIdx3f {}
⋮----
impl Hash for VertIdx3f {
⋮----
let x = (self.0 * SCALE).round() as i32;
let y = (self.1 * SCALE).round() as i32;
let z = (self.2 * SCALE).round() as i32;
x.hash(state);
y.hash(state);
z.hash(state);
</file>

<file path="crates/trivalibs_core/src/math/transform/mod.rs">
use serde::Serialize;
use std::ops::Mul;
⋮----
/// Describe the position of an entity.
/// To place or move an entity, you should set its [`Transform`].
⋮----
/// To place or move an entity, you should set its [`Transform`].
/// Copied from Bevy Engine Transform (version 0.15)
⋮----
/// Copied from Bevy Engine Transform (version 0.15)
#[derive(Debug, PartialEq, Clone, Copy, Serialize)]
pub struct Transform {
/// Position of the entity. In 2d, the last value of the `Vec3` is used for z-ordering.
	pub translation: Vec3,
/// Rotation of the entity.
	pub rotation: Quat,
/// Scale of the entity.
	pub scale: Vec3,
⋮----
impl Transform {
/// An identity [`Transform`] with no translation, rotation, and a scale of 1 on all axes.
	pub const IDENTITY: Self = Transform {
⋮----
/// Creates a new [`Transform`] at the position `(x, y, z)`. In 2d, the `z` component
	/// is used for z-ordering elements: higher `z`-value will be in front of lower
⋮----
/// is used for z-ordering elements: higher `z`-value will be in front of lower
	/// `z`-value.
⋮----
/// `z`-value.
	#[inline]
pub const fn from_xyz(x: f32, y: f32, z: f32) -> Self {
⋮----
/// Extracts the translation, rotation, and scale from `matrix`. It must be a 3d affine
	/// transformation matrix.
⋮----
/// transformation matrix.
	#[inline]
pub fn from_matrix(world_from_local: Mat4) -> Self {
let (scale, rotation, translation) = world_from_local.to_scale_rotation_translation();
⋮----
/// Creates a new [`Transform`], with `translation`. Rotation will be 0 and scale 1 on
	/// all axes.
⋮----
/// all axes.
	#[inline]
pub const fn from_translation(translation: Vec3) -> Self {
⋮----
/// Creates a new [`Transform`], with `rotation`. Translation will be 0 and scale 1 on
	/// all axes.
⋮----
pub const fn from_rotation(rotation: Quat) -> Self {
⋮----
/// Creates a new [`Transform`], with `scale`. Translation will be 0 and rotation 0 on
	/// all axes.
⋮----
pub const fn from_scale(scale: Vec3) -> Self {
⋮----
/// Returns this [`Transform`] with a new rotation so that [`Transform::forward`]
	/// points towards the `target` position and [`Transform::up`] points towards `up`.
⋮----
/// points towards the `target` position and [`Transform::up`] points towards `up`.
	///
⋮----
///
	/// In some cases it's not possible to construct a rotation. Another axis will be picked in those cases:
⋮----
/// In some cases it's not possible to construct a rotation. Another axis will be picked in those cases:
	/// * if `target` is the same as the transform translation, `Vec3::Z` is used instead
⋮----
/// * if `target` is the same as the transform translation, `Vec3::Z` is used instead
	/// * if `up` is zero, `Vec3::Y` is used instead
⋮----
/// * if `up` is zero, `Vec3::Y` is used instead
	/// * if the resulting forward direction is parallel with `up`, an orthogonal vector is used as the "right" direction
⋮----
/// * if the resulting forward direction is parallel with `up`, an orthogonal vector is used as the "right" direction
	#[inline]
⋮----
pub fn looking_at(mut self, target: Vec3, up: Vec3) -> Self {
self.look_at(target, up);
⋮----
/// Returns this [`Transform`] with a new rotation so that [`Transform::forward`]
	/// points in the given `direction` and [`Transform::up`] points towards `up`.
⋮----
/// points in the given `direction` and [`Transform::up`] points towards `up`.
	///
/// In some cases it's not possible to construct a rotation. Another axis will be picked in those cases:
	/// * if `direction` is zero, `Vec3::Z` is used instead
⋮----
/// * if `direction` is zero, `Vec3::Z` is used instead
	/// * if `up` is zero, `Vec3::Y` is used instead
⋮----
/// * if `up` is zero, `Vec3::Y` is used instead
	/// * if `direction` is parallel with `up`, an orthogonal vector is used as the "right" direction
⋮----
/// * if `direction` is parallel with `up`, an orthogonal vector is used as the "right" direction
	#[inline]
⋮----
pub fn looking_to(mut self, direction: Vec3, up: Vec3) -> Self {
self.look_to(direction, up);
⋮----
/// Rotates this [`Transform`] so that the `main_axis` vector, reinterpreted in local coordinates, points
	/// in the given `main_direction`, while `secondary_axis` points towards `secondary_direction`.
⋮----
/// in the given `main_direction`, while `secondary_axis` points towards `secondary_direction`.
	/// For example, if a spaceship model has its nose pointing in the X-direction in its own local coordinates
⋮----
/// For example, if a spaceship model has its nose pointing in the X-direction in its own local coordinates
	/// and its dorsal fin pointing in the Y-direction, then `align(Vec3::X, v, Vec3::Y, w)` will make the spaceship's
⋮----
/// and its dorsal fin pointing in the Y-direction, then `align(Vec3::X, v, Vec3::Y, w)` will make the spaceship's
	/// nose point in the direction of `v`, while the dorsal fin does its best to point in the direction `w`.
⋮----
/// nose point in the direction of `v`, while the dorsal fin does its best to point in the direction `w`.
	///
⋮----
///
	///
⋮----
///
	/// In some cases a rotation cannot be constructed. Another axis will be picked in those cases:
⋮----
/// In some cases a rotation cannot be constructed. Another axis will be picked in those cases:
	/// * if `main_axis` or `main_direction` fail converting to `Vec3` (e.g are zero), `Vec3::X` takes their place
⋮----
/// * if `main_axis` or `main_direction` fail converting to `Vec3` (e.g are zero), `Vec3::X` takes their place
	/// * if `secondary_axis` or `secondary_direction` fail converting, `Vec3::Y` takes their place
⋮----
/// * if `secondary_axis` or `secondary_direction` fail converting, `Vec3::Y` takes their place
	/// * if `main_axis` is parallel with `secondary_axis` or `main_direction` is parallel with `secondary_direction`,
⋮----
/// * if `main_axis` is parallel with `secondary_axis` or `main_direction` is parallel with `secondary_direction`,
	///     a rotation is constructed which takes `main_axis` to `main_direction` along a great circle, ignoring the secondary
⋮----
///     a rotation is constructed which takes `main_axis` to `main_direction` along a great circle, ignoring the secondary
	///     counterparts
⋮----
///     counterparts
	///
⋮----
///
	/// See [`Transform::align`] for additional details.
⋮----
/// See [`Transform::align`] for additional details.
	#[inline]
⋮----
pub fn aligned_by(
⋮----
self.align(
⋮----
/// Returns this [`Transform`] with a new translation.
	#[inline]
⋮----
pub const fn with_translation(mut self, translation: Vec3) -> Self {
⋮----
/// Returns this [`Transform`] with a new rotation.
	#[inline]
⋮----
pub const fn with_rotation(mut self, rotation: Quat) -> Self {
⋮----
/// Returns this [`Transform`] with a new scale.
	#[inline]
⋮----
pub const fn with_scale(mut self, scale: Vec3) -> Self {
⋮----
/// Returns the 3d affine transformation matrix from this transforms translation,
	/// rotation, and scale.
⋮----
/// rotation, and scale.
	#[inline]
pub fn compute_matrix(&self) -> Mat4 {
⋮----
pub fn compute_affine(&self) -> Affine3A {
⋮----
/// Get the unit vector in the local `X` direction.
	#[inline]
pub fn local_x(&self) -> Vec3 {
⋮----
/// Equivalent to [`-local_x()`][Transform::local_x()]
	#[inline]
pub fn left(&self) -> Vec3 {
-self.local_x()
⋮----
/// Equivalent to [`local_x()`][Transform::local_x()]
	#[inline]
pub fn right(&self) -> Vec3 {
self.local_x()
⋮----
/// Get the unit vector in the local `Y` direction.
	#[inline]
pub fn local_y(&self) -> Vec3 {
⋮----
/// Equivalent to [`local_y()`][Transform::local_y]
	#[inline]
pub fn up(&self) -> Vec3 {
self.local_y()
⋮----
/// Equivalent to [`-local_y()`][Transform::local_y]
	#[inline]
pub fn down(&self) -> Vec3 {
-self.local_y()
⋮----
/// Get the unit vector in the local `Z` direction.
	#[inline]
pub fn local_z(&self) -> Vec3 {
⋮----
/// Equivalent to [`-local_z()`][Transform::local_z]
	#[inline]
pub fn forward(&self) -> Vec3 {
-self.local_z()
⋮----
/// Equivalent to [`local_z()`][Transform::local_z]
	#[inline]
pub fn back(&self) -> Vec3 {
self.local_z()
⋮----
/// Rotates this [`Transform`] by the given rotation.
	///
⋮----
///
	/// If this [`Transform`] has a parent, the `rotation` is relative to the rotation of the parent.
⋮----
/// If this [`Transform`] has a parent, the `rotation` is relative to the rotation of the parent.
	///
⋮----
///
	/// # Examples
⋮----
/// # Examples
	///
⋮----
///
	/// - [`3d_rotation`]
⋮----
/// - [`3d_rotation`]
	///
⋮----
///
	/// [`3d_rotation`]: https://github.com/bevyengine/bevy/blob/latest/examples/transforms/3d_rotation.rs
⋮----
/// [`3d_rotation`]: https://github.com/bevyengine/bevy/blob/latest/examples/transforms/3d_rotation.rs
	#[inline]
pub fn rotate(&mut self, rotation: Quat) {
⋮----
/// Rotates this [`Transform`] around the given `axis` by `angle` (in radians).
	///
⋮----
///
	/// If this [`Transform`] has a parent, the `axis` is relative to the rotation of the parent.
⋮----
/// If this [`Transform`] has a parent, the `axis` is relative to the rotation of the parent.
	#[inline]
pub fn rotate_axis(&mut self, axis: Vec3, angle: f32) {
self.rotate(Quat::from_axis_angle(axis, angle));
⋮----
/// Rotates this [`Transform`] around the `X` axis by `angle` (in radians).
	///
⋮----
///
	/// If this [`Transform`] has a parent, the axis is relative to the rotation of the parent.
⋮----
/// If this [`Transform`] has a parent, the axis is relative to the rotation of the parent.
	#[inline]
pub fn rotate_x(&mut self, angle: f32) {
self.rotate(Quat::from_rotation_x(angle));
⋮----
/// Rotates this [`Transform`] around the `Y` axis by `angle` (in radians).
	///
⋮----
pub fn rotate_y(&mut self, angle: f32) {
self.rotate(Quat::from_rotation_y(angle));
⋮----
/// Rotates this [`Transform`] around the `Z` axis by `angle` (in radians).
	///
⋮----
pub fn rotate_z(&mut self, angle: f32) {
self.rotate(Quat::from_rotation_z(angle));
⋮----
/// Rotates this [`Transform`] by the given `rotation`.
	///
⋮----
///
	/// The `rotation` is relative to this [`Transform`]'s current rotation.
⋮----
/// The `rotation` is relative to this [`Transform`]'s current rotation.
	#[inline]
pub fn rotate_local(&mut self, rotation: Quat) {
⋮----
/// Rotates this [`Transform`] around its local `axis` by `angle` (in radians).
	#[inline]
pub fn rotate_local_axis(&mut self, axis: Vec3, angle: f32) {
self.rotate_local(Quat::from_axis_angle(axis, angle));
⋮----
/// Rotates this [`Transform`] around its local `X` axis by `angle` (in radians).
	#[inline]
pub fn rotate_local_x(&mut self, angle: f32) {
self.rotate_local(Quat::from_rotation_x(angle));
⋮----
/// Rotates this [`Transform`] around its local `Y` axis by `angle` (in radians).
	#[inline]
pub fn rotate_local_y(&mut self, angle: f32) {
self.rotate_local(Quat::from_rotation_y(angle));
⋮----
/// Rotates this [`Transform`] around its local `Z` axis by `angle` (in radians).
	#[inline]
pub fn rotate_local_z(&mut self, angle: f32) {
self.rotate_local(Quat::from_rotation_z(angle));
⋮----
/// Translates this [`Transform`] around a `point` in space.
	///
⋮----
///
	/// If this [`Transform`] has a parent, the `point` is relative to the [`Transform`] of the parent.
⋮----
/// If this [`Transform`] has a parent, the `point` is relative to the [`Transform`] of the parent.
	#[inline]
pub fn translate_around(&mut self, point: Vec3, rotation: Quat) {
⋮----
/// Rotates this [`Transform`] around a `point` in space.
	///
⋮----
pub fn rotate_around(&mut self, point: Vec3, rotation: Quat) {
self.translate_around(point, rotation);
self.rotate(rotation);
⋮----
/// Rotates this [`Transform`] so that [`Transform::forward`] points towards the `target` position,
	/// and [`Transform::up`] points towards `up`.
⋮----
/// and [`Transform::up`] points towards `up`.
	///
/// In some cases it's not possible to construct a rotation. Another axis will be picked in those cases:
	/// * if `target` is the same as the transtorm translation, `Vec3::Z` is used instead
⋮----
/// * if `target` is the same as the transtorm translation, `Vec3::Z` is used instead
	/// * if `up` is zero, `Vec3::Y` is used instead
⋮----
pub fn look_at(&mut self, target: Vec3, up: Vec3) {
self.look_to(target - self.translation, up);
⋮----
/// Rotates this [`Transform`] so that [`Transform::forward`] points in the given `direction`
	/// and [`Transform::up`] points towards `up`.
⋮----
/// In some cases it's not possible to construct a rotation. Another axis will be picked in those cases:
	/// * if `direction` is zero, `Vec3::NEG_Z` is used instead
⋮----
/// * if `direction` is zero, `Vec3::NEG_Z` is used instead
	/// * if `up` is zero, `Vec3::Y` is used instead
⋮----
pub fn look_to(&mut self, direction: Vec3, up: Vec3) {
let back = -direction.try_normalize().unwrap_or(Vec3::NEG_Z);
let up = up.try_normalize().unwrap_or(Vec3::Y);
⋮----
.cross(back)
.try_normalize()
.unwrap_or_else(|| up.any_orthonormal_vector());
let up = back.cross(right);
⋮----
/// TODO: The copied doc example test fails! We need to see if we can find a hint in bevy, where this is copied from.
	///
⋮----
///
	/// Rotates this [`Transform`] so that the `main_axis` vector, reinterpreted in local coordinates, points
/// in the given `main_direction`, while `secondary_axis` points towards `secondary_direction`.
	///
⋮----
///
	/// For example, if a spaceship model has its nose pointing in the X-direction in its own local coordinates
⋮----
///
	/// More precisely, the [`Transform::rotation`] produced will be such that:
⋮----
/// More precisely, the [`Transform::rotation`] produced will be such that:
	/// * applying it to `main_axis` results in `main_direction`
⋮----
/// * applying it to `main_axis` results in `main_direction`
	/// * applying it to `secondary_axis` produces a vector that lies in the half-plane generated by `main_direction` and
⋮----
/// * applying it to `secondary_axis` produces a vector that lies in the half-plane generated by `main_direction` and
	///     `secondary_direction` (with positive contribution by `secondary_direction`)
⋮----
///     `secondary_direction` (with positive contribution by `secondary_direction`)
	///
⋮----
///
	/// [`Transform::look_to`] is recovered, for instance, when `main_axis` is `Vec3::NEG_Z` (the [`Transform::forward`]
⋮----
/// [`Transform::look_to`] is recovered, for instance, when `main_axis` is `Vec3::NEG_Z` (the [`Transform::forward`]
	/// direction in the default orientation) and `secondary_axis` is `Vec3::Y` (the [`Transform::up`] direction in the default
⋮----
/// direction in the default orientation) and `secondary_axis` is `Vec3::Y` (the [`Transform::up`] direction in the default
	/// orientation). (Failure cases may differ somewhat.)
⋮----
/// orientation). (Failure cases may differ somewhat.)
	///
⋮----
///
	/// Example
⋮----
/// Example
	/// ```
⋮----
/// ```
	/// # use glam::{Vec3, Quat};
⋮----
/// # use glam::{Vec3, Quat};
	/// # use trivalibs_core::math::transform::Transform;
⋮----
/// # use trivalibs_core::math::transform::Transform;
	/// # let mut t1 = Transform::IDENTITY;
⋮----
/// # let mut t1 = Transform::IDENTITY;
	/// # let mut t2 = Transform::IDENTITY;
⋮----
/// # let mut t2 = Transform::IDENTITY;
	/// t1.align(Vec3::X, Vec3::Y, Vec3::new(1., 1., 0.), Vec3::Z);
⋮----
/// t1.align(Vec3::X, Vec3::Y, Vec3::new(1., 1., 0.), Vec3::Z);
	/// let main_axis_image = t1.rotation * Vec3::X;
⋮----
/// let main_axis_image = t1.rotation * Vec3::X;
	/// let secondary_axis_image = t1.rotation * Vec3::new(1., 1., 0.);
⋮----
/// let secondary_axis_image = t1.rotation * Vec3::new(1., 1., 0.);
	/// assert!(main_axis_image.abs_diff_eq(Vec3::Y, 1e-5));
⋮----
/// assert!(main_axis_image.abs_diff_eq(Vec3::Y, 1e-5));
	/// assert!(secondary_axis_image.abs_diff_eq(Vec3::new(0., 1., 1.), 1e-5));
⋮----
/// assert!(secondary_axis_image.abs_diff_eq(Vec3::new(0., 1., 1.), 1e-5));
	///
⋮----
///
	/// t1.align(Vec3::ZERO, Vec3::Z, Vec3::ZERO, Vec3::X);
⋮----
/// t1.align(Vec3::ZERO, Vec3::Z, Vec3::ZERO, Vec3::X);
	/// t2.align(Vec3::X, Vec3::Z, Vec3::Y, Vec3::X);
⋮----
/// t2.align(Vec3::X, Vec3::Z, Vec3::Y, Vec3::X);
	/// assert_eq!(t1.rotation, t2.rotation);
⋮----
/// assert_eq!(t1.rotation, t2.rotation);
	///
⋮----
///
	/// t1.align(Vec3::X, Vec3::Z, Vec3::X, Vec3::Y);
⋮----
/// t1.align(Vec3::X, Vec3::Z, Vec3::X, Vec3::Y);
	/// assert_eq!(t1.rotation, Quat::from_rotation_arc(Vec3::X, Vec3::Z));
⋮----
/// assert_eq!(t1.rotation, Quat::from_rotation_arc(Vec3::X, Vec3::Z));
	/// ```
⋮----
/// ```
	#[inline]
pub fn align(
⋮----
// The solution quaternion will be constructed in two steps.
// First, we start with a rotation that takes `main_axis` to `main_direction`.
⋮----
// Let's follow by rotating about the `main_direction` axis so that the image of `secondary_axis`
// is taken to something that lies in the plane of `main_direction` and `secondary_direction`. Since
// `main_direction` is fixed by this rotation, the first criterion is still satisfied.
⋮----
.reject_from_normalized(main_direction)
.try_normalize();
⋮----
// If one of the two weak vectors was parallel to `main_direction`, then we just do the first part
⋮----
/// Multiplies `self` with `transform` component by component, returning the
	/// resulting [`Transform`]
⋮----
/// resulting [`Transform`]
	#[inline]
⋮----
pub fn mul_transform(&self, transform: Transform) -> Self {
let translation = self.transform_point(transform.translation);
⋮----
/// Transforms the given `point`, applying scale, rotation and translation.
	///
⋮----
///
	/// If this [`Transform`] has an ancestor entity with a [`Transform`] component,
⋮----
/// If this [`Transform`] has an ancestor entity with a [`Transform`] component,
	/// [`Transform::transform_point`] will transform a point in local space into its
⋮----
/// [`Transform::transform_point`] will transform a point in local space into its
	/// parent transform's space.
⋮----
/// parent transform's space.
	///
⋮----
///
	/// If this [`Transform`] does not have a parent, [`Transform::transform_point`] will
⋮----
/// If this [`Transform`] does not have a parent, [`Transform::transform_point`] will
	/// transform a point in local space into worldspace coordinates.
⋮----
/// transform a point in local space into worldspace coordinates.
	///
⋮----
///
	/// If you always want to transform a point in local space to worldspace, or if you need
⋮----
/// If you always want to transform a point in local space to worldspace, or if you need
	/// the inverse transformations, see [`GlobalTransform::transform_point()`].
⋮----
/// the inverse transformations, see [`GlobalTransform::transform_point()`].
	#[inline]
pub fn transform_point(&self, mut point: Vec3) -> Vec3 {
⋮----
/// Returns `true` if, and only if, translation, rotation and scale all are
	/// finite. If any of them contains a `NaN`, positive or negative infinity,
⋮----
/// finite. If any of them contains a `NaN`, positive or negative infinity,
	/// this will return `false`.
⋮----
/// this will return `false`.
	#[inline]
⋮----
pub fn is_finite(&self) -> bool {
self.translation.is_finite() && self.rotation.is_finite() && self.scale.is_finite()
⋮----
impl Default for Transform {
fn default() -> Self {
⋮----
type Output = Transform;
⋮----
fn mul(self, transform: Transform) -> Self::Output {
self.mul_transform(transform)
⋮----
type Output = Vec3;
⋮----
fn mul(self, value: Vec3) -> Self::Output {
self.transform_point(value)
</file>

<file path="crates/trivalibs_core/src/rendering/line_2d/buffered_geometry.rs">
pub struct VertexData {
⋮----
impl WebglVertexData for VertexData {
fn vertex_layout() -> Vec<VertexType> {
vec![
⋮----
pub struct LineGeometryProps {
⋮----
impl Default for LineGeometryProps {
fn default() -> Self {
⋮----
fn get_normal(direction: &Vec2) -> Vec2 {
⋮----
fn line_positions(vertex: Vec2, normal: Vec2, width: f32) -> [Vec2; 2] {
⋮----
fn line_mitter_positions(pos: &Vec2, dir: &Vec2, width: f32, prev_dir: Option<&Vec2>) -> [Vec2; 2] {
// for math see
// https://mattdesl.svbtle.com/drawing-lines-is-hard
// https://cesium.com/blog/2013/04/22/robust-polyline-rendering-with-webgl/ "Vertex Shader Details"
// https://www.npmjs.com/package/polyline-normals
//
let next_normal = get_normal(dir);
⋮----
if prev_dir.is_none() || dir == prev_dir.unwrap() {
return line_positions(*pos, next_normal, width);
⋮----
let prev_normal = get_normal(prev_dir.unwrap());
let normal = (next_normal + prev_normal).normalize();
let mitter_length = width / normal.dot(prev_normal);
let mitter_length = mitter_length.min(width * 5.0);
line_positions(*pos, normal, mitter_length)
⋮----
fn cross_2d(v1: Vec2, v2: Vec2) -> f32 {
⋮----
impl Line {
pub fn to_buffered_geometry_with(&self, props: LineGeometryProps) -> BufferedGeometry {
⋮----
for (prev, v, next) in self.iter().with_neighbours() {
⋮----
line_mitter_positions(&v.pos, &v.dir, v.width, prev.map(|x| &x.dir));
⋮----
if prev.is_none() {
top_line.add_width_data(v.pos, v.width, line_length);
bottom_line.add_width_data(v.pos, v.width, line_length);
⋮----
// adjust first vertex
if prev.is_none() && props.prev_direction.is_some() {
let prev_dir = props.prev_direction.unwrap();
let c = v.width / (prev_dir * -1.0 + v.dir).normalize().dot(v.dir);
⋮----
if cross_2d(v.dir, prev_dir) > 0. {
⋮----
// adjust last vertex
if next.is_none() && props.next_direction.is_some() {
let next_dir = props.next_direction.unwrap();
let c = v.width / (v.dir * -1.0 + next_dir).normalize().dot(next_dir);
⋮----
if cross_2d(next_dir, v.dir) > 0. {
⋮----
top_line.add_width_data(new_points[0], v.width, line_length);
bottom_line.add_width_data(new_points[1], v.width, line_length);
⋮----
if next.is_none() {
⋮----
top_line = top_line.smouth_edges_threshold(
⋮----
bottom_line = bottom_line.smouth_edges_threshold(
⋮----
let mut buffer = vec![];
let mut indices: Vec<u32> = vec![];
⋮----
let total_length = props.total_length.unwrap_or(line_length);
⋮----
while top_i < top_line.vert_count() || bottom_i < bottom_line.vert_count() {
let top_opt = top_line.get_opt(top_i);
let bottom_opt = bottom_line.get_opt(bottom_i);
⋮----
if top_opt.is_some() && balance <= 0. {
let top = top_opt.unwrap();
⋮----
let v = if top_i == 0 || top_i == top_line.vert_count() - 1 {
⋮----
buffer.push(top_vertex);
⋮----
indices.push(next_idx);
⋮----
indices.push(top_idx);
⋮----
if bottom_opt.is_some() && balance >= 0. {
let bottom = bottom_opt.unwrap();
⋮----
let v = if bottom_i == 0 || bottom_i == bottom_line.vert_count() - 1 {
⋮----
buffer.push(bottom_vertex);
⋮----
indices.push(bottom_idx);
⋮----
vertex_buffer: bytemuck::cast_slice(&buffer).to_vec(),
index_buffer: Some(bytemuck::cast_slice(&indices).to_vec()),
vertex_count: buffer.len() as u32,
index_count: indices.len() as u32,
⋮----
pub fn to_buffered_geometry(&self) -> BufferedGeometry {
self.to_buffered_geometry_with(default())
⋮----
pub fn to_webgl_buffered_geometry_with(
⋮----
let buffer = self.to_buffered_geometry_with(props);
⋮----
let geom_layout = create_buffered_geometry_layout(VertexData::vertex_layout());
⋮----
pub fn to_webgl_buffered_geometry(&self) -> WebglBufferedGeometry {
self.to_webgl_buffered_geometry_with(default())
⋮----
pub trait LineBufferedGeometryVec {
⋮----
impl LineBufferedGeometryVec for Vec<Line> {
fn to_buffered_geometry_with(&self, props: LineGeometryProps) -> Vec<BufferedGeometry> {
let total_length = self.iter().fold(0.0, |acc, x| acc + x.len);
⋮----
self.iter()
.enumerate()
.map_with_prev_next(|(i, line), prev, next| {
line.to_buffered_geometry_with(LineGeometryProps {
total_length: Some(total_length),
⋮----
prev_direction: prev.map(|(_, x)| x.last().dir),
next_direction: next.map(|(_, x)| x.first().dir),
⋮----
.collect()
⋮----
fn to_buffered_geometry(&self) -> Vec<BufferedGeometry> {
</file>

<file path="crates/trivalibs_core/src/rendering/shapes/quad.rs">
use crate::data::Position3D;
⋮----
use lerp::Lerp;
⋮----
pub struct Quad3D<P>
⋮----
pub fn from_dimensions_at_pos_f<F: Fn(Vec3, Vec2) -> P>(
⋮----
let normal = normal.normalize();
let up = if normal.y.abs() > 0.999 {
⋮----
let u_dir = up.cross(normal);
⋮----
let v_vec = -normal.cross(u_dir) * height;
⋮----
top_left: f(top_left, vec2(0.0, 0.0)),
bottom_left: f(bottom_left, vec2(0.0, 1.0)),
bottom_right: f(bottom_right, vec2(1.0, 1.0)),
top_right: f(top_right, vec2(1.0, 0.0)),
⋮----
pub fn from_dimensions_center_f<F: Fn(Vec3, Vec2) -> P>(
⋮----
Self::from_dimensions_at_pos_f(width, height, normal, center, vec2(0.5, 0.5), f)
⋮----
pub fn from_dimensions_tl_f<F: Fn(Vec3, Vec2) -> P>(
⋮----
Self::from_dimensions_at_pos_f(width, height, normal, top_left, vec2(0.0, 0.0), f)
⋮----
pub fn from_verts_f<F: Fn(Vec3, Vec2) -> P>(
⋮----
assert!(
⋮----
let width = u_vec.length();
let height = v_vec.length();
⋮----
assert!(width > 0.0, "width is zero");
assert!(height > 0.0, "height is zero");
⋮----
let normal = u_vec.cross(v_vec).normalize();
⋮----
pub fn from_tl_bl_tr_f<F: Fn(Vec3, Vec2) -> P>(
⋮----
pub fn from_tl_bl_br_f<F: Fn(Vec3, Vec2) -> P>(
⋮----
pub fn from_tl_br_tr_f<F: Fn(Vec3, Vec2) -> P>(
⋮----
pub fn from_br_bl_tr_f<F: Fn(Vec3, Vec2) -> P>(
⋮----
pub fn from_verts(top_left: P, bottom_left: P, bottom_right: P, top_right: P) -> Self {
let u_vec = top_right.position() - top_left.position();
let v_vec = bottom_left.position() - top_left.position();
⋮----
pub fn to_ccw_verts(&self) -> [P; 4] {
⋮----
self.top_left.clone(),
self.bottom_left.clone(),
self.bottom_right.clone(),
self.top_right.clone(),
⋮----
pub fn to_cw_verts(&self) -> [P; 4] {
⋮----
pub fn subdivide_at_v(&self, v: f32) -> (Quad3D<P>, Quad3D<P>) {
let mid_left = self.top_left.clone().lerp(self.bottom_left.clone(), v);
let mid_right = self.top_right.clone().lerp(self.bottom_right.clone(), v);
⋮----
mid_left.clone(),
mid_right.clone(),
⋮----
pub fn subdivide_at_u(&self, u: f32) -> (Quad3D<P>, Quad3D<P>) {
let mid_top = self.top_left.clone().lerp(self.top_right.clone(), u);
let mid_bottom = self.bottom_left.clone().lerp(self.bottom_right.clone(), u);
⋮----
mid_bottom.clone(),
mid_top.clone(),
⋮----
mod tests {
⋮----
use crate::rendering::mesh_geometry::utils::vert_pos_uv;
⋮----
fn test_quad() {
⋮----
Quad3D::from_dimensions_center_f(4.0, 2.0, Vec3::Z, vec3(0.0, 3.0, 0.0), vert_pos_uv);
⋮----
assert_eq!(quad.normal, vec3(0.0, 0.0, 1.0));
⋮----
assert_eq!(quad.top_left.pos, vec3(-2.0, 4.0, 0.0));
assert_eq!(quad.bottom_right.pos, vec3(2.0, 2.0, 0.0));
assert_eq!(quad.top_right.pos, vec3(2.0, 4.0, 0.0));
assert_eq!(quad.bottom_left.pos, vec3(-2.0, 2.0, 0.0));
⋮----
assert_eq!(quad.top_left.uv, vec2(0.0, 0.0,));
assert_eq!(quad.bottom_right.uv, vec2(1.0, 1.0,));
assert_eq!(quad.top_right.uv, vec2(1.0, 0.0,));
assert_eq!(quad.bottom_left.uv, vec2(0.0, 1.0,));
⋮----
vec3(0.0, 3.3, 0.0),
vec3(0.0, 0.0, 0.0),
vec2(1.0, 1.0),
⋮----
assert_eq!(quad.normal, vec3(0.0, 1.0, 0.0));
⋮----
assert_eq!(quad.top_left.pos, vec3(-1.0, 0.0, -1.0));
assert_eq!(quad.bottom_right.pos, vec3(0.0, 0.0, 0.0));
assert_eq!(quad.top_right.pos, vec3(0.0, 0.0, -1.0));
assert_eq!(quad.bottom_left.pos, vec3(-1.0, 0.0, 0.0));
</file>

<file path="crates/trivalibs_core/src/rendering/texture/mod.rs">
use trivalibs_nostd::prelude::NumExt;
⋮----
pub fn f32_to_u8(channel: f32) -> u8 {
(255.999 * channel.clamp01()) as u8
⋮----
pub fn f64_to_u8(channel: f64) -> u8 {
</file>

<file path="crates/trivalibs_core/src/lib.rs">
pub mod data;
pub mod macros;
pub mod math;
pub mod rendering;
pub mod utils;
pub mod wasm_helpers;
⋮----
pub use bytemuck;
pub use glam;
⋮----
pub mod prelude {
⋮----
pub use rand;
⋮----
pub use rand::random;
</file>

<file path="crates/trivalibs_macros/Cargo.toml">
[package]
name = "trivalibs-macros"
version = "0.1.0"
edition.workspace = true

[dependencies]
syn = { version = "2.0" }
quote = "1"

[lib]
proc-macro = true
</file>

<file path="crates/trivalibs_nostd/src/random/hash.rs">
fn u32_to_f32(x: u32) -> f32 {
⋮----
// Imported and ported from https://www.shadertoy.com/view/WttXWX
⋮----
// // --- from Chris Wellons https://nullprogram.com/blog/2018/07/31/
// https://github.com/skeeto/hash-prospector
⋮----
// bias: 0.10760229515479501
// has excellent results if tested here: https://www.shadertoy.com/view/XlGcRh
pub fn hashi(x: u32) -> u32 {
⋮----
x = x.wrapping_mul(0x21f0aaad);
⋮----
x = x.wrapping_mul(0xd35a2d97);
⋮----
// bias: 0.020888578919738908 = minimal theoretic limit
// probably hashi is good enough for most cases
pub fn hashi_triple32(x: u32) -> u32 {
⋮----
x = x.wrapping_mul(0xed5ad4bb);
⋮----
x = x.wrapping_mul(0xac4c1b51);
⋮----
x = x.wrapping_mul(0x31848bab);
⋮----
pub fn hash(x: u32) -> f32 {
u32_to_f32(hashi(x))
⋮----
// // The MIT License
// // Copyright © 2017,2024 Inigo Quilez
// // Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
⋮----
// ported from https://www.shadertoy.com/view/4tXyWN by Inigo Quilez
⋮----
pub fn hash21i(p: UVec2) -> u32 {
⋮----
pub fn hash21(p: UVec2) -> f32 {
u32_to_f32(hash21i(p))
⋮----
// https://www.pcg-random.org/
// http://www.jcgt.org/published/0009/03/02/
⋮----
// see https://www.shadertoy.com/view/XlGcRh
⋮----
pub fn hash2di(v: UVec2) -> UVec2 {
⋮----
pub fn hash2d(v: UVec2) -> Vec2 {
let hash = hash2di(v);
vec2(u32_to_f32(hash.x), u32_to_f32(hash.y))
⋮----
pub fn hash3di(v: UVec3) -> UVec3 {
⋮----
pub fn hash3d(v: UVec3) -> Vec3 {
let hash = hash3di(v);
vec3(u32_to_f32(hash.x), u32_to_f32(hash.y), u32_to_f32(hash.z))
⋮----
pub fn hash4di(v: UVec4) -> UVec4 {
⋮----
pub fn hash4d(v: UVec4) -> Vec4 {
let hash = hash4di(v);
vec4(
u32_to_f32(hash.x),
u32_to_f32(hash.y),
u32_to_f32(hash.z),
u32_to_f32(hash.w),
</file>

<file path="crates/trivalibs_nostd/src/random/mod.rs">
pub mod hash;
pub mod simplex;
</file>

<file path="crates/trivalibs_nostd/src/blur.rs">
use spirv_std::num_traits::Float;
⋮----
/// Performs a separable Gaussian blur kernel.
///
⋮----
///
/// # Arguments
⋮----
/// # Arguments
///
⋮----
///
/// * `image` - The image to be blurred.
⋮----
/// * `image` - The image to be blurred.
/// * `sampler` - The sampler used for sampling the image.
⋮----
/// * `sampler` - The sampler used for sampling the image.
/// * `diameter` - The diameter (not radius) of the circle of confusion for this fragment.
⋮----
/// * `diameter` - The diameter (not radius) of the circle of confusion for this fragment.
/// * `uv` - The texture coordinates of the fragment.
⋮----
/// * `uv` - The texture coordinates of the fragment.
/// * `res` - The resolution of the image.
⋮----
/// * `res` - The resolution of the image.
/// * `dir` - The vector, in screen-space units, from one sample to the next. For a horizontal blur this will be `vec2(1.0, 0.0)`; for a vertical blur this will be `vec2(0.0, 1.0)`.
⋮----
/// * `dir` - The vector, in screen-space units, from one sample to the next. For a horizontal blur this will be `vec2(1.0, 0.0)`; for a vertical blur this will be `vec2(0.0, 1.0)`.
///
⋮----
///
/// # Returns
⋮----
/// # Returns
///
⋮----
///
/// The resulting color of the fragment.
⋮----
/// The resulting color of the fragment.
///
⋮----
///
pub fn gaussian_blur(
⋮----
pub fn gaussian_blur(
image: &Image!(2D, type=f32, sampled),
⋮----
// Usually σ (the standard deviation) is half the radius, and the radius is
// half the diameter. So we multiply by 0.25.
⋮----
// 1.5σ is a good, somewhat aggressive default for support—the number of
// texels on each side of the center that we process.
let support = (sigma * 1.5).ceil() as i32;
⋮----
// The probability density function of the Gaussian blur is (up to constant factors) `exp(-1 / 2σ² *
// x²). We precalculate the constant factor here to avoid having to
// calculate it in the inner loop.
⋮----
// Accumulate samples on both sides of the current texel. Go two at a time,
// taking advantage of bilinear filtering.
let mut sum = image.sample(*sampler, uv);
⋮----
// This is a well-known trick to reduce the number of needed texture
// samples by a factor of two. We seek to accumulate two adjacent
// samples c₀ and c₁ with weights w₀ and w₁ respectively, with a single
// texture sample at a carefully chosen location. Observe that:
//
//     k ⋅ lerp(c₀, c₁, t) = w₀⋅c₀ + w₁⋅c₁
⋮----
//                              w₁
//     if k = w₀ + w₁ and t = ───────
//                            w₀ + w₁
⋮----
// Therefore, if we sample at a distance of t = w₁ / (w₀ + w₁) texels in
// between the two texel centers and scale by k = w₀ + w₁ afterward, we
// effectively evaluate w₀⋅c₀ + w₁⋅c₁ with a single texture lookup.
⋮----
let w0 = (exp_factor * j * j).exp();
let w1 = (exp_factor * (j + 1.0) * (j + 1.0)).exp();
⋮----
sum += (image.sample(*sampler, uv + uv_offset) + image.sample(*sampler, uv - uv_offset))
⋮----
/// Precalculated weights for a 5-tap Gaussian blur kernel.
///
⋮----
///
/// The diameter of the circle of confusion is 5.0.
⋮----
/// The diameter of the circle of confusion is 5.0.
///
⋮----
/// * `sampler` - The sampler used for sampling the image.
/// * `uv` - The texture coordinates of the fragment.
⋮----
///
pub fn gaussian_blur_5(
⋮----
pub fn gaussian_blur_5(
⋮----
let mut color = image.sample(*sampler, uv) * 0.29411764705882354;
color += image.sample(*sampler, uv + (off1 / res)) * 0.35294117647058826;
color += image.sample(*sampler, uv - (off1 / res)) * 0.35294117647058826;
⋮----
/// Precalculated weights for a 9-tap Gaussian blur kernel.
///
⋮----
///
/// The diameter of the circle of confusion is 9.0.
⋮----
/// The diameter of the circle of confusion is 9.0.
///
⋮----
///
pub fn gaussian_blur_9(
⋮----
pub fn gaussian_blur_9(
⋮----
let mut color = image.sample(*sampler, uv) * 0.2270270270;
color += image.sample(*sampler, uv + (off1 / res)) * 0.3162162162;
color += image.sample(*sampler, uv - (off1 / res)) * 0.3162162162;
color += image.sample(*sampler, uv + (off2 / res)) * 0.0702702703;
color += image.sample(*sampler, uv - (off2 / res)) * 0.0702702703;
⋮----
/// Precalculated weights for a 13-tap Gaussian blur kernel.
///
⋮----
///
/// The diameter of the circle of confusion is 13.0.
⋮----
/// The diameter of the circle of confusion is 13.0.
///
⋮----
///
pub fn gaussian_blur_13(
⋮----
pub fn gaussian_blur_13(
⋮----
let mut color = image.sample(*sampler, uv) * 0.1964825501511404;
color += image.sample(*sampler, uv + (off1 / res)) * 0.2969069646728344;
color += image.sample(*sampler, uv - (off1 / res)) * 0.2969069646728344;
color += image.sample(*sampler, uv + (off2 / res)) * 0.09447039785044732;
color += image.sample(*sampler, uv - (off2 / res)) * 0.09447039785044732;
color += image.sample(*sampler, uv + (off3 / res)) * 0.010381362401148057;
color += image.sample(*sampler, uv - (off3 / res)) * 0.010381362401148057;
⋮----
/// Performs a box blur in a single direction of the separable box blur kernel.
///
⋮----
/// * `res` - The resolution of the image.
/// * `dir` - The vector, in screen-space units, from one sample to the next. This need not be horizontal or vertical.
⋮----
/// * `dir` - The vector, in screen-space units, from one sample to the next. This need not be horizontal or vertical.
///
⋮----
/// The resulting color of the fragment.
pub fn box_blur(
⋮----
pub fn box_blur(
⋮----
let support = (diameter * 0.5).floor() as i32;
⋮----
// Accumulate samples in a single direction.
⋮----
sum += image.sample(*sampler, uv + offset * (i as f32))
+ image.sample(*sampler, uv - offset * (i as f32));
</file>

<file path="crates/trivalibs_nostd/src/coords.rs">
use spirv_std::num_traits::Float;
⋮----
pub struct PolarCoord {
⋮----
impl PolarCoord {
pub fn to_2d(&self) -> Vec2 {
vec2(
self.radius * self.angle.cos(),
self.radius * self.angle.sin(),
⋮----
pub fn as_vec(&self) -> Vec2 {
vec2(self.radius, self.angle)
⋮----
pub fn from_2d(v: Vec2) -> Self {
⋮----
radius: v.length(),
angle: v.y.atan2(v.x),
⋮----
pub fn from_vec(v: Vec2) -> Self {
⋮----
pub fn from_2d_with_center(v: Vec2, center: Vec2) -> Self {
⋮----
impl Default for PolarCoord {
fn default() -> Self {
⋮----
fn from(v: Vec2) -> Self {
⋮----
fn from(p: PolarCoord) -> Self {
p.as_vec()
</file>

<file path="crates/trivalibs_nostd/src/num_ext.rs">
use spirv_std::num_traits::Float;
⋮----
pub fn fit1101(x: f32) -> f32 {
⋮----
pub fn fit1101_f64(x: f64) -> f64 {
⋮----
pub fn fit0111(x: f32) -> f32 {
⋮----
pub fn fit0111_f64(x: f64) -> f64 {
⋮----
pub fn step(edge: f32, x: f32) -> f32 {
⋮----
pub fn step_f64(edge: f64, x: f64) -> f64 {
⋮----
/// Third order polynomial interpolation of values between 0 and 1.
/// Make sure to clamp the input to [0, 1] before using this function.
⋮----
/// Make sure to clamp the input to [0, 1] before using this function.
pub fn smoothen(t: f32) -> f32 {
⋮----
pub fn smoothen(t: f32) -> f32 {
⋮----
/// Make sure to clamp the input to [0, 1] before using this function.
pub fn smoothen_f64(t: f64) -> f64 {
⋮----
pub fn smoothen_f64(t: f64) -> f64 {
⋮----
/// Fifth order polynomial interpolation of values between 0 and 1.
/// Make sure to clamp the input to [0, 1] before using this function.
⋮----
/// Make sure to clamp the input to [0, 1] before using this function.
pub fn smoothen_more(t: f32) -> f32 {
⋮----
pub fn smoothen_more(t: f32) -> f32 {
⋮----
/// Make sure to clamp the input to [0, 1] before using this function.
pub fn smoothen_more_f64(t: f64) -> f64 {
⋮----
pub fn smoothen_more_f64(t: f64) -> f64 {
⋮----
/// Fractional part of a number. It is defined as `x - floor(x)`.
/// In contrast, std implementation fract is defined as `x - trunc(x)`, which inverts direction when negative.
⋮----
/// In contrast, std implementation fract is defined as `x - trunc(x)`, which inverts direction when negative.
pub fn frct(x: f32) -> f32 {
⋮----
pub fn frct(x: f32) -> f32 {
x - x.floor()
⋮----
/// In contrast, std implementation fract is defined as `x - trunc(x)`, which inverts direction when negative.
pub fn frct_f64(x: f64) -> f64 {
⋮----
pub fn frct_f64(x: f64) -> f64 {
⋮----
pub trait NumExt
⋮----
/// Fractional part of a number. It is defined as `x - floor(x)`.
	/// In contrast, std implementation fract is defined as `x - trunc(x)`, which inverts direction when negative.
⋮----
/// In contrast, std implementation fract is defined as `x - trunc(x)`, which inverts direction when negative.
	fn frct(self) -> Self;
⋮----
/// Third order polynomial interpolation of values between 0 and 1.
	/// Make sure to clamp the input to [0, 1] before using this function.
⋮----
/// Make sure to clamp the input to [0, 1] before using this function.
	fn smoothen(self) -> Self;
⋮----
/// Fifth order polynomial interpolation of values between 0 and 1.
	/// Make sure to clamp the input to [0, 1] before using this function.
⋮----
/// Make sure to clamp the input to [0, 1] before using this function.
	fn smoothen_more(self) -> Self;
⋮----
impl NumExt for f32 {
fn fit0111(self) -> Self {
fit0111(self)
⋮----
fn fit1101(self) -> Self {
fit1101(self)
⋮----
fn clamp01(self) -> Self {
self.clamp(0., 1.)
⋮----
fn frct(self) -> Self {
frct(self)
⋮----
fn rem(self, other: Self) -> Self {
⋮----
if r < 0.0 { r + other.abs() } else { r }
⋮----
fn lerp(self, other: Self, t: f32) -> Self {
⋮----
fn step(self, edge: Self) -> Self {
step(edge, self)
⋮----
fn gtf(self, edge: Self) -> Self {
⋮----
fn ltf(self, edge: Self) -> Self {
⋮----
fn gtef(self, edge: Self) -> Self {
⋮----
fn ltef(self, edge: Self) -> Self {
⋮----
fn step_fn<F: Fn(Self) -> Self>(self, edge0: Self, edge1: Self, f: F) -> Self {
⋮----
f(t.clamp01())
⋮----
fn smoothen(self) -> Self {
smoothen(self)
⋮----
fn smoothen_more(self) -> Self {
smoothen_more(self)
⋮----
fn smoothstep(self, edge0: Self, edge1: Self) -> Self {
self.step_fn(edge0, edge1, |t| t.smoothen())
⋮----
impl NumExt for f64 {
⋮----
fit0111_f64(self)
⋮----
fit1101_f64(self)
⋮----
frct_f64(self)
⋮----
fn lerp(self, other: Self, t: f64) -> Self {
⋮----
step_f64(edge, self)
⋮----
smoothen_f64(self)
⋮----
smoothen_more_f64(self)
</file>

<file path="crates/trivalibs_painter/src/utils/input_state.rs">
use std::collections::BTreeSet;
⋮----
pub struct DraggingState {
⋮----
pub struct InputState {
⋮----
impl Default for InputState {
fn default() -> Self {
⋮----
impl InputState {
pub fn process_event<U>(&mut self, event: Event<U>) {
⋮----
self.pressed_keys.insert(key);
⋮----
self.pressed_keys.remove(&key);
⋮----
self.pressed_pointer_buttons.insert(button);
⋮----
// Start dragging when any button is pressed
if self.dragging.is_none() {
self.dragging = Some(DraggingState {
⋮----
self.pressed_pointer_buttons.remove(&button);
⋮----
// Stop dragging when all buttons are released
if self.pressed_pointer_buttons.is_empty() {
⋮----
// Accumulate deltas while dragging
// Use mouse_lock events for raw motion (FPS-style controls)
⋮----
// Even without dragging, raw motion might be useful for FPS controls
// For now, we only track it when dragging
⋮----
/// Check if a key is currently pressed
	pub fn is_key_pressed(&self, key: KeyCode) -> bool {
⋮----
pub fn is_key_pressed(&self, key: KeyCode) -> bool {
self.pressed_keys.contains(&key)
⋮----
/// Check if a pointer button is currently pressed
	pub fn is_button_pressed(&self, button: PointerButton) -> bool {
⋮----
pub fn is_button_pressed(&self, button: PointerButton) -> bool {
self.pressed_pointer_buttons.contains(&button)
</file>

<file path="crates/trivalibs_painter/src/binding_constants.rs">
use wgpu::BindingType;
</file>

<file path="crates/trivalibs_painter/src/events.rs">
/// Custom event types for painter, independent of winit
/// Pointer button types - device-agnostic naming
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum PointerButton {
⋮----
fn from(button: winit::event::MouseButton) -> Self {
⋮----
/// Physical key codes - crate-local copy of winit's KeyCode
/// This allows WASM builds to emit events without depending on winit
⋮----
/// This allows WASM builds to emit events without depending on winit
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum KeyCode {
/// <kbd>`</kbd> on a US keyboard. This is also called a backtick or grave.
	/// This is the <kbd>半角</kbd>/<kbd>全角</kbd>/<kbd>漢字</kbd>
⋮----
/// This is the <kbd>半角</kbd>/<kbd>全角</kbd>/<kbd>漢字</kbd>
	/// (hankaku/zenkaku/kanji) key on Japanese keyboards.
⋮----
/// (hankaku/zenkaku/kanji) key on Japanese keyboards.
	Backquote,
/// Used for both the US <kbd>\\</kbd> (on the 101-key layout) and also for the key
	/// located between the <kbd>"</kbd> and <kbd>Enter</kbd> keys on row C of the 102-,
⋮----
/// located between the <kbd>"</kbd> and <kbd>Enter</kbd> keys on row C of the 102-,
	/// 104- and 106-key layouts.
⋮----
/// 104- and 106-key layouts.
	/// Labeled <kbd>#</kbd> on a UK (102) keyboard.
⋮----
/// Labeled <kbd>#</kbd> on a UK (102) keyboard.
	Backslash,
/// <kbd>[</kbd> on a US keyboard.
	BracketLeft,
/// <kbd>]</kbd> on a US keyboard.
	BracketRight,
/// <kbd>,</kbd> on a US keyboard.
	Comma,
/// <kbd>0</kbd> on a US keyboard.
	Digit0,
/// <kbd>1</kbd> on a US keyboard.
	Digit1,
/// <kbd>2</kbd> on a US keyboard.
	Digit2,
/// <kbd>3</kbd> on a US keyboard.
	Digit3,
/// <kbd>4</kbd> on a US keyboard.
	Digit4,
/// <kbd>5</kbd> on a US keyboard.
	Digit5,
/// <kbd>6</kbd> on a US keyboard.
	Digit6,
/// <kbd>7</kbd> on a US keyboard.
	Digit7,
/// <kbd>8</kbd> on a US keyboard.
	Digit8,
/// <kbd>9</kbd> on a US keyboard.
	Digit9,
/// <kbd>=</kbd> on a US keyboard.
	Equal,
/// Located between the left <kbd>Shift</kbd> and <kbd>Z</kbd> keys.
	/// Labeled <kbd>\\</kbd> on a UK keyboard.
⋮----
/// Labeled <kbd>\\</kbd> on a UK keyboard.
	IntlBackslash,
/// Located between the <kbd>/</kbd> and right <kbd>Shift</kbd> keys.
	/// Labeled <kbd>\\</kbd> (ro) on a Japanese keyboard.
⋮----
/// Labeled <kbd>\\</kbd> (ro) on a Japanese keyboard.
	IntlRo,
/// Located between the <kbd>=</kbd> and <kbd>Backspace</kbd> keys.
	/// Labeled <kbd>¥</kbd> (yen) on a Japanese keyboard. <kbd>\\</kbd> on a
⋮----
/// Labeled <kbd>¥</kbd> (yen) on a Japanese keyboard. <kbd>\\</kbd> on a
	/// Russian keyboard.
⋮----
/// Russian keyboard.
	IntlYen,
/// <kbd>a</kbd> on a US keyboard.
	/// Labeled <kbd>q</kbd> on an AZERTY (e.g., French) keyboard.
⋮----
/// Labeled <kbd>q</kbd> on an AZERTY (e.g., French) keyboard.
	KeyA,
/// <kbd>b</kbd> on a US keyboard.
	KeyB,
/// <kbd>c</kbd> on a US keyboard.
	KeyC,
/// <kbd>d</kbd> on a US keyboard.
	KeyD,
/// <kbd>e</kbd> on a US keyboard.
	KeyE,
/// <kbd>f</kbd> on a US keyboard.
	KeyF,
/// <kbd>g</kbd> on a US keyboard.
	KeyG,
/// <kbd>h</kbd> on a US keyboard.
	KeyH,
/// <kbd>i</kbd> on a US keyboard.
	KeyI,
/// <kbd>j</kbd> on a US keyboard.
	KeyJ,
/// <kbd>k</kbd> on a US keyboard.
	KeyK,
/// <kbd>l</kbd> on a US keyboard.
	KeyL,
/// <kbd>m</kbd> on a US keyboard.
	KeyM,
/// <kbd>n</kbd> on a US keyboard.
	KeyN,
/// <kbd>o</kbd> on a US keyboard.
	KeyO,
/// <kbd>p</kbd> on a US keyboard.
	KeyP,
/// <kbd>q</kbd> on a US keyboard.
	/// Labeled <kbd>a</kbd> on an AZERTY (e.g., French) keyboard.
⋮----
/// Labeled <kbd>a</kbd> on an AZERTY (e.g., French) keyboard.
	KeyQ,
/// <kbd>r</kbd> on a US keyboard.
	KeyR,
/// <kbd>s</kbd> on a US keyboard.
	KeyS,
/// <kbd>t</kbd> on a US keyboard.
	KeyT,
/// <kbd>u</kbd> on a US keyboard.
	KeyU,
/// <kbd>v</kbd> on a US keyboard.
	KeyV,
/// <kbd>w</kbd> on a US keyboard.
	/// Labeled <kbd>z</kbd> on an AZERTY (e.g., French) keyboard.
⋮----
/// Labeled <kbd>z</kbd> on an AZERTY (e.g., French) keyboard.
	KeyW,
/// <kbd>x</kbd> on a US keyboard.
	KeyX,
/// <kbd>y</kbd> on a US keyboard.
	/// Labeled <kbd>z</kbd> on a QWERTZ (e.g., German) keyboard.
⋮----
/// Labeled <kbd>z</kbd> on a QWERTZ (e.g., German) keyboard.
	KeyY,
/// <kbd>z</kbd> on a US keyboard.
	/// Labeled <kbd>w</kbd> on an AZERTY (e.g., French) keyboard, and <kbd>y</kbd> on a
⋮----
/// Labeled <kbd>w</kbd> on an AZERTY (e.g., French) keyboard, and <kbd>y</kbd> on a
	/// QWERTZ (e.g., German) keyboard.
⋮----
/// QWERTZ (e.g., German) keyboard.
	KeyZ,
/// <kbd>-</kbd> on a US keyboard.
	Minus,
/// <kbd>.</kbd> on a US keyboard.
	Period,
/// <kbd>'</kbd> on a US keyboard.
	Quote,
/// <kbd>;</kbd> on a US keyboard.
	Semicolon,
/// <kbd>/</kbd> on a US keyboard.
	Slash,
/// <kbd>Alt</kbd>, <kbd>Option</kbd>, or <kbd>⌥</kbd>.
	AltLeft,
/// <kbd>Alt</kbd>, <kbd>Option</kbd>, or <kbd>⌥</kbd>.
	/// This is labeled <kbd>AltGr</kbd> on many keyboard layouts.
⋮----
/// This is labeled <kbd>AltGr</kbd> on many keyboard layouts.
	AltRight,
/// <kbd>Backspace</kbd> or <kbd>⌫</kbd>.
	/// Labeled <kbd>Delete</kbd> on Apple keyboards.
⋮----
/// Labeled <kbd>Delete</kbd> on Apple keyboards.
	Backspace,
/// <kbd>CapsLock</kbd> or <kbd>⇪</kbd>
	CapsLock,
/// The application context menu key, which is typically found between the right
	/// <kbd>Super</kbd> key and the right <kbd>Control</kbd> key.
⋮----
/// <kbd>Super</kbd> key and the right <kbd>Control</kbd> key.
	ContextMenu,
/// <kbd>Control</kbd> or <kbd>⌃</kbd>
	ControlLeft,
/// <kbd>Control</kbd> or <kbd>⌃</kbd>
	ControlRight,
/// <kbd>Enter</kbd> or <kbd>↵</kbd>. Labeled <kbd>Return</kbd> on Apple keyboards.
	Enter,
/// The Windows, <kbd>⌘</kbd>, <kbd>Command</kbd>, or other OS symbol key.
	SuperLeft,
/// The Windows, <kbd>⌘</kbd>, <kbd>Command</kbd>, or other OS symbol key.
	SuperRight,
/// <kbd>Shift</kbd> or <kbd>⇧</kbd>
	ShiftLeft,
/// <kbd>Shift</kbd> or <kbd>⇧</kbd>
	ShiftRight,
/// <kbd> </kbd> (space)
	Space,
/// <kbd>Tab</kbd> or <kbd>⇥</kbd>
	Tab,
/// Japanese: <kbd>変</kbd> (henkan)
	Convert,
/// Japanese: <kbd>カタカナ</kbd>/<kbd>ひらがな</kbd>/<kbd>ローマ字</kbd> (katakana/hiragana/romaji)
	KanaMode,
/// Korean: HangulMode <kbd>한/영</kbd> (han/yeong)
	///
⋮----
///
	/// Japanese (Mac keyboard): <kbd>か</kbd> (kana)
⋮----
/// Japanese (Mac keyboard): <kbd>か</kbd> (kana)
	Lang1,
/// Korean: Hanja <kbd>한</kbd> (hanja)
	///
⋮----
///
	/// Japanese (Mac keyboard): <kbd>英</kbd> (eisu)
⋮----
/// Japanese (Mac keyboard): <kbd>英</kbd> (eisu)
	Lang2,
/// Japanese (word-processing keyboard): Katakana
	Lang3,
/// Japanese (word-processing keyboard): Hiragana
	Lang4,
/// Japanese (word-processing keyboard): Zenkaku/Hankaku
	Lang5,
/// Japanese: <kbd>無変換</kbd> (muhenkan)
	NonConvert,
/// <kbd>⌦</kbd>. The forward delete key.
	/// Note that on Apple keyboards, the key labelled <kbd>Delete</kbd> on the main part of
⋮----
/// Note that on Apple keyboards, the key labelled <kbd>Delete</kbd> on the main part of
	/// the keyboard is encoded as [`Backspace`].
⋮----
/// the keyboard is encoded as [`Backspace`].
	///
⋮----
///
	/// [`Backspace`]: Self::Backspace
⋮----
/// [`Backspace`]: Self::Backspace
	Delete,
/// <kbd>Page Down</kbd>, <kbd>End</kbd>, or <kbd>↘</kbd>
	End,
/// <kbd>Help</kbd>. Not present on standard PC keyboards.
	Help,
/// <kbd>Home</kbd> or <kbd>↖</kbd>
	Home,
/// <kbd>Insert</kbd> or <kbd>Ins</kbd>. Not present on Apple keyboards.
	Insert,
/// <kbd>Page Down</kbd>, <kbd>PgDn</kbd>, or <kbd>⇟</kbd>
	PageDown,
/// <kbd>Page Up</kbd>, <kbd>PgUp</kbd>, or <kbd>⇞</kbd>
	PageUp,
/// <kbd>↓</kbd>
	ArrowDown,
/// <kbd>←</kbd>
	ArrowLeft,
/// <kbd>→</kbd>
	ArrowRight,
/// <kbd>↑</kbd>
	ArrowUp,
/// On the Mac, this is used for the numpad <kbd>Clear</kbd> key.
	NumLock,
/// <kbd>0 Ins</kbd> on a keyboard. <kbd>0</kbd> on a phone or remote control
	Numpad0,
/// <kbd>1 End</kbd> on a keyboard. <kbd>1</kbd> or <kbd>1 QZ</kbd> on a phone or remote control
	Numpad1,
/// <kbd>2 ↓</kbd> on a keyboard. <kbd>2 ABC</kbd> on a phone or remote control
	Numpad2,
/// <kbd>3 PgDn</kbd> on a keyboard. <kbd>3 DEF</kbd> on a phone or remote control
	Numpad3,
/// <kbd>4 ←</kbd> on a keyboard. <kbd>4 GHI</kbd> on a phone or remote control
	Numpad4,
/// <kbd>5</kbd> on a keyboard. <kbd>5 JKL</kbd> on a phone or remote control
	Numpad5,
/// <kbd>6 →</kbd> on a keyboard. <kbd>6 MNO</kbd> on a phone or remote control
	Numpad6,
/// <kbd>7 Home</kbd> on a keyboard. <kbd>7 PQRS</kbd> or <kbd>7 PRS</kbd> on a phone
	/// or remote control
⋮----
/// or remote control
	Numpad7,
/// <kbd>8 ↑</kbd> on a keyboard. <kbd>8 TUV</kbd> on a phone or remote control
	Numpad8,
/// <kbd>9 PgUp</kbd> on a keyboard. <kbd>9 WXYZ</kbd> or <kbd>9 WXY</kbd> on a phone
	/// or remote control
⋮----
/// or remote control
	Numpad9,
/// <kbd>+</kbd>
	NumpadAdd,
/// Found on the Microsoft Natural Keyboard.
	NumpadBackspace,
/// <kbd>C</kbd> or <kbd>A</kbd> (All Clear). Also for use with numpads that have a
	/// <kbd>Clear</kbd> key that is separate from the <kbd>NumLock</kbd> key. On the Mac, the
⋮----
/// <kbd>Clear</kbd> key that is separate from the <kbd>NumLock</kbd> key. On the Mac, the
	/// numpad <kbd>Clear</kbd> key is encoded as [`NumLock`].
⋮----
/// numpad <kbd>Clear</kbd> key is encoded as [`NumLock`].
	///
⋮----
///
	/// [`NumLock`]: Self::NumLock
⋮----
/// [`NumLock`]: Self::NumLock
	NumpadClear,
/// <kbd>C</kbd> (Clear Entry)
	NumpadClearEntry,
/// <kbd>,</kbd> (thousands separator). For locales where the thousands separator
	/// is a "." (e.g., Brazil), this key may generate a <kbd>.</kbd>.
⋮----
/// is a "." (e.g., Brazil), this key may generate a <kbd>.</kbd>.
	NumpadComma,
/// <kbd>. Del</kbd>. For locales where the decimal separator is "," (e.g.,
	/// Brazil), this key may generate a <kbd>,</kbd>.
⋮----
/// Brazil), this key may generate a <kbd>,</kbd>.
	NumpadDecimal,
/// <kbd>/</kbd>
	NumpadDivide,
⋮----
/// <kbd>=</kbd>
	NumpadEqual,
/// <kbd>#</kbd> on a phone or remote control device. This key is typically found
	/// below the <kbd>9</kbd> key and to the right of the <kbd>0</kbd> key.
⋮----
/// below the <kbd>9</kbd> key and to the right of the <kbd>0</kbd> key.
	NumpadHash,
/// <kbd>M</kbd> Add current entry to the value stored in memory.
	NumpadMemoryAdd,
/// <kbd>M</kbd> Clear the value stored in memory.
	NumpadMemoryClear,
/// <kbd>M</kbd> Replace the current entry with the value stored in memory.
	NumpadMemoryRecall,
/// <kbd>M</kbd> Replace the value stored in memory with the current entry.
	NumpadMemoryStore,
/// <kbd>M</kbd> Subtract current entry from the value stored in memory.
	NumpadMemorySubtract,
/// <kbd>*</kbd> on a keyboard. For use with numpads that provide mathematical
	/// operations (<kbd>+</kbd>, <kbd>-</kbd> <kbd>*</kbd> and <kbd>/</kbd>).
⋮----
/// operations (<kbd>+</kbd>, <kbd>-</kbd> <kbd>*</kbd> and <kbd>/</kbd>).
	///
⋮----
///
	/// Use `NumpadStar` for the <kbd>*</kbd> key on phones and remote controls.
⋮----
/// Use `NumpadStar` for the <kbd>*</kbd> key on phones and remote controls.
	NumpadMultiply,
/// <kbd>(</kbd> Found on the Microsoft Natural Keyboard.
	NumpadParenLeft,
/// <kbd>)</kbd> Found on the Microsoft Natural Keyboard.
	NumpadParenRight,
/// <kbd>*</kbd> on a phone or remote control device.
	///
⋮----
///
	/// This key is typically found below the <kbd>7</kbd> key and to the left of
⋮----
/// This key is typically found below the <kbd>7</kbd> key and to the left of
	/// the <kbd>0</kbd> key.
⋮----
/// the <kbd>0</kbd> key.
	///
⋮----
///
	/// Use <kbd>"NumpadMultiply"</kbd> for the <kbd>*</kbd> key on
⋮----
/// Use <kbd>"NumpadMultiply"</kbd> for the <kbd>*</kbd> key on
	/// numeric keypads.
⋮----
/// numeric keypads.
	NumpadStar,
/// <kbd>-</kbd>
	NumpadSubtract,
/// <kbd>Esc</kbd> or <kbd>⎋</kbd>
	Escape,
/// <kbd>Fn</kbd> This is typically a hardware key that does not generate a separate code.
	Fn,
/// <kbd>FLock</kbd> or <kbd>FnLock</kbd>. Function Lock key. Found on the Microsoft
	/// Natural Keyboard.
⋮----
/// Natural Keyboard.
	FnLock,
/// <kbd>PrtScr SysRq</kbd> or <kbd>Print Screen</kbd>
	PrintScreen,
/// <kbd>Scroll Lock</kbd>
	ScrollLock,
/// <kbd>Pause Break</kbd>
	Pause,
/// Some laptops place this key to the left of the <kbd>↑</kbd> key.
	///
⋮----
///
	/// This also the "back" button (triangle) on Android.
⋮----
/// This also the "back" button (triangle) on Android.
	BrowserBack,
⋮----
/// Some laptops place this key to the right of the <kbd>↑</kbd> key.
	BrowserForward,
/// The "home" button on Android.
	BrowserHome,
⋮----
/// <kbd>Eject</kbd> or <kbd>⏏</kbd>. This key is placed in the function section on some Apple
	/// keyboards.
⋮----
/// keyboards.
	Eject,
/// Sometimes labelled <kbd>My Computer</kbd> on the keyboard
	LaunchApp1,
/// Sometimes labelled <kbd>Calculator</kbd> on the keyboard
	LaunchApp2,
⋮----
/// This key is placed in the function section on some Apple keyboards, replacing the
	/// <kbd>Eject</kbd> key.
⋮----
/// <kbd>Eject</kbd> key.
	Power,
⋮----
// Legacy modifier key. Also called "Super" in certain places.
⋮----
// Legacy modifier key.
⋮----
/// Found on Sun's USB keyboard.
	Again,
/// Found on Sun's USB keyboard.
	Copy,
/// Found on Sun's USB keyboard.
	Cut,
/// Found on Sun's USB keyboard.
	Find,
/// Found on Sun's USB keyboard.
	Open,
/// Found on Sun's USB keyboard.
	Paste,
/// Found on Sun's USB keyboard.
	Props,
/// Found on Sun's USB keyboard.
	Select,
/// Found on Sun's USB keyboard.
	Undo,
/// Use for dedicated <kbd>ひらがな</kbd> key found on some Japanese word processing keyboards.
	Hiragana,
/// Use for dedicated <kbd>カタカナ</kbd> key found on some Japanese word processing keyboards.
	Katakana,
/// General-purpose function key.
	/// Usually found at the top of the keyboard.
⋮----
/// Usually found at the top of the keyboard.
	F1,
⋮----
/// Usually found at the top of the keyboard.
	F2,
⋮----
/// Usually found at the top of the keyboard.
	F3,
⋮----
/// Usually found at the top of the keyboard.
	F4,
⋮----
/// Usually found at the top of the keyboard.
	F5,
⋮----
/// Usually found at the top of the keyboard.
	F6,
⋮----
/// Usually found at the top of the keyboard.
	F7,
⋮----
/// Usually found at the top of the keyboard.
	F8,
⋮----
/// Usually found at the top of the keyboard.
	F9,
⋮----
/// Usually found at the top of the keyboard.
	F10,
⋮----
/// Usually found at the top of the keyboard.
	F11,
⋮----
/// Usually found at the top of the keyboard.
	F12,
⋮----
/// Usually found at the top of the keyboard.
	F13,
⋮----
/// Usually found at the top of the keyboard.
	F14,
⋮----
/// Usually found at the top of the keyboard.
	F15,
⋮----
/// Usually found at the top of the keyboard.
	F16,
⋮----
/// Usually found at the top of the keyboard.
	F17,
⋮----
/// Usually found at the top of the keyboard.
	F18,
⋮----
/// Usually found at the top of the keyboard.
	F19,
⋮----
/// Usually found at the top of the keyboard.
	F20,
⋮----
/// Usually found at the top of the keyboard.
	F21,
⋮----
/// Usually found at the top of the keyboard.
	F22,
⋮----
/// Usually found at the top of the keyboard.
	F23,
⋮----
/// Usually found at the top of the keyboard.
	F24,
/// General-purpose function key.
	F25,
/// General-purpose function key.
	F26,
/// General-purpose function key.
	F27,
/// General-purpose function key.
	F28,
/// General-purpose function key.
	F29,
/// General-purpose function key.
	F30,
/// General-purpose function key.
	F31,
/// General-purpose function key.
	F32,
/// General-purpose function key.
	F33,
/// General-purpose function key.
	F34,
/// General-purpose function key.
	F35,
⋮----
fn from(key: winit::keyboard::KeyCode) -> Self {
⋮----
_ => KeyCode::Escape, // Fallback for any unmapped keys
⋮----
/// Custom events for painter applications
#[derive(Debug)]
pub enum Event<UserEvent> {
/// Pointer button pressed
	PointerDown {
⋮----
/// Pointer button released
	PointerUp {
⋮----
/// Pointer moved
	/// When mouse_lock is false: x/y are absolute cursor coordinates, delta_x/delta_y show movement
⋮----
/// When mouse_lock is false: x/y are absolute cursor coordinates, delta_x/delta_y show movement
	/// When mouse_lock is true: x/y are 0, delta_x/delta_y contain raw motion deltas
⋮----
/// When mouse_lock is true: x/y are 0, delta_x/delta_y contain raw motion deltas
	PointerMove {
⋮----
/// Key pressed
	KeyDown { key: KeyCode },
/// Key released
	KeyUp { key: KeyCode },
/// User-defined event
	UserEvent(UserEvent),
/// Shader file was reloaded (debug mode only)
	ShaderReloadEvent,
</file>

<file path="crates/trivalibs_painter/src/pipeline.rs">
use trivalibs_core::utils::default;
⋮----
pub(crate) struct PipelineStorage {
⋮----
#[allow(dead_code)] // not used in WASM builds
⋮----
impl PipelineStorage {
pub(crate) fn create_shape_pipeline(painter: &Painter, shape: Shape, layer: Layer) -> Self {
⋮----
.iter()
.map(|f| {
Some(wgpu::ColorTargetState {
⋮----
blend: Some(sp.blend_state),
⋮----
.create_shader_module(wgpu::ShaderModuleDescriptor {
⋮----
source: make_spirv(&sd.vertex_bytes.as_ref().unwrap()),
⋮----
source: make_spirv(&sd.fragment_bytes.as_ref().unwrap()),
⋮----
.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
⋮----
layout: Some(&sd.pipeline_layout),
⋮----
compilation_options: default(),
⋮----
fragment: Some(wgpu::FragmentState {
⋮----
targets: targets.as_slice(),
⋮----
// Setting this to anything other than Fill requires Features::NON_FILL_POLYGON_MODE
⋮----
depth_stencil: if l.depth_texture.is_some() {
Some(wgpu::DepthStencilState {
⋮----
stencil: default(),
bias: default(),
⋮----
count: if l.multisampled_textures.is_empty() {
⋮----
layer: Some(layer),
shape: Some(shape),
⋮----
pub(crate) fn create_effect_pipeline(painter: &Painter, effect: Effect, layer: Layer) -> Self {
⋮----
source: make_spirv(&s.fragment_bytes.as_ref().unwrap()),
⋮----
blend: Some(e.blend_state),
⋮----
layout: Some(&s.pipeline_layout),
⋮----
entry_point: Some("vs_main"),
⋮----
..default()
⋮----
effect: Some(effect),
⋮----
pub(crate) fn recreate(self, painter: &Painter) -> Self {
</file>

<file path="examples/blur/shader/src/lib.rs">
pub fn triangle_vs(pos: Vec2, uv: Vec2, #[spirv(position)] out_pos: &mut Vec4, out_uv: &mut Vec2) {
*out_pos = pos.extend(0.0).extend(1.0);
⋮----
pub fn triangle_fs(uv: Vec2, out: &mut Vec4) {
*out = vec4(uv.x, uv.y, 0.0, 1.0);
⋮----
pub fn blur_fs(
⋮----
#[spirv(descriptor_set = 1, binding = 0)] tex: &Image!(2D, type=f32, sampled),
⋮----
// for bluring in one pass
// *out = gaussian_blur(tex, sampler, *diameter, uv, *resolution, *dir);
⋮----
// for bluring in multiple passes
*out = gaussian_blur_9(tex, sampler, uv, *resolution, *dir * *diameter);
</file>

<file path="examples/deferred_light/shader/src/lib.rs">
use spirv_std::num_traits::Float;
⋮----
pub fn scene_vs(
⋮----
*out_norm = normal_rot.mul_vec3(normal);
let pos = *model_mat * position.extend(1.0);
*out_pos = pos.xyz();
⋮----
pub fn scene_fs(
⋮----
*frag_color = in_color.extend(1.0);
*frag_norm = in_norm.extend(0.0);
*frag_pos = in_pos.extend(in_depth);
⋮----
pub fn light_fs(
⋮----
#[spirv(descriptor_set = 1, binding = 0)] color_tex: &Image!(2D, type=f32, sampled),
#[spirv(descriptor_set = 1, binding = 1)] normal_tex: &Image!(2D, type=f32, sampled),
#[spirv(descriptor_set = 1, binding = 2)] pos_tex: &Image!(2D, type=f32, sampled),
⋮----
let color = color_tex.sample(*sampler, in_uv).xyz();
let normal = normal_tex.sample(*sampler, in_uv).xyz().normalize();
let pos = pos_tex.sample(*sampler, in_uv).xyz();
⋮----
let light_dir = (*light_pos - pos).normalize();
let view_dir = (*eye_pos - pos).normalize();
let half_dir = (light_dir + view_dir).normalize();
⋮----
// Half Lambert diffuse
let n_dot_l = normal.dot(light_dir);
let diffuse = *light_color * n_dot_l.max(0.0);
⋮----
// Specular (Blinn-Phong)
let n_dot_h = normal.dot(half_dir).max(0.0);
let specular = *light_color * n_dot_h.powf(30.0) * 1.8;
⋮----
// let final_color = (color.xyz() * (1.0 - (pos.w / 25.0))).extend(1.0);
⋮----
// let final_color = Vec3::splat(1.0) * diffuse + specular;
*frag_color = final_color.extend(1.0);
</file>

<file path="examples/dynamic_texture/shader/src/lib.rs">
/// Fragment shader that samples a texture.
/// This is used for the display layer that switches between red/blue textures.
⋮----
/// This is used for the display layer that switches between red/blue textures.
#[spirv(fragment)]
pub fn tex_fs(
⋮----
#[spirv(descriptor_set = 1, binding = 0)] tex: &Image!(2D, type=f32, sampled),
⋮----
*out = tex.sample(*sampler, uv);
⋮----
/// Fragment shader that outputs a solid color from a uniform.
/// This is used to create the red and blue layers.
⋮----
/// This is used to create the red and blue layers.
#[spirv(fragment)]
pub fn col_fs(
⋮----
*out = color.xyz().extend(1.0);
</file>

<file path="examples/dynamic_texture/shader/Cargo.toml">
[package]
name = "dynamic_texture_shader"
edition.workspace = true
version = "0.1.0"

[lib]
crate-type = ["rlib", "cdylib"]

[dependencies]
spirv-std.workspace = true
</file>

<file path="examples/dynamic_texture/shader/manifest.json">
[
  {
    "source_path": "col_fs.spv",
    "entry_point": "col_fs",
    "wgsl_entry_point": "col_fs"
  },
  {
    "source_path": "tex_fs.spv",
    "entry_point": "tex_fs",
    "wgsl_entry_point": "tex_fs"
  }
]
</file>

<file path="examples/layer_tex/shader/src/lib.rs">
pub fn color_vs(
⋮----
*out_pos = *mvp * pos.extend(1.0);
⋮----
pub fn color_fs(#[spirv(uniform, descriptor_set = 0, binding = 1)] color: &Vec3, out: &mut Vec4) {
*out = vec4(color.x, color.y, color.z, 1.0);
⋮----
// Texture shader
⋮----
pub fn texture_vs(
⋮----
pub fn texture_fs(
⋮----
#[spirv(descriptor_set = 1, binding = 0)] tex: &Image!(2D, type=f32, sampled),
⋮----
*out = tex.sample(*sampler, uv);
</file>

<file path="examples/random_lines/shader/Cargo.toml">
[package]
name = "random_lines_shader"
edition.workspace = true
version = "0.1.0"

[lib]
crate-type = ["rlib", "cdylib"]

[dependencies]
spirv-std.workspace = true
</file>

<file path="examples/random_lines/shader/manifest.json">
[
  {
    "source_path": "fragment.spv",
    "entry_point": "fragment",
    "wgsl_entry_point": "fragment"
  },
  {
    "source_path": "vertex.spv",
    "entry_point": "vertex",
    "wgsl_entry_point": "vertex"
  }
]
</file>

<file path="examples/render_to_mip/shader/manifest.json">
[
  {
    "source_path": "image.spv",
    "entry_point": "image",
    "wgsl_entry_point": "image"
  },
  {
    "source_path": "mip_sampling.spv",
    "entry_point": "mip_sampling",
    "wgsl_entry_point": "mip_sampling"
  }
]
</file>

<file path="examples/shader_image/shader/manifest.json">
[
  {
    "source_path": "main_fs.spv",
    "entry_point": "main_fs",
    "wgsl_entry_point": "main_fs"
  },
  {
    "source_path": "main_vs.spv",
    "entry_point": "main_vs",
    "wgsl_entry_point": "main_vs"
  }
]
</file>

<file path="examples/shader_image/main.rs">
use std::io::Write;
⋮----
fn output_image_native(image_data: Vec<u8>, texture_dims: (usize, usize), path: String) {
let mut png_data = Vec::<u8>::with_capacity(image_data.len());
⋮----
encoder.set_color(png::ColorType::Rgba);
let mut png_writer = encoder.write_header().unwrap();
png_writer.write_image_data(&image_data[..]).unwrap();
png_writer.finish().unwrap();
⋮----
let mut file = std::fs::File::create(&path).unwrap();
file.write_all(&png_data[..]).unwrap();
⋮----
async fn run(_path: Option<String>) {
// This will later store the raw pixel value data locally. We'll create it now as
// a convenient size reference.
⋮----
.request_adapter(&wgpu::RequestAdapterOptions::default())
⋮----
.unwrap();
⋮----
.request_device(&wgpu::DeviceDescriptor {
⋮----
// Load the shaders from disk
let vert = device.create_shader_module(include_spirv!("./shader/main_vs.spv"));
let frag = device.create_shader_module(include_spirv!("./shader/main_fs.spv"));
⋮----
let render_target = device.create_texture(&wgpu::TextureDescriptor {
⋮----
let output_staging_buffer = device.create_buffer(&wgpu::BufferDescriptor {
⋮----
size: texture_data.capacity() as u64,
⋮----
let pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
⋮----
fragment: Some(wgpu::FragmentState {
⋮----
targets: &[Some(wgpu::TextureFormat::Rgba8UnormSrgb.into())],
⋮----
//-----------------------------------------------
⋮----
let texture_view = render_target.create_view(&wgpu::TextureViewDescriptor::default());
⋮----
device.create_command_encoder(&wgpu::CommandEncoderDescriptor::default());
⋮----
let mut render_pass = command_encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
⋮----
color_attachments: &[Some(wgpu::RenderPassColorAttachment {
⋮----
render_pass.set_pipeline(&pipeline);
render_pass.draw(0..3, 0..1);
⋮----
// The texture now contains our rendered image
command_encoder.copy_texture_to_buffer(
⋮----
// This needs to be a multiple of 256. Normally we would need to pad
// it but we here know it will work out anyways.
bytes_per_row: Some((TEXTURE_DIMS.0 * 4) as u32),
rows_per_image: Some(TEXTURE_DIMS.1 as u32),
⋮----
queue.submit(Some(command_encoder.finish()));
⋮----
// Time to get our image.
let buffer_slice = output_staging_buffer.slice(..);
⋮----
buffer_slice.map_async(wgpu::MapMode::Read, move |r| sender.send(r).unwrap());
device.poll(wgpu::PollType::Wait).unwrap();
receiver.recv_async().await.unwrap().unwrap();
⋮----
let view = buffer_slice.get_mapped_range();
texture_data.extend_from_slice(&view[..]);
⋮----
output_staging_buffer.unmap();
⋮----
output_image_native(texture_data.to_vec(), TEXTURE_DIMS, _path.unwrap());
⋮----
pub fn main() {
⋮----
.filter_level(log::LevelFilter::Info)
.format_timestamp(None)
.init();
⋮----
.nth(2)
.unwrap_or_else(|| "output.png".to_string());
⋮----
pollster::block_on(run(Some(path)));
</file>

<file path="examples/simple_triangle/shader/src/lib.rs">
use spirv_std::spirv;
⋮----
pub fn vertex(
⋮----
*clip_pos = *vp_mat * *model_mat * position.extend(1.0);
⋮----
pub fn fragment(
</file>

<file path="examples/simple_triangle/shader/Cargo.toml">
[package]
name = "simple_triangle_shader"
edition.workspace = true
version = "0.1.0"

[lib]
crate-type = ["rlib", "cdylib"]

[dependencies]
spirv-std.workspace = true
</file>

<file path="examples/simple_triangle/shader/manifest.json">
[
  {
    "source_path": "fragment.spv",
    "entry_point": "fragment",
    "wgsl_entry_point": "fragment"
  },
  {
    "source_path": "vertex.spv",
    "entry_point": "vertex",
    "wgsl_entry_point": "vertex"
  }
]
</file>

<file path="examples/triangle/shader/manifest.json">
[
  {
    "source_path": "fragment.spv",
    "entry_point": "fragment",
    "wgsl_entry_point": "fragment"
  },
  {
    "source_path": "vertex.spv",
    "entry_point": "vertex",
    "wgsl_entry_point": "vertex"
  }
]
</file>

<file path="examples/user_event/shader/manifest.json">
[
  {
    "source_path": "fragment.spv",
    "entry_point": "fragment",
    "wgsl_entry_point": "fragment"
  },
  {
    "source_path": "vertex.spv",
    "entry_point": "vertex",
    "wgsl_entry_point": "vertex"
  }
]
</file>

<file path=".gitignore">
.DS_Store
.vscode

# Generated by Cargo
# will have compiled files and executables
/target/

# These are backup files generated by rustfmt
**/*.rs.bk

# Added by cargo
#
# already existing elements were commented out

/target
#Cargo.lock
spirv-manifest.json

/output.png
</file>

<file path="painter_technical_overview.md">
# trivalibs_painter — Technical Overview for WebGPU Reimplementation

This document describes the architecture, abstractions, and design decisions of `trivalibs_painter` for someone who wants to reimplement the same concepts in a different language (e.g. TypeScript/JavaScript) targeting the WebGPU browser API. The focus is on _what_ the abstractions do and _why_, not on Rust-specific implementation details.

---

## Motivation

The WebGPU API is low-level by design. Rendering a single triangle requires: creating a shader module, specifying a vertex buffer layout, building a bind group layout, creating a pipeline layout, creating a render pipeline, allocating a vertex buffer, writing data to it, creating a command encoder, beginning a render pass, setting the pipeline, setting the vertex buffer, drawing, ending the pass, and submitting to the queue.

For iterative creative work — building generative graphics, visual effects, or interactive simulations — this boilerplate is the enemy. `trivalibs_painter` collapses this into five composable primitives:

- **Shade**: the shader program and its input contract
- **Form**: the geometry data on the GPU
- **Shape**: a drawable object (Form + Shade + data bindings)
- **Effect**: a fullscreen post-processing pass — a Shape specialization that requires no Form and no vertex shader; the geometry is always the full viewport quad, driven by a built-in vertex shader
- **Layer**: a render target containing an ordered list of Shapes and Effects to render

**Shape and Effect share the same abstraction for bindings, blend state, and instancing.** The only difference is that a Shape requires explicit geometry (a Form) and a full vertex+fragment Shade, while an Effect replaces both with the implicit fullscreen quad and a fragment-only Shade. This makes Effects a natural, first-class primitive rather than a special-cased feature of Layer.

These map cleanly to WebGPU concepts but at a much higher level of abstraction.

---

## Core Design Principles

Before describing each abstraction, it helps to understand the principles that govern the whole system.

### 1. Handles, not objects

Every GPU resource is represented by a lightweight **handle** — an opaque identifier (an integer index) rather than a rich object. All actual GPU resources (buffers, textures, pipelines, bind groups) live in a central **Painter** registry.

This means handles are cheap to copy and store anywhere. There are no reference counts, no lifetimes, no ownership concerns in user code. The Painter owns everything.

### 2. Builders for creation

All resources are created through a **builder pattern**: you configure a resource with a chain of method calls, then call `.create()` to finalize it and get back a handle. After creation, resources are not reconfigured — you update _data_ (write new values to GPU buffers) but not _structure_ (the pipeline layout, attribute format, etc.).

### 3. Lazy pipeline creation

WebGPU `GPURenderPipeline` objects are expensive to create. The Painter creates them on demand (at first render) and caches them, keyed by a hash of their configuration (shader + blend state + topology + cull mode). Multiple Shapes that share the same configuration reuse the same pipeline.

### 4. Declarative rendering

You declare _what_ to render (shapes in a layer) and _how_ (bindings, blend state, multisampling). The Painter executes the actual render passes. The frame loop is simply:

```
update data → painter.paint(layer) → painter.show(layer)
```

### 5. Binding hierarchy

Data is passed to shaders at three levels, from lowest to highest priority:

```
Layer bindings  →  Shape/Effect bindings  →  Instance bindings
```

Higher levels override lower levels at the same binding slot. This lets you share a view-projection matrix at the layer level and override only the model matrix per shape.

---

## The Painter

The `Painter` is the central registry and execution engine. It holds:

- The WebGPU device and queue
- Storage arrays for all resources (shades, forms, shapes, layers, effects, buffers, textures, samplers, bind groups)
- A cache of `GPURenderPipeline` objects
- The surface / canvas for display

All builder methods are on the Painter: `painter.shade(...)`, `painter.form(...)`, `painter.shape(...)`, `painter.layer()`, etc.

**In a JavaScript/TypeScript reimplementation**, the Painter would be a class holding a `GPUDevice`, `GPUQueue`, and arrays of stored resources. Handles would simply be integer indices into those arrays.

```typescript
class Painter {
  device: GPUDevice;
  queue: GPUQueue;
  canvas: HTMLCanvasElement;
  context: GPUCanvasContext;

  // Resource storage
  shades: ShadeStorage[];
  forms: FormStorage[];
  shapes: ShapeStorage[];
  layers: LayerStorage[];
  effects: EffectStorage[];
  buffers: GPUBuffer[];
  textures: TextureStorage[];
  samplers: GPUSampler[];
  bindGroups: BindGroupStorage[];

  // Pipeline cache
  pipelines: Map<string, GPURenderPipeline>;
}
```

---

## Shade — The Shader Program and Its Contract

### Concept

A `Shade` defines:

1. The **vertex attribute layout**: what data each vertex carries (position, normal, UV, etc.) and how it's packed in memory
2. The **binding layout**: what uniform buffers, samplers, and input textures the shader expects, at which slots, and in which shader stage (vertex or fragment)
3. The **shader code** itself

This is a combination of WebGPU's `GPUShaderModule`, `GPUBindGroupLayout`, and `GPUVertexBufferLayout`.

The key insight is that the Shade defines a _contract_: any Shape using this Shade must supply data matching these layouts. The Shade is reusable across many Shapes.

### Vertex Attributes

Attributes are described as an ordered list of `GPUVertexFormat` values. The Shade automatically computes the stride (total bytes per vertex) and assigns each attribute a sequential shader location.

For example, `[Float32x3, Float32x3, Float32x2]` means:

- Location 0: `vec3f` at offset 0 (12 bytes)
- Location 1: `vec3f` at offset 12 (12 bytes)
- Location 2: `vec2f` at offset 24 (8 bytes)
- Stride: 44 bytes

This becomes the `GPUVertexBufferLayout` passed to the pipeline descriptor.

### Binding Layouts

Bindings are declared as an ordered list of binding types, each producing a `GPUBindGroupLayoutEntry`. Supported types include:

- `BINDING_BUFFER_VERT` — uniform buffer, visible in vertex shader
- `BINDING_BUFFER_FRAG` — uniform buffer, visible in fragment shader
- `BINDING_BUFFER_VERT_FRAG` — uniform buffer, visible in both
- `BINDING_SAMPLER_FRAG` — sampler, visible in fragment shader

**Layer bindings** (input textures from other layers) are declared separately from value bindings (buffers and samplers). This separation is important: layer bindings may need to change every frame (as the source layer's texture changes between passes), while value bindings are typically stable.

The Shade creates two `GPUBindGroupLayout` objects: one for value bindings, one for layer bindings. These are combined into a `GPUPipelineLayout`.

### Effect Shades

A special variant of Shade — the _effect shade_ — has no vertex attributes. It is used for fullscreen post-processing passes, which always operate on a built-in fullscreen triangle. Effect shades only need a fragment shader.

### Shader Code

In the Rust implementation, shaders are compiled SPIR-V loaded at runtime. For a WebGPU reimplementation, shaders would be WGSL strings (or modules) assigned separately after creating the Shade handle.

### Storage

```typescript
interface ShadeStorage {
  vertexModule: GPUShaderModule | null;
  fragmentModule: GPUShaderModule;
  attribsFormat: GPUVertexBufferLayout; // null for effect shades
  valueBindGroupLayout: GPUBindGroupLayout | null;
  layerBindGroupLayout: GPUBindGroupLayout | null;
  pipelineLayout: GPUPipelineLayout;
  valueBindingCount: number;
  layerBindingCount: number;
}

type Shade = number; // index into painter.shades
```

---

## Form — Geometry on the GPU

### Concept

A `Form` is the raw geometry data: a vertex buffer and an optional index buffer, along with the primitive topology (triangle list, triangle strip, line list, etc.) and front-face winding.

The Form is the answer to "what geometry do I draw?" It is independent of any shader — the same Form could be drawn with different Shades.

### Creating a Form

The user provides vertex data as a typed array (or `ArrayBuffer`). The Painter allocates a `GPUBuffer` with `VERTEX` usage and writes the data. If index data is provided, an additional buffer with `INDEX` usage is created.

Key implementation detail: WebGPU requires buffer sizes to be multiples of 4. The Rust implementation pads to 256 bytes (WGPU's minimum uniform binding size), but for vertex buffers the requirement is just 4-byte alignment.

### Dynamic Geometry

Forms support updating their data after creation. If the new data fits in the existing buffer, the buffer is reused (via `device.queue.writeBuffer`). If the new data is larger, the old buffer is destroyed and a new one is allocated.

For animations or procedurally generated geometry, you call `form.update(painter, newVertexData)` each frame.

### Storage

```typescript
interface FormGPUBuffers {
  vertexBuffer: GPUBuffer;
  vertexBufferSize: number; // currently allocated size
  vertexCount: number;
  indexBuffer: GPUBuffer | null;
  indexBufferSize: number;
  indexCount: number;
}

interface FormStorage {
  buffers: FormGPUBuffers[]; // supports multiple buffer sets
  activeBufferCount: number;
  topology: GPUPrimitiveTopology;
  frontFace: GPUFrontFace;
}

type Form = number; // index into painter.forms
```

---

## Shape — A Drawable Object

### Concept

A `Shape` combines:

- A **Form** (what geometry)
- A **Shade** (what shader program)
- **Value bindings**: the uniform buffers and samplers to pass to the shader
- **Layer bindings**: textures from other layers to use as shader inputs
- **Rendering state**: cull mode, blend state
- Optionally, **instances**: a list of per-draw-call binding overrides

The Shape is the unit of rendering. When the Painter renders a Layer, it iterates over the Layer's Shapes and draws each one.

### Pipeline Key

The render pipeline for a Shape is determined by the combination of:

- Which Shade (determines shader code and layouts)
- Blend state (alpha blend, additive, replace, etc.)
- Cull mode
- Primitive topology (from the Form)

These are serialized into a string (or hash) that serves as the cache key. If another Shape would produce the same key, they share the same `GPURenderPipeline`.

### Bind Groups

At render time (or at first paint, for initialization), the Painter resolves the Shape's bindings into `GPUBindGroup` objects:

1. One bind group for value bindings (buffers + samplers)
2. One bind group for layer bindings (textures from other layers)

These are created from the merged binding data: layer-level bindings are the base, shape-level bindings override at matching slots, instance-level bindings override further.

### Instance Rendering

"Instancing" in this system means rendering the same Shape multiple times with different bindings per draw call — not GPU-level instancing with instance buffers.

If a Shape has N instances, the Painter issues N draw calls, setting different bind groups each time.

The Painter optimizes this based on which binding categories vary:

| What varies            | Strategy                                                       |
| ---------------------- | -------------------------------------------------------------- |
| Nothing (no instances) | Set bindings once, one draw call                               |
| Only value bindings    | Set layer bind group once; loop updating only value bind group |
| Only layer bindings    | Set value bind group once; loop updating only layer bind group |
| Both                   | Update both bind groups per draw call                          |

This minimizes the number of `setBindGroup` calls on the render pass encoder.

### Storage

```typescript
interface ShapeStorage {
  form: Form;
  shade: Shade;
  valueBindings: [number, ValueBinding][]; // slot → binding
  layerBindings: [number, LayerBinding][]; // slot → layer reference
  instances: InstanceBinding[];
  cullMode: GPUCullMode;
  blendState: GPUBlendState;
  pipelineKey: string;
}

type Shape = number; // index into painter.shapes
```

---

## Layer — Render Target and Composition

### Concept

A `Layer` is the highest-level abstraction. It serves two roles:

1. **Render target**: it owns the GPU textures that shapes and effects render into
2. **Composition unit**: it holds an ordered list of Shapes and Effects to execute

Rendering a Layer means:

1. Begin a render pass targeting the layer's textures
2. Clear (if configured)
3. Draw each Shape in order
4. End the render pass
5. For each Effect: begin a new render pass reading from the previous output, draw a fullscreen quad, end the render pass
6. Generate mipmaps (if configured)

The output of a rendered Layer is its texture(s), which can be bound as input to Shapes or Effects in other Layers.

### Target Textures

By default, a Layer has a single RGBA texture with a standard format. The size defaults to the window/canvas dimensions and updates automatically on resize.

Custom sizes are supported for off-screen rendering (shadow maps, render-to-texture, etc.).

**Multiple Render Targets (MRT)**: A Layer can render simultaneously to multiple textures with different formats. This is essential for deferred rendering (G-buffers):

```
Layer with formats [RGBA8, RGBA16Float, RGBA16Float]
  → three GPUTextures written in parallel by fragment shader
  → accessible as layer.bindingAt(0), layer.bindingAt(1), layer.bindingAt(2)
```

Implementing MRT requires the render pass `colorAttachments` to include all target textures, and the fragment shader to output to multiple locations.

### Optional Features per Layer

- **Depth testing**: creates a `depth24plus` texture attached as `depthStencilAttachment`
- **MSAA (multisampling)**: creates additional multisampled textures; the render pass targets the multisampled texture and resolves to the regular texture. In WebGPU, this is the `resolveTarget` in `colorAttachments`.
- **Mipmaps**: after rendering, generate mipmaps for the output texture. Can be done with a compute shader or a series of blit passes.
- **Static texture**: initialize a Layer from image data; it is never re-rendered. Useful for texture assets.

### Shared Bindings

A Layer can hold default bindings shared by all its Shapes and Effects. This is useful for per-frame data like a view-projection matrix: set it once on the Layer, and every Shape in the Layer receives it without per-Shape configuration.

```typescript
interface LayerStorage {
  shapes: ShapeData[];
  effects: EffectData[];
  targetTextures: TextureStorage[];
  depthTexture: TextureStorage | null;
  msaaTextures: TextureStorage[] | null;
  width: number;
  height: number;
  useWindowSize: boolean;
  clearColor: GPUColor | null;
  formats: GPUTextureFormat[];
  multisampled: boolean;
  depthTest: boolean;
  mips: MipMapCount | null;
  valueBindings: [number, ValueBinding][];
  layerBindings: [number, LayerBinding][];
}

type Layer = number; // index into painter.layers
```

---

## Effect — Post-Processing Pass

### Concept

An `Effect` is a Layer's post-processing step. It renders a fullscreen quad (or triangle) using a fragment shader that reads from the Layer's current output texture and writes to a new one.

An Effect is essentially a Shape without any Form: its geometry is always a hardcoded fullscreen triangle (three vertices covering the entire viewport, no vertex buffer needed). Only a fragment shader is required.

### The Fullscreen Triangle

The standard technique is a single triangle that covers the clip-space viewport, generated entirely in the vertex shader from `vertex_index`:

```wgsl
// WGSL vertex shader for fullscreen triangle
@vertex
fn vs_main(@builtin(vertex_index) vi: u32) -> @builtin(position) vec4f {
  let x = f32((vi << 1u) & 2u) * 2.0 - 1.0;
  let y = f32(vi & 2u) * 2.0 - 1.0;
  return vec4f(x, y, 0.0, 1.0);
}
```

This vertex shader is built into the Painter and shared by all Effects. No vertex buffer is created.

### Target Swapping (Ping-Pong)

When a Layer has multiple Effects, the output of one Effect becomes the input of the next. This is implemented with texture ping-pong:

- The Layer has two sets of target textures (A and B)
- Shapes render into A
- Effect 1: reads A → writes B
- Effect 2: reads B → writes A
- Effect 3: reads A → writes B
- ...

The "current" texture (the one other Layers bind when they reference this Layer) is whichever was last written to.

Implementation: the Layer tracks a `currentTarget` index (0 or 1), toggling it after each Effect pass. When an Effect is done, the swap happens unless the Effect writes to a specific mip level (in which case no swap is needed — the effect wrote into an auxiliary mip, not the main target).

### Effect Instances

Effects support the same instance mechanism as Shapes: multiple draw calls with per-instance binding overrides. This is the key technique for **deferred lighting**: a single fullscreen lighting shader is run once per light, with additive blending, using per-instance uniform data for light position and color.

```
for each light:
  set blend state: additive
  set bindings: { 2: light.positionBuffer, 3: light.colorBuffer }
  draw fullscreen quad
```

The result accumulates light contributions in the output texture.

### Mip Level Targeting

Effects can read from a specific mip level of a layer (`srcMipLevel`) and write to a specific mip level (`dstMipLevel`). This enables:

- Manual mipmap generation with custom filtering
- Hierarchical blur (reading coarser mips to spread blur efficiently)
- Progressive downsampling chains

---

## The Binding System

### Value Bindings

Value bindings wrap GPU uniform buffers and samplers. They are typed wrappers that handle:

- Allocating the `GPUBuffer` with `UNIFORM | COPY_DST` usage
- Writing data with `queue.writeBuffer()`
- Providing a `ValueBinding` reference for use in Shapes/Effects/Layers

In WebGPU, uniform buffers have alignment requirements:

- Buffer size must be a multiple of 256 bytes (for `minUniformBufferOffsetAlignment`)
- `vec3` types need 16-byte alignment (pad to `vec4` in practice)

**Common binding types to support:**

- Scalar: `f32`, `u32`, `i32`
- Vector: `vec2f`, `vec3f` (padded to `vec4f`), `vec4f`
- Matrix: `mat4x4f`, `mat3x3f` (padded to `mat4x4f`)
- Sampler: wraps a `GPUSampler`

For mutable bindings, the user holds a reference and calls `.update(painter, newValue)` to write new data to the GPU each frame.

For constant bindings (values that never change), the Painter allocates a buffer, writes the initial value, and returns a `ValueBinding` directly — the user does not need to keep a reference.

### Layer Bindings

Layer bindings expose a Layer's rendered texture(s) as a `GPUTextureView` for use in shaders. Variants:

- `Source(layer)` — the layer's current output texture view
- `AtIndex(layer, i)` — a specific MRT target (for G-buffers)
- `SourceAtMipLevel(layer, mipLevel)` — a specific mip level view
- `Depth(layer)` — the layer's depth texture view

Layer bindings are resolved fresh each render call, because the underlying texture can change (ping-pong targets swap after each Effect).

### Bind Group Construction

When rendering, the Painter constructs `GPUBindGroup` objects from the resolved bindings. The process:

1. Start with layer-level bindings as the base
2. Override with shape/effect-level bindings at matching slots
3. For instance rendering, override further with per-instance bindings

Bind groups can be cached per-frame, but must be re-created if any layer binding references a texture that changed (due to ping-pong). Value binding bind groups are more stable and can be cached across frames.

---

## The Rendering Loop

### Painting a Layer

```
painter.paint(layer):
  1. If layer.msaa: target = layer.msaaTextures, resolve = layer.targetTextures
     Else: target = layer.targetTextures

  2. Create render pass:
     colorAttachments: target textures (+ resolve targets for MSAA)
     depthStencilAttachment: layer.depthTexture (if any)
     clearValues: layer.clearColor

  3. For each shape in layer.shapes:
     a. Get or create GPURenderPipeline (from cache by pipelineKey)
     b. Resolve bind groups (merge layer + shape + instance bindings)
     c. set pipeline
     d. set vertex buffer (form.vertexBuffer)
     e. set index buffer (form.indexBuffer, if any)
     f. For each instance (or once if no instances):
        - setBindGroup(0, valueBindGroup)
        - setBindGroup(1, layerBindGroup)
        - draw(vertexCount) or drawIndexed(indexCount)

  4. End render pass, submit command buffer

  5. For each effect in layer.effects:
     a. Swap active target (ping-pong)
     b. Resolve source texture = previous target
     c. Create new render pass targeting new active target
     d. Get or create GPURenderPipeline
     e. Resolve bind groups (including source texture as layer binding)
     f. For each instance (or once):
        - setBindGroup(0, valueBindGroup)
        - setBindGroup(1, layerBindGroup)
        - draw(3)  // fullscreen triangle
     g. End render pass, submit
     (unless effect writes to mip level: no swap, no re-submission needed)

  6. If layer.mips: generate mipmaps for target textures
```

### Showing a Layer

To display a Layer to the screen:

```
painter.show(layer):
  1. Get current swap chain texture: context.getCurrentTexture()
  2. Create render pass targeting the swap chain texture
  3. Run a fullscreen blit effect: draw the layer's texture to screen
  4. End render pass, submit
  5. context.present() (if needed by platform)
```

The blit is a minimal fullscreen triangle with a simple fragment shader that samples the layer texture.

### Composing Multiple Layers

For multi-pass rendering, the user calls `paint()` on each layer in dependency order before `show()`:

```
// Deferred rendering frame:
painter.paint(sceneLayer);    // render G-buffer
painter.paint(lightingLayer); // accumulate lighting using G-buffer
painter.show(lightingLayer);  // display result
```

The Painter provides a `compose(layers)` helper that paints all layers in order, equivalent to calling `paint()` on each.

---

## Application Framework

The Painter includes a minimal application loop wrapper. In a browser context, this is straightforward:

```typescript
interface CanvasApp {
  init(painter: Painter): void;
  frame(painter: Painter, deltaTime: number): void;
  resize(painter: Painter, width: number, height: number): void;
  event(event: Event, painter: Painter): void;
}
```

The framework handles:

- Requesting a WebGPU adapter and device
- Creating the canvas context
- Setting up a `ResizeObserver` to call `resize()` and update layer dimensions
- Driving the render loop with `requestAnimationFrame`
- Computing `deltaTime` (time per frame in seconds)

`painter.requestNextFrame()` signals that the app wants continuous animation. If not called, rendering stops until the next user event — useful for static or event-driven renders.

---

## WebGPU-Specific Implementation Notes

### Adapter and Device Initialization

```typescript
const adapter = await navigator.gpu.requestAdapter();
const device = await adapter.requestDevice();
const context = canvas.getContext("webgpu");
const format = navigator.gpu.getPreferredCanvasFormat();
context.configure({ device, format });
```

### Uniform Buffer Alignment

WebGPU enforces `minUniformBufferOffsetAlignment` (typically 256 bytes). All uniform buffers must be padded to a multiple of 256 bytes:

```typescript
function paddedSize(size: number): number {
  return Math.ceil(size / 256) * 256;
}
```

Additionally, `vec3f` in WGSL has 16-byte alignment. Pass `vec3` values padded to `vec4` in the buffer, or use a struct with explicit padding.

### Pipeline Creation

```typescript
const pipeline = device.createRenderPipeline({
  layout: shade.pipelineLayout,
  vertex: {
    module: shade.vertexModule,
    entryPoint: "vs_main",
    buffers: [shade.attribsFormat],
  },
  fragment: {
    module: shade.fragmentModule,
    entryPoint: "fs_main",
    targets: layer.formats.map((format) => ({
      format,
      blend: shape.blendState,
    })),
  },
  primitive: {
    topology: form.topology,
    frontFace: form.frontFace,
    cullMode: shape.cullMode,
  },
  depthStencil: layer.depthTest
    ? {
        format: "depth24plus",
        depthWriteEnabled: true,
        depthCompare: "less",
      }
    : undefined,
  multisample: layer.multisampled ? { count: 4 } : undefined,
});
```

### MSAA in WebGPU

WebGPU MSAA uses sample count 4. The multisampled texture is the render target; the regular texture is the resolve target:

```typescript
colorAttachments: [
  {
    view: msaaTextureView, // render here (multisampled)
    resolveTarget: textureView, // resolve MSAA to this
    clearValue: layer.clearColor,
    loadOp: "clear",
    storeOp: "discard", // MSAA texture is discarded after resolve
  },
];
```

### Mipmap Generation

WebGPU does not have a built-in mipmap generation call. Options:

1. A series of render passes, each reading mip N and writing mip N+1, using a blit shader
2. A compute shader that downsamples multiple mips in one pass

The render pass approach is simpler to implement and works on all WebGPU-capable devices.

### Shader Hot Reloading

In a browser context, hot reloading can be implemented using WebSockets connected to a dev server that watches shader files. When a file changes, the server sends the new WGSL source; the client recreates the shader module and invalidates cached pipelines for that Shade.

---

## Summary: Abstraction Layers

```
WebGPU API
  ↑
Painter (resource registry + render execution)
  ↑
┌──────────────────────────────────────────────────────────────────────┐
│  Shade    │  Form     │  Shape         │  Effect        │  Layer     │
│ (shader   │ (vertex   │ (Form + Shade  │ (Shade only,   │ (render    │
│  program  │  buffers) │  + bindings)   │  fullscreen    │  target +  │
│  + layout)│           │                │  quad, no Form)│  drawlist) │
└──────────────────────────────────────────────────────────────────────┘
  ↑
CanvasApp (frame loop + resize + events)
```

Each abstraction has a single responsibility, and they compose cleanly:

- **Shade** answers: "What shader runs and what inputs does it need?"
- **Form** answers: "What geometry is on the GPU?"
- **Shape** answers: "What do I draw and with what data?" — requires both a Form and a Shade
- **Effect** answers: "What do I apply to a layer's output?" — a Shape specialization: same binding system, same blend control, same instancing, but the geometry is always the full viewport quad and only a fragment shader is needed
- **Layer** answers: "Where do I render, in what order, and with what shared data?"
- **Painter** answers: "How do I execute all of this efficiently?"
</file>

<file path="run_all_examples.sh">
#!/bin/bash

# Script to run all Cargo examples sequentially
# Each example runs until closed, then the next one starts

set -e

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default values
RELEASE_MODE=false
DRY_RUN=false
CONTINUE_ON_ERROR=true

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --release)
            RELEASE_MODE=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --stop-on-error)
            CONTINUE_ON_ERROR=false
            shift
            ;;
        -h|--help)
            echo "Usage: $0 [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  --release          Build and run examples in release mode"
            echo "  --dry-run          Show which examples would be run without executing"
            echo "  --stop-on-error    Stop if any example fails (default: continue)"
            echo "  -h, --help         Show this help message"
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Function to get list of examples
get_examples() {
    # Extract example names from Cargo.toml
    # Look for [[example]] sections and extract the name field
    local examples=()

    # Use cargo metadata to get examples
    if command -v jq &> /dev/null; then
        # If jq is available, use it for cleaner parsing
        examples=($(cargo metadata --no-deps --format-version 1 2>/dev/null | \
            jq -r '.packages[] | select(.name == "trivalibs_examples") | .targets[] | select(.kind[] | contains("example")) | .name' | \
            sort))
    else
        # Fallback: parse the examples directory
        if [ -d "examples" ]; then
            for dir in examples/*/; do
                if [ -d "$dir" ]; then
                    example_name=$(basename "$dir")
                    # Skip if it's the triangle example (it has its own structure)
                    if [ -f "examples/$example_name/main.rs" ]; then
                        examples+=("$example_name")
                    fi
                fi
            done
            # Add triangle separately if it exists
            if [ -d "examples/triangle/src" ]; then
                examples+=("simple_triangle")
            fi
            # Sort the array
            IFS=$'\n' examples=($(sort <<<"${examples[*]}"))
            unset IFS
        fi
    fi

    echo "${examples[@]}"
}

# Get all examples
EXAMPLES=($(get_examples))
TOTAL=${#EXAMPLES[@]}

if [ $TOTAL -eq 0 ]; then
    echo -e "${RED}Error: No examples found${NC}"
    exit 1
fi

echo -e "${BLUE}Found $TOTAL examples${NC}"
echo ""

if [ "$DRY_RUN" = true ]; then
    echo -e "${YELLOW}Dry run mode - would execute:${NC}"
    for i in "${!EXAMPLES[@]}"; do
        num=$((i + 1))
        echo "  $num. ${EXAMPLES[$i]}"
    done
    exit 0
fi

# Build command
if [ "$RELEASE_MODE" = true ]; then
    BUILD_FLAG="--release"
    echo -e "${YELLOW}Running in release mode${NC}"
else
    BUILD_FLAG=""
    echo -e "${YELLOW}Running in debug mode${NC}"
fi
echo ""

# Counter for successful runs
SUCCESS_COUNT=0
FAILED_COUNT=0
SKIPPED_COUNT=0
FAILED_EXAMPLES=()

# Function to run a single example
run_example() {
    local example_name=$1
    local index=$2

    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${GREEN}Running example $index/$TOTAL: $example_name${NC}"
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""

    # Run the example
    if cargo run $BUILD_FLAG --example "$example_name"; then
        echo ""
        echo -e "${GREEN}✓ Example '$example_name' completed successfully${NC}"
        ((SUCCESS_COUNT++))
    else
        exit_code=$?
        echo ""
        echo -e "${RED}✗ Example '$example_name' failed with exit code $exit_code${NC}"
        ((FAILED_COUNT++))
        FAILED_EXAMPLES+=("$example_name")

        if [ "$CONTINUE_ON_ERROR" = false ]; then
            echo -e "${RED}Stopping due to error (--stop-on-error is set)${NC}"
            return 1
        else
            echo -e "${YELLOW}Continuing to next example...${NC}"
        fi
    fi

    echo ""
    return 0
}

# Main loop
for i in "${!EXAMPLES[@]}"; do
    example="${EXAMPLES[$i]}"
    index=$((i + 1))

    if ! run_example "$example" "$index"; then
        break
    fi

    # Add a small pause between examples
    if [ $index -lt $TOTAL ]; then
        sleep 0.5
    fi
done

# Summary
echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "${BLUE}Summary${NC}"
echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "${GREEN}Successful: $SUCCESS_COUNT${NC}"
if [ $FAILED_COUNT -gt 0 ]; then
    echo -e "${RED}Failed: $FAILED_COUNT${NC}"
    echo -e "${RED}Failed examples:${NC}"
    for failed in "${FAILED_EXAMPLES[@]}"; do
        echo -e "${RED}  - $failed${NC}"
    done
fi
echo -e "${BLUE}Total: $TOTAL${NC}"
echo ""

if [ $FAILED_COUNT -eq 0 ]; then
    echo -e "${GREEN}All examples completed successfully! 🎉${NC}"
    exit 0
else
    exit 1
fi
</file>

<file path="crates/trivalibs/Cargo.toml">
[package]
name = "trivalibs"
version = "0.1.0"
edition = "2021"
rust-version = "1.82" # Prevent Cargo.lock version 4, cargo gpu does not support it yet

[dependencies]
trivalibs-core.workspace = true
trivalibs-nostd.workspace = true
trivalibs-painter.workspace = true
</file>

<file path="crates/trivalibs_core/src/rendering/mesh_geometry/utils.rs">
use lerp::Lerp;
use macro_rules_attribute::apply;
⋮----
pub struct Vert3dUv {
⋮----
impl Position3D for Vert3dUv {
fn position(&self) -> Vec3 {
⋮----
fn lerp(self, other: Self, t: f32) -> Self {
⋮----
pos: self.pos.lerp(other.pos, t),
uv: self.uv.lerp(other.uv, t),
⋮----
pub fn vert_pos_uv(pos: Vec3, uv: Vec2) -> Vert3dUv {
</file>

<file path="crates/trivalibs_core/src/utils/rand_utils.rs">
use rand::random;
⋮----
use crate::math::fit::Fit;
⋮----
pub fn rand_range(min: f32, max: f32) -> f32 {
⋮----
pub fn rand_usize(max: usize) -> usize {
(random::<f32>() * max as f32).floor() as usize
⋮----
pub fn rand_u32(max: u32) -> u32 {
(random::<f32>() * max as f32).floor() as u32
⋮----
pub fn rand_range_u32(min: u32, max: u32) -> u32 {
min + (random::<f32>() * (max - min) as f32).floor() as u32
⋮----
pub fn rand_range_i32(min: i32, max: i32) -> i32 {
min + (random::<f32>() * (max - min) as f32).floor() as i32
⋮----
pub fn rand_f32() -> f32 {
⋮----
pub fn rand_f64() -> f64 {
⋮----
pub fn rand_bool() -> bool {
⋮----
pub fn rand_sign() -> f32 {
if rand_f32() < 0.5 { 1.0 } else { -1.0 }
⋮----
pub fn rand_vec3() -> Vec3 {
vec3(random::<f32>(), random::<f32>(), random::<f32>())
⋮----
pub fn rand_vec3_range(min: f32, max: f32) -> Vec3 {
vec3(
rand_range(min, max),
⋮----
pub fn rand_in_unit_sphere() -> Vec3 {
⋮----
let p = vec3(
rand_range(-1.0, 1.0),
⋮----
let ls = p.length_squared();
⋮----
pub fn rand_vec3_unit() -> Vec3 {
rand_in_unit_sphere().normalize()
⋮----
pub fn rand_vec4() -> Vec4 {
vec4(
⋮----
pub fn rand_vec4_range(min: f32, max: f32) -> Vec4 {
⋮----
/// Returns a random number in the range [-1, 1] with normal distribution.
pub fn rand_normal() -> f32 {
⋮----
pub fn rand_normal() -> f32 {
⋮----
/// Returns a random number in the range [0, 1] with normal distribution arround 0.5.
pub fn rand_normal_01() -> f32 {
⋮----
pub fn rand_normal_01() -> f32 {
⋮----
pub fn rand_normal_11() -> f32 {
rand_normal_01().fit0111()
⋮----
pub trait Pick<T> {
⋮----
fn pick(&self) -> &T {
&self[(random::<f64>() * self.len() as f64).floor() as usize]
</file>

<file path="crates/trivalibs_nostd/src/random/simplex.rs">
//  MIT License. © Ian McEwan, Stefan Gustavson, Munrocket, Johan Helsing
⋮----
// Ported from https://github.com/johanhelsing/noisy_bevy from WGSL To Rust-GPU
// Original code at https://github.com/stegu/webgl-noise by Stefan Gustavson
⋮----
use core::f32::consts::TAU;
⋮----
use spirv_std::num_traits::Float;
⋮----
/// Permutation polynomial for pseudo-random hashing (scalar version).
fn permute_1(x: f32) -> f32 {
⋮----
fn permute_1(x: f32) -> f32 {
⋮----
/// Permutation polynomial for pseudo-random hashing (Vec3 version).
fn permute_3(x: Vec3) -> Vec3 {
⋮----
fn permute_3(x: Vec3) -> Vec3 {
⋮----
/// Permutation polynomial for pseudo-random hashing (Vec4 version).
fn permute_4(x: Vec4) -> Vec4 {
⋮----
fn permute_4(x: Vec4) -> Vec4 {
⋮----
/// Taylor series approximation of inverse square root (scalar version).
fn taylor_inv_sqrt_1(r: f32) -> f32 {
⋮----
fn taylor_inv_sqrt_1(r: f32) -> f32 {
⋮----
/// Taylor series approximation of inverse square root (Vec4 version).
fn taylor_inv_sqrt_4(r: Vec4) -> Vec4 {
⋮----
fn taylor_inv_sqrt_4(r: Vec4) -> Vec4 {
⋮----
/// Computes gradient vector for 4D simplex noise.
fn grad_4(j: f32, ip: Vec4) -> Vec4 {
⋮----
fn grad_4(j: f32, ip: Vec4) -> Vec4 {
let tmp = ((j * ip.xyz()).frct() * 7.0).floor() * ip.z - 1.0;
let mut p = vec4(tmp.x, tmp.y, tmp.z, 1.5 - tmp.abs().dot(Vec3::ONE));
⋮----
let s = Vec4::ZERO.step(p);
⋮----
let tmp = (s.xyz() * 2.0 - 1.0) * s.www();
⋮----
/// 2D simplex noise.
///
⋮----
///
/// # Parameters
⋮----
/// # Parameters
///
⋮----
///
/// * `pos` - Input position coordinates
⋮----
/// * `pos` - Input position coordinates
///
⋮----
///
/// # Returns
⋮----
/// # Returns
///
⋮----
///
/// Noise value in approximate range [-1.0, 1.0]
⋮----
/// Noise value in approximate range [-1.0, 1.0]
pub fn simplex_noise_2d(pos: Vec2) -> f32 {
⋮----
pub fn simplex_noise_2d(pos: Vec2) -> f32 {
let c = vec4(
0.211324865405187,  // (3.0 - sqrt(3.0)) / 6.0
0.366025403784439,  // 0.5 * (sqrt(3.0) - 1.0)
-0.577350269189626, // -1.0 + 2.0 * C.x
0.024390243902439,  // 1.0 / 41.0
⋮----
// first corner
let i = (pos + pos.dot(c.yy())).floor();
let x0 = pos - i + i.dot(c.xx());
⋮----
// other corners
⋮----
vec2(1.0, 0.0)
⋮----
vec2(0.0, 1.0)
⋮----
let x12 = x0.xyxy() + c.xxzz() - vec4(i1.x, i1.y, 0.0, 0.0);
⋮----
// permutations
⋮----
let p = permute_3(permute_3(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
⋮----
- vec3(x0.dot(x0), x12.xy().dot(x12.xy()), x12.zw().dot(x12.zw())))
.max(Vec3::ZERO);
⋮----
// gradients: 41 points uniformly over a line, mapped onto a diamond
// the ring size, 17*17 = 289, is close to a multiple of 41 (41*7 = 287)
let x = 2.0 * (p * c.www()).fract() - 1.0;
let h = x.abs() - 0.5;
let ox = (x + 0.5).floor();
⋮----
// normalize gradients implicitly by scaling m
// approximation of: m *= inversesqrt(a0 * a0 + h * h);
⋮----
// compute final noise value at P
let v = a0.yz() * x12.xz() + h.yz() * x12.yw();
let g = vec3(a0.x * x0.x + h.x * x0.y, v.x, v.y);
130.0 * m.dot(g)
⋮----
/// 3D simplex noise.
///
⋮----
/// Noise value in approximate range [-1.0, 1.0]
pub fn simplex_noise_3d(pos: Vec3) -> f32 {
⋮----
pub fn simplex_noise_3d(pos: Vec3) -> f32 {
let c = vec2(1.0 / 6.0, 1.0 / 3.0);
let d = vec4(0.0, 0.5, 1.0, 2.0);
⋮----
let i = (pos + pos.dot(c.yyy())).floor();
let x0 = pos - i + i.dot(c.xxx());
⋮----
let g = x0.xyz().step(x0.yzx());
⋮----
let i1 = g.min(l.zxy());
let i2 = g.max(l.zxy());
⋮----
// x0 = x0 - 0. + 0. * C
let x1 = x0 - i1 + c.xxx();
let x2 = x0 - i2 + 2.0 * c.xxx();
let x3 = x0 - Vec3::splat(1.0) + 3.0 * c.xxx();
⋮----
let p = permute_4(
permute_4(permute_4(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0))
+ i.x + vec4(0.0, i1.x, i2.x, 1.0),
⋮----
// gradients (NxN points uniformly over a square, mapped onto an octahedron)
let n_ = 1.0 / 7.0; // N=7
let ns = n_ * d.wyz() - d.xzx();
⋮----
let j = p - 49.0 * (p * ns.z * ns.z).floor(); // mod(p, N*N)
⋮----
let x_ = (j * ns.z).floor();
let y_ = (j - 7.0 * x_).floor(); // mod(j, N)
⋮----
let x = x_ * ns.x + ns.yyyy();
let y = y_ * ns.x + ns.yyyy();
let h = 1.0 - x.abs() - y.abs();
⋮----
let b0 = vec4(x.x, x.y, y.x, y.y);
let b1 = vec4(x.z, x.w, y.z, y.w);
⋮----
let s0 = b0.floor() * 2.0 + 1.0;
let s1 = b1.floor() * 2.0 + 1.0;
let sh = -Vec4::ZERO.step(h);
⋮----
let a0 = b0.xzyw() + s0.xzyw() * sh.xxyy();
let a1 = b1.xzyw() + s1.xzyw() * sh.zzww();
⋮----
let mut p0 = vec3(a0.x, a0.y, h.x);
let mut p1 = vec3(a0.z, a0.w, h.y);
let mut p2 = vec3(a1.x, a1.y, h.z);
let mut p3 = vec3(a1.z, a1.w, h.w);
⋮----
// normalize gradients
let norm = taylor_inv_sqrt_4(vec4(p0.dot(p0), p1.dot(p1), p2.dot(p2), p3.dot(p3)));
⋮----
// mix final noise value
let mut m = 0.6 - vec4(x0.dot(x0), x1.dot(x1), x2.dot(x2), x3.dot(x3));
m = m.max(Vec4::ZERO);
⋮----
42.0 * m.dot(vec4(p0.dot(x0), p1.dot(x1), p2.dot(x2), p3.dot(x3)))
⋮----
/// Fractal Brownian Motion using 2D simplex noise.
///
⋮----
///
/// * `pos` - Input position
⋮----
/// * `pos` - Input position
/// * `octaves` - Number of noise layers
⋮----
/// * `octaves` - Number of noise layers
/// * `freq_factor` - Frequency multiplier per octave
⋮----
/// * `freq_factor` - Frequency multiplier per octave
/// * `amplitude_factor` - Amplitude multiplier per octave
⋮----
/// * `amplitude_factor` - Amplitude multiplier per octave
pub fn fbm_simplex_2d(pos: Vec2, octaves: i32, freq_factor: f32, amplitude_factor: f32) -> f32 {
⋮----
pub fn fbm_simplex_2d(pos: Vec2, octaves: i32, freq_factor: f32, amplitude_factor: f32) -> f32 {
⋮----
sum += simplex_noise_2d(pos * frequency) * amplitude;
⋮----
/// Fractal Brownian Motion using 3D simplex noise.
///
⋮----
/// * `pos` - Input position coordinates
/// * `octaves` - Number of noise layers to combine
⋮----
/// * `octaves` - Number of noise layers to combine
/// * `freq_factor` - Frequency multiplier per octave (typically 2.0)
⋮----
/// * `freq_factor` - Frequency multiplier per octave (typically 2.0)
/// * `amplitude_factor` - Amplitude multiplier per octave (typically 0.5)
⋮----
/// * `amplitude_factor` - Amplitude multiplier per octave (typically 0.5)
///
⋮----
///
/// Combined noise value. Range depends on octaves and amplitude_factor parameters.
⋮----
/// Combined noise value. Range depends on octaves and amplitude_factor parameters.
pub fn fbm_simplex_3d(pos: Vec3, octaves: i32, freq_factor: f32, amplitude_factor: f32) -> f32 {
⋮----
pub fn fbm_simplex_3d(pos: Vec3, octaves: i32, freq_factor: f32, amplitude_factor: f32) -> f32 {
⋮----
sum += simplex_noise_3d(pos * frequency) * amplitude;
⋮----
/// 4D simplex noise.
///
⋮----
///
/// * `pos` - Input position coordinates (4D)
⋮----
/// * `pos` - Input position coordinates (4D)
///
⋮----
/// Noise value in approximate range [-1.0, 1.0]
pub fn simplex_noise_4d(pos: Vec4) -> f32 {
⋮----
pub fn simplex_noise_4d(pos: Vec4) -> f32 {
⋮----
0.138196601125011,  // (5 - sqrt(5))/20  G4
0.276393202250021,  // 2 * G4
0.414589803375032,  // 3 * G4
-0.447213595499958, // -1 + 4 * G4
⋮----
// First corner
let i = (pos + pos.dot(Vec4::splat(0.309016994374947451))).floor(); // (sqrt(5) - 1)/4
let x0 = pos - i + i.dot(c.xxxx());
⋮----
// Other corners
let is_x = x0.xxx().step(x0.yzw());
let is_yz = x0.yyz().step(x0.zww());
⋮----
// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)
⋮----
let mut i0 = vec4(is_x.x + is_x.y + is_x.z, tmp.x, tmp.y, tmp.z);
⋮----
let tmp = Vec2::ONE - is_yz.xy();
⋮----
// i0 now contains the unique values 0,1,2,3 in each channel
let i3 = i0.clamp01();
let i2 = (i0 - Vec4::ONE).clamp01();
let i1 = (i0 - Vec4::splat(2.0)).clamp01();
⋮----
let x1 = x0 - i1 + c.xxxx();
let x2 = x0 - i2 + c.yyyy();
let x3 = x0 - i3 + c.zzzz();
let x4 = x0 + c.wwww();
⋮----
// Permutations
⋮----
let j0 = permute_1(permute_1(permute_1(permute_1(i.w) + i.z) + i.y) + i.x);
let j1 = permute_4(
permute_4(
⋮----
permute_4(i.w + vec4(i1.w, i2.w, i3.w, 1.0)) + i.z + vec4(i1.z, i2.z, i3.z, 1.0),
) + i.y + vec4(i1.y, i2.y, i3.y, 1.0),
) + i.x + vec4(i1.x, i2.x, i3.x, 1.0),
⋮----
// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope
// 7*7*6 = 294, which is close to the ring size 17*17 = 289.
let ip = vec4(1.0 / 294.0, 1.0 / 49.0, 1.0 / 7.0, 0.0);
⋮----
let p0 = grad_4(j0, ip);
let p1 = grad_4(j1.x, ip);
let p2 = grad_4(j1.y, ip);
let p3 = grad_4(j1.z, ip);
let p4 = grad_4(j1.w, ip);
⋮----
// Normalize gradients
⋮----
let p4 = p4 * taylor_inv_sqrt_1(p4.dot(p4));
⋮----
// Mix contributions from the five corners
let mut m0 = vec3(0.6 - x0.dot(x0), 0.6 - x1.dot(x1), 0.6 - x2.dot(x2)).max(Vec3::ZERO);
let mut m1 = vec2(0.6 - x3.dot(x3), 0.6 - x4.dot(x4)).max(Vec2::ZERO);
⋮----
49.0 * (m0.dot(m0 * vec3(p0.dot(x0), p1.dot(x1), p2.dot(x2)))
+ m1.dot(m1 * vec2(p3.dot(x3), p4.dot(x4))))
⋮----
/// Seamlessly tiling 2D simplex noise using 4D noise mapped to a torus.
///
⋮----
///
/// * `pos` - Input position coordinates (should be in range [0.0, 1.0] for seamless tiling)
⋮----
/// * `pos` - Input position coordinates (should be in range [0.0, 1.0] for seamless tiling)
/// * `scale` - Scale factor for the noise
⋮----
/// * `scale` - Scale factor for the noise
///
⋮----
/// Noise value in approximate range [-1.0, 1.0]
pub fn tiling_simplex_noise_2d(pos: Vec2, scale: f32) -> f32 {
⋮----
pub fn tiling_simplex_noise_2d(pos: Vec2, scale: f32) -> f32 {
// Map coordinates to circle for seamless wrapping
⋮----
let nx = angle_x.cos() * scale;
let ny = angle_x.sin() * scale;
let nz = angle_y.cos() * scale;
let nw = angle_y.sin() * scale;
⋮----
// Get 4D noise value
simplex_noise_4d(vec4(nx, ny, nz, nw))
⋮----
/// 2D tiling simplex noise with rotating gradients and analytical derivative.
///
⋮----
///
/// Implementation based on psrdnoise by Stefan Gustavson and Ian McEwan.
⋮----
/// Implementation based on psrdnoise by Stefan Gustavson and Ian McEwan.
/// See <https://github.com/stegu/psrdnoise/>
⋮----
/// See <https://github.com/stegu/psrdnoise/>
///
⋮----
///
/// * `pos` - Point (x,y) to evaluate
⋮----
/// * `pos` - Point (x,y) to evaluate
/// * `period` - Desired periods along x and y. Set to 0.0 or negative to skip wrapping along that dimension.
⋮----
/// * `period` - Desired periods along x and y. Set to 0.0 or negative to skip wrapping along that dimension.
/// * `norm_rot` - Normalized rotation for swirling gradients, where 1.0 is TAU (2π radians)
⋮----
/// * `norm_rot` - Normalized rotation for swirling gradients, where 1.0 is TAU (2π radians)
///
⋮----
///
/// A tuple containing:
⋮----
/// A tuple containing:
/// * Noise value in approximate range [-1.0, 1.0]
⋮----
/// * Noise value in approximate range [-1.0, 1.0]
/// * Gradient vector (x,y partial derivatives)
⋮----
/// * Gradient vector (x,y partial derivatives)
///
⋮----
///
/// # Performance Notes
⋮----
/// # Performance Notes
///
⋮----
///
/// * Setting both periods to 0.0 makes the function execute ~15% faster
⋮----
/// * Setting both periods to 0.0 makes the function execute ~15% faster
/// * Not using the gradient return value allows compiler optimization for 10-15% speedup
⋮----
/// * Not using the gradient return value allows compiler optimization for 10-15% speedup
pub fn tiling_rot_noise_2d(pos: Vec2, period: Vec2, norm_rot: f32) -> (f32, Vec2) {
⋮----
pub fn tiling_rot_noise_2d(pos: Vec2, period: Vec2, norm_rot: f32) -> (f32, Vec2) {
// Transform to simplex space (axis-aligned hexagonal grid)
let uv = vec2(pos.x + pos.y * 0.5, pos.y);
⋮----
// Determine which simplex we're in, with i0 being the "base"
let i0 = uv.floor();
let f0 = uv.fract();
// o1 is the offset in simplex space to the second corner
let cmp = f0.x.step(f0.y);
let o1 = vec2(cmp, 1.0 - cmp);
⋮----
// Enumerate the remaining simplex corners
⋮----
let i2 = i0 + vec2(1.0, 1.0);
⋮----
// Transform corners back to texture space
let v0 = vec2(i0.x - i0.y * 0.5, i0.y);
let v1 = vec2(v0.x + o1.x - o1.y * 0.5, v0.y + o1.y);
let v2 = vec2(v0.x + 0.5, v0.y + 1.0);
⋮----
// Compute vectors from v to each of the simplex corners
⋮----
// Wrap to periods, if desired
⋮----
let xw = vec3(v0.x, v1.x, v2.x);
let yw = vec3(v0.y, v1.y, v2.y);
⋮----
((xw + 0.5 * yw + 0.5).floor(), (yw + 0.5).floor())
⋮----
(vec3(i0.x, i1.x, i2.x), vec3(i0.y, i1.y, i2.y))
⋮----
// Compute one pseudo-random hash value for each corner
⋮----
// Pick a pseudo-random angle and add the desired rotation
⋮----
let gx = psi.cos();
let gy = psi.sin();
⋮----
// Reorganize for dot products below
let g0 = vec2(gx.x, gy.x);
let g1 = vec2(gx.y, gy.y);
let g2 = vec2(gx.z, gy.z);
⋮----
// Radial decay with distance from each simplex corner
let w = vec3(0.8 - x0.dot(x0), 0.8 - x1.dot(x1), 0.8 - x2.dot(x2)).max(Vec3::ZERO);
⋮----
// The value of the linear ramp from each of the corners
let gdotx = vec3(g0.dot(x0), g1.dot(x1), g2.dot(x2));
⋮----
// Multiply by the radial decay and sum up the noise value
let n = w4.dot(gdotx);
⋮----
// Compute the first order partial derivatives
⋮----
// Scale the return value to fit nicely into the range [-1, 1]
⋮----
/// 2D tiling simplex noise with fixed gradients and analytical derivative.
///
⋮----
///
/// Wrapper around `tiling_rot_noise_2d` with no rotation.
⋮----
/// Wrapper around `tiling_rot_noise_2d` with no rotation.
///
⋮----
/// * `period` - Desired periods along x and y. Set to 0.0 or negative to skip wrapping along that dimension.
///
⋮----
/// * Gradient vector (x,y partial derivatives)
pub fn tiling_noise_2d(pos: Vec2, period: Vec2) -> (f32, Vec2) {
⋮----
pub fn tiling_noise_2d(pos: Vec2, period: Vec2) -> (f32, Vec2) {
tiling_rot_noise_2d(pos, period, 0.0)
⋮----
/// 2D simplex noise with rotating gradients and analytical derivative (no tiling).
///
⋮----
///
/// Wrapper around `tiling_rot_noise_2d` with no period wrapping.
⋮----
/// Wrapper around `tiling_rot_noise_2d` with no period wrapping.
///
⋮----
/// * `pos` - Point (x,y) to evaluate
/// * `norm_rot` - Normalized rotation for swirling gradients, where 1.0 is TAU (2π radians)
⋮----
/// * Gradient vector (x,y partial derivatives)
pub fn rot_noise_2d(pos: Vec2, norm_rot: f32) -> (f32, Vec2) {
⋮----
pub fn rot_noise_2d(pos: Vec2, norm_rot: f32) -> (f32, Vec2) {
tiling_rot_noise_2d(pos, Vec2::ZERO, norm_rot)
⋮----
/// 3D tiling simplex noise with rotating gradients and analytical derivatives.
///
⋮----
///
/// This implementation uses an axis-aligned grid to permit rectangular tiling.
⋮----
/// This implementation uses an axis-aligned grid to permit rectangular tiling.
/// The noise pattern can tile seamlessly to any integer periods up to 289 units
⋮----
/// The noise pattern can tile seamlessly to any integer periods up to 289 units
/// in the x, y and z directions. The rotating gradients create a swirling motion
⋮----
/// in the x, y and z directions. The rotating gradients create a swirling motion
/// effect, useful for animation without needing a 4th dimension.
⋮----
/// effect, useful for animation without needing a 4th dimension.
///
⋮----
///
/// * `pos` - Point (x,y,z) to evaluate
⋮----
/// * `pos` - Point (x,y,z) to evaluate
/// * `period` - Desired periods along x,y,z (up to 289). Set to 0.0 or negative to skip wrapping along that dimension.
⋮----
/// * `period` - Desired periods along x,y,z (up to 289). Set to 0.0 or negative to skip wrapping along that dimension.
/// * `norm_rot` - Normalized rotation for swirling gradients, where 1.0 is TAU (2π radians)
⋮----
/// * Noise value in approximate range [-1.0, 1.0]
/// * Gradient vector (x,y,z partial derivatives)
⋮----
/// * Gradient vector (x,y,z partial derivatives)
///
⋮----
///
/// * Function executes 15-20% faster if `norm_rot` is constant 0.0
⋮----
/// * Function executes 15-20% faster if `norm_rot` is constant 0.0
/// * Setting all periods to 0.0 makes the function execute 10-15% faster
⋮----
/// * Setting all periods to 0.0 makes the function execute 10-15% faster
/// * Not using the gradient return value allows compiler optimization for ~10% speedup
⋮----
/// * Not using the gradient return value allows compiler optimization for ~10% speedup
pub fn tiling_rot_noise_3d(pos: Vec3, period: Vec3, norm_rot: f32) -> (f32, Vec3) {
⋮----
pub fn tiling_rot_noise_3d(pos: Vec3, period: Vec3, norm_rot: f32) -> (f32, Vec3) {
const M: Mat3 = mat3(
vec3(0.0, 1.0, 1.0),
vec3(1.0, 0.0, 1.0),
vec3(1.0, 1.0, 0.0),
⋮----
const MI: Mat3 = mat3(
vec3(-0.5, 0.5, 0.5),
vec3(0.5, -0.5, 0.5),
vec3(0.5, 0.5, -0.5),
⋮----
let uvw = M * pos; // Transform to simplex space
⋮----
// Determine which simplex we're in, with i0 being the "base corner"
let mut i0 = uvw.floor();
let f0 = uvw.fract(); // coords within "skewed cube"
⋮----
// To determine which simplex corners are closest, rank order the
// magnitudes of u,v,w, resolving ties in priority order u,v,w,
// and traverse the four corners from largest to smallest magnitude.
// o1, o2 are offsets in simplex space to the 2nd and 3rd corners.
let g_ = f0.yzz().step(f0.xyx()); // Makes comparison "less-than"
let l_ = 1.0 - g_; // complement is "greater-or-equal"
let g = vec3(l_.z, g_.x, g_.y);
let l = vec3(l_.x, l_.y, g_.z);
let o1 = g.min(l);
let o2 = g.max(l);
⋮----
// Wrap to periods and transform back to simplex space
let vx = vec4(v0.x, v1.x, v2.x, v3.x);
let vy = vec4(v0.y, v1.y, v2.y, v3.y);
let vz = vec4(v0.z, v1.z, v2.z, v3.z);
⋮----
// Wrap to periods where specified
⋮----
// Transform wrapped coordinates back to uvw
i0 = M * vec3(vx.x, vy.x, vz.x);
i1 = M * vec3(vx.y, vy.y, vz.y);
i2 = M * vec3(vx.z, vy.z, vz.z);
i3 = M * vec3(vx.w, vy.w, vz.w);
⋮----
// Fix rounding errors
i0 = (i0 + 0.5).floor();
i1 = (i1 + 0.5).floor();
i2 = (i2 + 0.5).floor();
i3 = (i3 + 0.5).floor();
⋮----
let hash = permute_4(
permute_4(permute_4(vec4(i0.z, i1.z, i2.z, i3.z)) + vec4(i0.y, i1.y, i2.y, i3.y))
+ vec4(i0.x, i1.x, i2.x, i3.x),
⋮----
// Compute generating gradients from a Fibonacci spiral on the unit sphere
let theta = hash * 3.883222077; // 2*pi/golden ratio
let sz = hash * -0.006920415 + 0.996539792; // 1-(hash+0.5)*2/289
let psi = hash * 0.108705628; // 10*pi/289, chosen to avoid correlation
⋮----
let ct = theta.cos();
let st = theta.sin();
let sz_prime = (1.0 - sz * sz).sqrt(); // s is a point on a unit fib-sphere
⋮----
// Rotate gradients by angle alpha around a pseudo-random ortogonal axis
⋮----
let sa = alpha.sin(); // psi and alpha in different planes
let ca = alpha.cos();
⋮----
let sp = psi.sin(); // q' from psi on equator
let cp = psi.cos();
⋮----
let px = ct * sz_prime; // px = sx
let py = st * sz_prime; // py = sy
⋮----
let ctp = st * sp - ct * cp; // q = (rotate( cross(s,n), dot(s,n))(q')
let qx = (ctp * st).lerp_vec(sp, sz);
let qy = (-ctp * ct).lerp_vec(cp, sz);
⋮----
let g0 = vec3(gx.x, gy.x, gz.x);
let g1 = vec3(gx.y, gy.y, gz.y);
let g2 = vec3(gx.z, gy.z, gz.z);
let g3 = vec3(gx.w, gy.w, gz.w);
⋮----
let w = vec4(
0.5 - x0.dot(x0),
0.5 - x1.dot(x1),
0.5 - x2.dot(x2),
0.5 - x3.dot(x3),
⋮----
.max(Vec4::ZERO);
⋮----
let gdotx = vec4(g0.dot(x0), g1.dot(x1), g2.dot(x2), g3.dot(x3));
⋮----
let n = w3.dot(gdotx);
⋮----
/// 3D tiling simplex noise with fixed gradients and analytical derivatives.
///
⋮----
///
/// Wrapper around `tiling_rot_noise_3d` with no rotation.
⋮----
/// Wrapper around `tiling_rot_noise_3d` with no rotation.
///
⋮----
/// * `period` - Desired periods along x,y,z (up to 289). Set to 0.0 or negative to skip wrapping along that dimension.
///
⋮----
/// * Gradient vector (x,y,z partial derivatives)
pub fn tiling_noise_3d(pos: Vec3, period: Vec3) -> (f32, Vec3) {
⋮----
pub fn tiling_noise_3d(pos: Vec3, period: Vec3) -> (f32, Vec3) {
tiling_rot_noise_3d(pos, period, 0.0)
⋮----
/// 3D simplex noise with rotating gradients and analytical derivatives (no tiling).
///
⋮----
///
/// Wrapper around `tiling_rot_noise_3d` with no period wrapping.
⋮----
/// Wrapper around `tiling_rot_noise_3d` with no period wrapping.
///
⋮----
/// * `pos` - Point (x,y,z) to evaluate
/// * `norm_rot` - Normalized rotation for swirling gradients, where 1.0 is TAU (2π radians)
⋮----
/// * Gradient vector (x,y,z partial derivatives)
pub fn rot_noise_3d(pos: Vec3, norm_rot: f32) -> (f32, Vec3) {
⋮----
pub fn rot_noise_3d(pos: Vec3, norm_rot: f32) -> (f32, Vec3) {
tiling_rot_noise_3d(pos, Vec3::ZERO, norm_rot)
</file>

<file path="crates/trivalibs_nostd/src/bits.rs">
pub trait FloatBits<T> {
⋮----
pub trait FromBits<T> {}
⋮----
fn to_bits(self) -> UVec2 {
UVec2::new(self.x.to_bits(), self.y.to_bits())
⋮----
fn from_bits(v: UVec2) -> Self {
⋮----
fn to_bits(self) -> UVec3 {
UVec3::new(self.x.to_bits(), self.y.to_bits(), self.z.to_bits())
⋮----
fn from_bits(v: UVec3) -> Self {
⋮----
fn to_bits(self) -> UVec4 {
⋮----
self.x.to_bits(),
self.y.to_bits(),
self.z.to_bits(),
self.w.to_bits(),
⋮----
fn from_bits(v: UVec4) -> Vec4 {
</file>

<file path="crates/trivalibs_nostd/src/color.rs">
use core::f32::consts::PI;
⋮----
use spirv_std::num_traits::Float;
⋮----
pub fn rgb2hsl(c: Vec3) -> Vec3 {
let k = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
let p = vec4(c.z, c.y, k.w, k.z).lerp(vec4(c.y, c.z, k.x, k.y), step(c.z, c.y));
let q = vec4(p.x, p.y, p.w, c.x).lerp(vec4(c.x, p.y, p.z, p.x), step(p.x, c.x));
let d = q.x - q.w.min(q.y);
⋮----
vec3(
(q.z + (q.w - q.y) / (6.0 * d + e)).abs(),
⋮----
//  Function from Iñigo Quiles
//  https://www.shadertoy.com/view/MsS3Wc
⋮----
pub fn hsv2rgb(c: Vec3) -> Vec3 {
let rgb = ((((c.x * 6.0 + vec3(0.0, 4.0, 2.0)) % 6.0) - 3.0).abs() - 1.0).clamp01();
c.z * Vec3::ONE.lerp(rgb, c.y)
⋮----
pub fn hsv2rgb_smooth(c: Vec3) -> Vec3 {
let rgb = ((((c.x * 6.0 + vec3(0.0, 4.0, 2.0)) % 6.0) - 3.0).abs() - 1.0)
.clamp01()
.smoothen();
⋮----
pub fn hsv2rgb_smoother(c: Vec3) -> Vec3 {
⋮----
.smoothen_more();
⋮----
/// blend rgb color using trigonometry. This is an experiment. hsv2rgb_smooth looks almost the same, but is much cheeper.
pub fn hsv2rgb_smoothest(c: Vec3) -> Vec3 {
⋮----
pub fn hsv2rgb_smoothest(c: Vec3) -> Vec3 {
let mut rgb = ((((c.x * 6.0 + vec3(0.0, 4.0, 2.0)) % 6.0) - 3.0).abs() - 1.0).clamp01();
⋮----
rgb.x = ((rgb.x + 1.0) * PI).cos().fit1101();
rgb.y = ((rgb.y + 1.0) * PI).cos().fit1101();
rgb.z = ((rgb.z + 1.0) * PI).cos().fit1101();
</file>

<file path="crates/trivalibs_nostd/src/vec_ext.rs">
use crate::num_ext::NumExt;
⋮----
use spirv_std::num_traits::Float;
⋮----
pub trait VecExt
⋮----
/// Fractional part of each vector component. It is defined as `x - floor(x)`.
	/// In contrast, rust std implementation fract is defined as `x - trunc(x)`, which inverts direction when negative.
⋮----
/// In contrast, rust std implementation fract is defined as `x - trunc(x)`, which inverts direction when negative.
	/// Same as glam's fract_gl.
⋮----
/// Same as glam's fract_gl.
	fn frct(self) -> Self;
⋮----
impl VecExt for Vec2 {
fn sin(self) -> Self {
vec2(self.x.sin(), self.y.sin())
⋮----
fn cos(self) -> Self {
vec2(self.x.cos(), self.y.cos())
⋮----
fn sqrt(self) -> Self {
vec2(self.x.sqrt(), self.y.sqrt())
⋮----
fn frct(self) -> Self {
vec2(self.x.frct(), self.y.frct())
⋮----
fn fit0111(self) -> Self {
vec2(self.x.fit0111(), self.y.fit0111())
⋮----
fn fit1101(self) -> Self {
vec2(self.x.fit1101(), self.y.fit1101())
⋮----
fn clamp01(self) -> Self {
self.clamp(Vec2::ZERO, Vec2::ONE)
⋮----
fn step(self, edge: Vec2) -> Vec2 {
vec2(self.x.step(edge.x), self.y.step(edge.y))
⋮----
fn step_f32(self, edge: f32) -> Vec2 {
vec2(self.x.step(edge), self.y.step(edge))
⋮----
fn step_fn<F: Fn(f32) -> f32>(self, edge0: Self, edge1: Self, f: F) -> Self {
vec2(
self.x.step_fn(edge0.x, edge1.x, &f),
self.y.step_fn(edge0.y, edge1.y, &f),
⋮----
fn gt(self, other: Self) -> Self {
vec2(self.x.gtf(other.x), self.y.gtf(other.y))
⋮----
fn lt(self, other: Self) -> Self {
vec2(self.x.ltf(other.x), self.y.ltf(other.y))
⋮----
fn gte(self, other: Self) -> Self {
vec2(self.x.gtef(other.x), self.y.gtef(other.y))
⋮----
fn lte(self, other: Self) -> Self {
vec2(self.x.ltef(other.x), self.y.ltef(other.y))
⋮----
fn gt_f32(self, other: f32) -> Self {
vec2(self.x.gtf(other), self.y.gtf(other))
⋮----
fn lt_f32(self, other: f32) -> Self {
vec2(self.x.ltf(other), self.y.ltf(other))
⋮----
fn gte_f32(self, other: f32) -> Self {
vec2(self.x.gtef(other), self.y.gtef(other))
⋮----
fn lte_f32(self, other: f32) -> Self {
vec2(self.x.ltef(other), self.y.ltef(other))
⋮----
fn smoothen(self) -> Self {
vec2(self.x.smoothen(), self.y.smoothen())
⋮----
fn smoothen_more(self) -> Self {
vec2(self.x.smoothen_more(), self.y.smoothen_more())
⋮----
fn smoothstep(self, edge0: Self, edge1: Self) -> Self {
⋮----
self.x.smoothstep(edge0.x, edge1.x),
self.y.smoothstep(edge0.y, edge1.y),
⋮----
fn lerp_vec(self, other: Self, t: Self) -> Self {
vec2(self.x.lerp(other.x, t.x), self.y.lerp(other.y, t.y))
⋮----
impl VecExt for Vec3 {
⋮----
vec3(self.x.sin(), self.y.sin(), self.z.sin())
⋮----
vec3(self.x.cos(), self.y.cos(), self.z.cos())
⋮----
vec3(self.x.sqrt(), self.y.sqrt(), self.z.sqrt())
⋮----
vec3(self.x.frct(), self.y.frct(), self.z.frct())
⋮----
vec3(self.x.fit0111(), self.y.fit0111(), self.z.fit0111())
⋮----
vec3(self.x.fit1101(), self.y.fit1101(), self.z.fit1101())
⋮----
self.clamp(Vec3::ZERO, Vec3::ONE)
⋮----
fn step(self, edge: Vec3) -> Vec3 {
vec3(
self.x.step(edge.x),
self.y.step(edge.y),
self.z.step(edge.z),
⋮----
fn step_f32(self, edge: f32) -> Vec3 {
vec3(self.x.step(edge), self.y.step(edge), self.z.step(edge))
⋮----
self.z.step_fn(edge0.z, edge1.z, &f),
⋮----
self.x.gtf(other.x),
self.y.gtf(other.y),
self.z.gtf(other.z),
⋮----
self.x.ltf(other.x),
self.y.ltf(other.y),
self.z.ltf(other.z),
⋮----
self.x.gtef(other.x),
self.y.gtef(other.y),
self.z.gtef(other.z),
⋮----
self.x.ltef(other.x),
self.y.ltef(other.y),
self.z.ltef(other.z),
⋮----
vec3(self.x.gtf(other), self.y.gtf(other), self.z.gtf(other))
⋮----
vec3(self.x.ltf(other), self.y.ltf(other), self.z.ltf(other))
⋮----
vec3(self.x.gtef(other), self.y.gtef(other), self.z.gtef(other))
⋮----
vec3(self.x.ltef(other), self.y.ltef(other), self.z.ltef(other))
⋮----
vec3(self.x.smoothen(), self.y.smoothen(), self.z.smoothen())
⋮----
self.x.smoothen_more(),
self.y.smoothen_more(),
self.z.smoothen_more(),
⋮----
self.z.smoothstep(edge0.z, edge1.z),
⋮----
self.x.lerp(other.x, t.x),
self.y.lerp(other.y, t.y),
self.z.lerp(other.z, t.z),
⋮----
impl VecExt for Vec4 {
⋮----
vec4(self.x.sin(), self.y.sin(), self.z.sin(), self.w.sin())
⋮----
vec4(self.x.cos(), self.y.cos(), self.z.cos(), self.w.cos())
⋮----
vec4(self.x.sqrt(), self.y.sqrt(), self.z.sqrt(), self.w.sqrt())
⋮----
vec4(self.x.frct(), self.y.frct(), self.z.frct(), self.w.frct())
⋮----
vec4(
self.x.fit0111(),
self.y.fit0111(),
self.z.fit0111(),
self.w.fit0111(),
⋮----
self.x.fit1101(),
self.y.fit1101(),
self.z.fit1101(),
self.w.fit1101(),
⋮----
self.clamp(Vec4::ZERO, Vec4::ONE)
⋮----
fn step(self, edge: Vec4) -> Vec4 {
⋮----
self.w.step(edge.w),
⋮----
fn step_f32(self, edge: f32) -> Vec4 {
⋮----
self.x.step(edge),
self.y.step(edge),
self.z.step(edge),
self.w.step(edge),
⋮----
self.w.step_fn(edge0.w, edge1.w, &f),
⋮----
self.w.gtf(other.w),
⋮----
self.w.ltf(other.w),
⋮----
self.w.gtef(other.w),
⋮----
self.w.ltef(other.w),
⋮----
self.x.gtf(other),
self.y.gtf(other),
self.z.gtf(other),
self.w.gtf(other),
⋮----
self.x.ltf(other),
self.y.ltf(other),
self.z.ltf(other),
self.w.ltf(other),
⋮----
self.x.gtef(other),
self.y.gtef(other),
self.z.gtef(other),
self.w.gtef(other),
⋮----
self.x.ltef(other),
self.y.ltef(other),
self.z.ltef(other),
self.w.ltef(other),
⋮----
self.x.smoothen(),
self.y.smoothen(),
self.z.smoothen(),
self.w.smoothen(),
⋮----
self.w.smoothen_more(),
⋮----
self.w.smoothstep(edge0.w, edge1.w),
⋮----
self.w.lerp(other.w, t.w),
</file>

<file path="crates/trivalibs_nostd/Cargo.toml">
[package]
name = "trivalibs-nostd"
version = "0.1.0"
edition.workspace = true

[dependencies]
spirv-std.workspace = true

[target.'cfg(not(target_arch = "spirv"))'.dependencies]
glam.workspace = true
</file>

<file path="crates/trivalibs_painter/src/window_dimensions.rs">
pub struct WindowDimensions {
⋮----
impl WindowDimensions {
pub fn get_state_path() -> PathBuf {
let mut path = dirs::config_dir().unwrap_or_else(|| PathBuf::from("."));
path.push("rust-graphics");
path.push("window-state.json");
⋮----
pub fn load() -> Option<Self> {
⋮----
.ok()
.and_then(|json| serde_json::from_str(&json).ok())
⋮----
pub fn save(&self) -> std::io::Result<()> {
⋮----
fs::create_dir_all(path.parent().unwrap())?;
⋮----
pub fn from_window(size: PhysicalSize<u32>, position: PhysicalPosition<i32>) -> Self {
⋮----
pub fn cleanup() -> std::io::Result<()> {
⋮----
if path.exists() {
⋮----
Ok(())
</file>

<file path="crates/trivalibs_painter/Cargo.toml">
[package]
name = "trivalibs-painter"
version = "0.1.0"
edition.workspace = true

[dependencies]
trivalibs-core = { path = "../trivalibs_core" }
bytemuck.workspace = true
winit.workspace = true
wgpu.workspace = true
log.workspace = true
env_logger.workspace = true
pollster.workspace = true
notify.workspace = true
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
dirs = "5.0"
web-time = "1.0"

[target.'cfg(target_arch = "wasm32")'.dependencies]
wasm-bindgen-futures = "0.4"
web-sys = { version = "0.3", features = ["HtmlCanvasElement", "CssStyleDeclaration", "Document", "Element", "HtmlElement", "Node", "Window"] }
console_error_panic_hook = "0.1"
console_log = "1"
</file>

<file path="examples/ball/shader/src/lib.rs">
pub fn vertex(
⋮----
// #[spirv(descriptor_set = 0, binding = 2)] light_dir: &Vec3,
⋮----
*clip_pos = *mvp_mat * position.extend(1.0);
⋮----
pub fn fragment(
⋮----
#[spirv(descriptor_set = 1, binding = 0)] tex: &Image!(2D, type=f32, sampled),
⋮----
let col = tex.sample(*sampler, in_uv);
*frag_color = in_color.extend(1.0) * in_norm.extend(1.0).abs() * vec4(col.x, col.y, col.z, 1.0);
</file>

<file path="examples/blur/shader/Cargo.toml">
[package]
name = "blur_shader"
version = "0.1.0"
edition.workspace = true

[lib]
crate-type = ["rlib", "cdylib"]

[dependencies]
spirv-std.workspace = true
trivalibs-nostd.workspace = true
</file>

<file path="examples/dynamic_shapes/shader/src/lib.rs">
use spirv_std::spirv;
⋮----
pub fn vertex(position: Vec2, #[spirv(position)] clip_pos: &mut Vec4, pos: &mut Vec2) {
*clip_pos = position.extend(0.0).extend(1.0);
*pos = position.fit1101();
⋮----
pub fn fragment(
⋮----
*frag_color = color.powf(2.2).extend(alpha);
⋮----
pub fn effect_fragment(
⋮----
let color: Vec4 = texture.sample(*sampler, uv);
*frag_color = vec4(color.x, color.y, color.z, color.w);
</file>

<file path="examples/dynamic_shapes/shader/Cargo.toml">
[package]
name = "dynamic_shapes_shader"
edition.workspace = true
version = "0.1.0"

[lib]
crate-type = ["rlib", "cdylib"]

[dependencies]
spirv-std.workspace = true
trivalibs-nostd.workspace = true
</file>

<file path="examples/dynamic_shapes/shader/manifest.json">
[
  {
    "source_path": "effect_fragment.spv",
    "entry_point": "effect_fragment",
    "wgsl_entry_point": "effect_fragment"
  },
  {
    "source_path": "fragment.spv",
    "entry_point": "fragment",
    "wgsl_entry_point": "fragment"
  },
  {
    "source_path": "vertex.spv",
    "entry_point": "vertex",
    "wgsl_entry_point": "vertex"
  }
]
</file>

<file path="examples/geometries/shader/Cargo.toml">
[package]
name = "room_shader"
version = "0.1.0"
edition.workspace = true

[lib]
crate-type = ["rlib", "cdylib"]

# Dependencies for CPU and GPU code
[dependencies]
spirv-std.workspace = true
trivalibs-nostd.workspace = true
</file>

<file path="examples/mipmap/shader/manifest.json">
[
  {
    "source_path": "image.spv",
    "entry_point": "image",
    "wgsl_entry_point": "image"
  },
  {
    "source_path": "mip_sampling.spv",
    "entry_point": "mip_sampling",
    "wgsl_entry_point": "mip_sampling"
  },
  {
    "source_path": "wave_effect.spv",
    "entry_point": "wave_effect",
    "wgsl_entry_point": "wave_effect"
  }
]
</file>

<file path="examples/noise_tests/shader/src/lib.rs">
use spirv_std::num_traits::Float;
⋮----
fn aspect_preserving_uv(uv: Vec2, size: UVec2) -> Vec2 {
⋮----
uv * vec2(1.0, 1.0 / aspect)
⋮----
uv * vec2(aspect, 1.0)
⋮----
pub fn simplex_3d_shader(
⋮----
let uv = aspect_preserving_uv(uv, *size);
⋮----
let noise = simplex_noise_3d(uv.extend(*time)).fit1101();
⋮----
let color = Vec3::splat(noise).powf(GAMMA).extend(1.0);
⋮----
pub fn simplex_2d_shader(
⋮----
let noise = simplex_noise_2d(uv * (time.sin().fit1101() * 20. + 0.5)).fit1101();
⋮----
pub fn simplex_4d_shader(
⋮----
let noise = simplex_noise_4d(uv.extend(123. + *time * 0.2345).extend(*time)).fit1101();
⋮----
pub fn tiling_simplex_shader(
⋮----
let uv = (uv * 1.5 + *time * 0.1).fract();
let scale = (time * 0.2).sin().fit1101() * 4. + 0.5;
⋮----
let noise = tiling_simplex_noise_2d(uv, scale).fit1101();
⋮----
pub fn tiling_noise_2d_shader(
⋮----
let noise = tiling_rot_noise_2d(
(uv * 2.5).fract() * 4. + 0.5, // shift by 0.5 to avoid tiling artifacts
vec2(1.0, 1.0) * 4.,
⋮----
.fit1101();
⋮----
pub fn tiling_noise_3d_shader(
⋮----
let noise = tiling_rot_noise_3d(
((uv * 2.5).fract() * 4. + 0.5) // shift by 0.5 to avoid tiling artifacts
.extend(*time * 0.2),
⋮----
pub fn hash_shader(
⋮----
let q_uv = (uv * 2.).fract();
let q_idx = (uv * 2.).floor().as_uvec2();
⋮----
} else if q_idx.eq(&uvec2(0, 0)) {
let v = hash(q_uv.x.to_bits() + hashi((q_uv.y + time).to_bits()));
vec3(v, 0.0, 0.0)
} else if q_idx.eq(&uvec2(1, 0)) {
let v = hash21((q_uv + time).to_bits());
vec3(0.0, v, 0.0)
} else if q_idx.eq(&uvec2(0, 1)) {
let v = hash2d((q_uv + time).to_bits());
v.extend(1.0)
} else if q_idx.eq(&uvec2(1, 1)) {
hash3d(q_uv.extend(time).to_bits())
⋮----
vec3(0.0, 1.0, 1.0)
⋮----
color.powf(GAMMA).extend(1.0)
</file>

<file path="examples/random_lines/shader/src/lib.rs">
use spirv_std::spirv;
⋮----
pub fn vertex(position: Vec2, #[spirv(position)] clip_pos: &mut Vec4) {
*clip_pos = position.extend(0.0).extend(1.0);
⋮----
pub fn fragment(
⋮----
*frag_color = color.powf(2.2).extend(1.0);
</file>

<file path="crates/trivalibs_core/src/rendering/mod.rs">
pub mod camera;
pub mod line_2d;
pub mod mesh_geometry;
pub mod scene;
pub mod shapes;
pub mod texture;
pub mod webgl_buffered_geometry;
⋮----
pub struct BufferedGeometry {
⋮----
fn into(self) -> BufferedGeometry {
⋮----
vertex_buffer: bytemuck::cast_slice(self).to_vec(),
⋮----
vertex_count: self.len() as u32,
⋮----
vertex_buffer: bytemuck::cast_slice(&self).to_vec(),
</file>

<file path="crates/trivalibs_core/Cargo.toml">
[package]
name = "trivalibs-core"
version = "0.1.0"
edition.workspace = true

[dependencies]
trivalibs-macros = { path = "../trivalibs_macros" }
trivalibs-nostd.workspace = true
serde.workspace = true
serde_repr.workspace = true
serde_bytes.workspace = true
bytemuck.workspace = true
js-sys.workspace = true
lerp.workspace = true
approx.workspace = true
rand.workspace = true
getrandom.workspace = true
glam.workspace = true
log.workspace = true
env_logger.workspace = true
macro_rules_attribute.workspace = true
rustc-hash = "2.1"
</file>

<file path="crates/trivalibs_painter/src/sampler.rs">
pub struct SamplerProps {
⋮----
impl Default for SamplerProps {
fn default() -> Self {
⋮----
impl SamplerProps {
⋮----
pub struct Sampler(pub(crate) usize);
⋮----
impl Sampler {
pub fn create(painter: &mut Painter, props: SamplerProps) -> Self {
let sampler = painter.device.create_sampler(&wgpu::SamplerDescriptor {
⋮----
compare: props.sample_depth.then(|| wgpu::CompareFunction::LessEqual),
⋮----
painter.samplers.push(sampler);
⋮----
Self(painter.samplers.len() - 1)
⋮----
pub fn binding(&self) -> ValueBinding {
⋮----
pub struct SamplerBuilder<'a> {
⋮----
pub fn new(painter: &'a mut Painter) -> Self {
⋮----
pub fn create(self) -> Sampler {
⋮----
pub fn with_address_mode_u(mut self, mode: wgpu::AddressMode) -> Self {
⋮----
pub fn with_address_mode_v(mut self, mode: wgpu::AddressMode) -> Self {
⋮----
pub fn with_address_modes(mut self, mode: wgpu::AddressMode) -> Self {
⋮----
pub fn with_mag_filter(mut self, filter: wgpu::FilterMode) -> Self {
⋮----
pub fn with_min_filter(mut self, filter: wgpu::FilterMode) -> Self {
⋮----
pub fn with_filters(mut self, filter: wgpu::FilterMode) -> Self {
⋮----
pub fn with_mipmap_filter(mut self, filter: wgpu::FilterMode) -> Self {
⋮----
pub fn with_depth_sampling(mut self) -> Self {
</file>

<file path="examples/base_effect/shader/src/lib.rs">
use spirv_std::num_traits::Float;
use spirv_std::spirv;
⋮----
pub fn main(
⋮----
let tile_dim = vec2(200.0, 100.0);
let size = vec2(size.x as f32, size.y as f32);
⋮----
let gap = vec2(gap_size, gap_size * tile_ratio);
⋮----
tile.y -= (time * 0.5).frct() * 2.0;
let y_offet = tile.y.ceil() % 2.0;
⋮----
let tile = tile.frct();
⋮----
vec4(0.4, 0.6, 0.9, 1.0)
⋮----
vec4(1.0, 0.8, 0.5, 1.0)
</file>

<file path="examples/base_effect/shader/Cargo.toml">
[package]
name = "base_effect_shader"
edition.workspace = true
version = "0.1.0"

[lib]
crate-type = ["rlib", "cdylib"]

[dependencies]
spirv-std.workspace = true
trivalibs-nostd.workspace = true
</file>

<file path="examples/deferred_light/geom.rs">
struct Vertex {
⋮----
impl Position3D for Vertex {
fn position(&self) -> Vec3 {
⋮----
fn vert_pos(pos: Vec3) -> Vertex {
⋮----
fn vert(pos: Vec3, color: Vec3) -> Vertex {
⋮----
pub fn create_ball_geom() -> BufferedGeometry {
let geom = create_sphere_mesh(
⋮----
|horiz_angle, vert_angle| vert_pos(angles_to_cartesian(horiz_angle, vert_angle)),
⋮----
let mut geom = geom.map(|face| {
let color = vec3(random(), random(), random());
⋮----
face.vertices().iter().map(|v| vert(v.pos, color)).collect()
⋮----
geom.to_buffered_geometry_by_type(MeshBufferType::FaceVerticesWithVertexNormal)
⋮----
pub fn create_box_geom() -> BufferedGeometry {
⋮----
geom.add_face(
quad.to_ccw_verts()
.iter()
.map(|pos| vert(*pos, color))
⋮----
add(&mut geom, box_shape.front_face(), vec3(1.0, 0.0, 0.0));
add(&mut geom, box_shape.back_face(), vec3(0.0, 1.0, 0.0));
add(&mut geom, box_shape.left_face(), vec3(0.0, 0.0, 1.0));
add(&mut geom, box_shape.right_face(), vec3(1.0, 1.0, 0.0));
add(&mut geom, box_shape.top_face(), vec3(0.0, 1.0, 1.0));
add(&mut geom, box_shape.bottom_face(), vec3(1.0, 0.0, 1.0));
⋮----
geom.to_buffered_geometry_by_type(MeshBufferType::FaceVerticesWithFaceNormal)
</file>

<file path="examples/user_event/main.rs">
struct App {
⋮----
struct UserEvent(wgpu::Color);
⋮----
fn init(p: &mut Painter) -> Self {
// Initialize the app
⋮----
.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
⋮----
// let capabilities = painter.surface.get_capabilities(&painter.adapter);
// let format = capabilities.formats[0];
⋮----
// Load the shaders from disk
⋮----
.create_shader_module(include_spirv!("./shader/vertex.spv"));
⋮----
.create_shader_module(include_spirv!("./shader/fragment.spv"));
⋮----
.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
⋮----
layout: Some(&pipeline_layout),
⋮----
fragment: Some(wgpu::FragmentState {
⋮----
targets: &[Some(wgpu::ColorTargetState {
format: p.config.format, // for direct rendering into te surface
blend: Some(wgpu::BlendState::REPLACE),
⋮----
fn frame(&mut self, painter: &mut Painter, _tpf: f32) {
let frame = painter.surface.get_current_texture().unwrap();
⋮----
.create_view(&wgpu::TextureViewDescriptor::default());
⋮----
.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: None });
⋮----
let mut rpass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
⋮----
color_attachments: &[Some(wgpu::RenderPassColorAttachment {
⋮----
rpass.set_pipeline(&self.pipeline);
rpass.draw(0..3, 0..1);
⋮----
painter.queue.submit(Some(encoder.finish()));
frame.present();
⋮----
fn event(&mut self, event: Event<UserEvent>, painter: &mut Painter) {
⋮----
painter.request_next_frame();
⋮----
fn resize(&mut self, _p: &mut Painter, _w: u32, _h: u32) {}
⋮----
pub fn main() {
⋮----
let handle = app.get_handle();
⋮----
let _ = handle.send_event(UserEvent(wgpu::Color::RED));
⋮----
let _ = handle.send_event(UserEvent(wgpu::Color::GREEN));
⋮----
let _ = handle.send_event(UserEvent(wgpu::Color::BLUE));
⋮----
app.start();
</file>

<file path="crates/trivalibs_core/src/rendering/shapes/sphere.rs">
use bytemuck::Zeroable;
⋮----
pub fn create_sphere_mesh<V: Position3D + Clone + Zeroable>(
⋮----
let mut last_col = vec![];
⋮----
for i in 0..(col1.len() - 1) {
let v1 = col2[i].clone();
let v2 = col2[i + 1].clone();
let v3 = col1[i].clone();
let v4 = col1[i + 1].clone();
⋮----
geom.add_face(&[v1, v2, v4, v3]);
⋮----
geom.add_face(&[first_vert, col2[0].clone(), col1[0].clone()]);
⋮----
geom.add_face(&[
col2[col2.len() - 1].clone(),
⋮----
col1[col1.len() - 1].clone(),
⋮----
let mut col = vec![];
⋮----
let first_vert = f(u, -PI * 0.5);
let last_vert = f(u, PI * 0.5);
⋮----
col.push(f(u, v));
⋮----
if last_col.is_empty() {
⋮----
add_cols(&mut geom, last_col, col.clone(), first_vert, last_vert);
</file>

<file path="crates/trivalibs_nostd/src/lib.rs">
pub mod bits;
pub mod blur;
pub mod color;
pub mod coords;
pub mod num_ext;
pub mod random;
pub mod vec_ext;
⋮----
pub mod prelude {
</file>

<file path="examples/ball/geom.rs">
use std::f32::consts::PI;
⋮----
struct Vertex {
⋮----
impl Position3D for Vertex {
fn position(&self) -> Vec3 {
⋮----
fn vert(pos: Vec3, uv: Vec2, color: Vec3) -> Vertex {
⋮----
fn pos_vert(pos: Vec3, uv: Vec2) -> Vertex {
⋮----
pub fn create_ball_geom() -> BufferedGeometry {
let geom = create_sphere_mesh(
⋮----
let pos = angles_to_cartesian(horiz_angle, vert_angle);
let uv = vec2(horiz_angle / (PI * 2.0), vert_angle / PI + 0.5);
⋮----
pos_vert(pos * 5.0, uv)
⋮----
let mut geom = geom.map(|face| {
let vertices = face.vertices();
⋮----
let uv = vertices.iter().map(|v| v.uv).sum::<Vec2>() / vertices.len() as f32;
⋮----
let color = vec3(random(), random(), random()) * 0.2 + gradient * 0.8;
⋮----
vertices.iter().map(|v| vert(v.pos, v.uv, color)).collect()
⋮----
geom.to_buffered_geometry_by_type(MeshBufferType::FaceVerticesWithVertexNormal)
⋮----
fn ball1() {
let res = create_ball_geom();
// println!("{:?}", res);
assert!(res.vertex_buffer.len() > 0);
println!("buffer len: {}", res.vertex_buffer.len());
println!(
</file>

<file path="examples/mipmap/shader/src/lib.rs">
use spirv_std::num_traits::Float;
use spirv_std::spirv;
⋮----
use trivalibs_nostd::num_ext::NumExt;
⋮----
pub fn aspect_preserving_uv(uv: Vec2, size: UVec2) -> Vec2 {
⋮----
uv * vec2(1.0, 1.0 / aspect)
⋮----
uv * vec2(aspect, 1.0)
⋮----
pub fn image(
⋮----
let uv = aspect_preserving_uv(coord, *size).fit0111();
⋮----
let uv = uv * (7.0 + (*time * 0.1).sin());
let mut idx = uv.floor();
let mut uv = uv.frct();
⋮----
let h1 = hash((idx.x + (8.0 * i as f32) * idx.y + 8.0.powf(i as f32 + 1.0)) as u32);
⋮----
vec2(uv.x * 2.0, uv.y)
⋮----
vec2(uv.x, uv.y * 2.0)
⋮----
idx = uv.floor() * 8.0 + idx;
uv = uv.frct();
⋮----
let h2 = hash((idx.x + (8.0 * (1 + i) as f32) * idx.y + (8.0.powf(i as f32))) as u32);
⋮----
idx = uv.floor() * (8.0 * (i + 2) as f32) + idx;
⋮----
let h = hash(((idx.x + (8.0 * 4.0) * idx.y) + 9.0.powf(4.0f32)) as u32);
⋮----
let color = hsv2rgb(vec3(h, 0.7, 0.7));
⋮----
*out = color.powf(2.2).extend(1.0);
⋮----
pub fn mip_sampling(
⋮----
#[spirv(descriptor_set = 1, binding = 0)] tex: &Image!(2D, type=f32, sampled),
⋮----
let col = tex.sample_by_lod(*sampler, coord, (*time * 0.2).sin().fit1101() * mips);
⋮----
pub fn wave_effect(
⋮----
let coord = vec2(coord.x + (coord.y * 30.0 + time).sin() * 0.005, coord.y);
let col = tex.sample(*sampler, coord);
</file>

<file path="examples/mouse_color/main.rs">
struct App {
⋮----
fn init(_p: &mut Painter) -> Self {
⋮----
fn frame(&mut self, p: &mut Painter, _tpf: f32) {
let frame = p.surface.get_current_texture().unwrap();
⋮----
.create_view(&wgpu::TextureViewDescriptor::default());
⋮----
.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: None });
⋮----
encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
⋮----
color_attachments: &[Some(wgpu::RenderPassColorAttachment {
⋮----
p.queue.submit(Some(encoder.finish()));
frame.present();
⋮----
fn event(&mut self, event: Event<()>, p: &mut Painter) {
⋮----
let size = p.canvas_size();
⋮----
p.request_next_frame();
⋮----
fn resize(&mut self, _p: &mut Painter, _w: u32, _h: u32) {}
⋮----
pub fn main() {
App::create().start();
</file>

<file path="examples/noise_tests/shader/Cargo.toml">
[package]
name = "noise_tests_shader"
version = "0.1.0"
edition.workspace = true

[lib]
crate-type = ["rlib", "cdylib"]

# Dependencies for CPU and GPU code
[dependencies]
spirv-std.workspace = true
trivalibs-nostd.workspace = true
</file>

<file path="examples/render_to_mip/shader/src/lib.rs">
use spirv_std::glam::Vec3;
⋮----
use spirv_std::num_traits::Float;
use spirv_std::spirv;
⋮----
use trivalibs_nostd::num_ext::NumExt;
use trivalibs_nostd::vec_ext::VecExt;
⋮----
pub fn aspect_preserving_uv(uv: Vec2, size: UVec2) -> Vec2 {
⋮----
uv * vec2(1.0, 1.0 / aspect)
⋮----
uv * vec2(aspect, 1.0)
⋮----
pub fn image(
⋮----
#[spirv(descriptor_set = 1, binding = 0)] tex: &Image!(2D, type=f32, sampled),
⋮----
let idx = coord.floor();
let coord = coord.frct();
⋮----
let col = tex.sample(*sampler, coord);
col.xyz()
⋮----
*out = color.extend(1.0);
⋮----
pub fn mip_sampling(
⋮----
let col = tex.sample_by_lod(*sampler, coord, (*time * 0.1).frct() * mips);
</file>

<file path="examples/triangle/src/main.rs">
use shader::Vertex;
⋮----
position: vec3(0.0, 0.5, 0.0),
color: vec3(1.0, 0.0, 0.0),
uv: vec2(0.5, 1.0),
⋮----
position: vec3(-0.5, -0.5, 0.0),
color: vec3(0.0, 1.0, 0.0),
uv: vec2(0.0, 0.0),
⋮----
position: vec3(0.5, -0.5, 0.0),
color: vec3(0.0, 0.0, 1.0),
uv: vec2(1.0, 0.0),
⋮----
struct App {
⋮----
fn init(p: &mut Painter) -> Self {
// Initialize the app
⋮----
.create_buffer_init(&wgpu::util::BufferInitDescriptor {
label: Some("Vertex Buffer"),
⋮----
let tex_bytes = include_bytes!("../texture.png");
⋮----
.read_info()
.unwrap();
// Allocate the output buffer.
let mut buf = vec![0; reader.output_buffer_size().unwrap()];
// Read the next frame. An APNG might contain multiple frames.
let info = reader.next_frame(&mut buf).unwrap();
// Grab the bytes of the image.
let tex_rgba = &buf[..info.buffer_size()];
⋮----
let diffuse_texture = p.device.create_texture(&wgpu::TextureDescriptor {
// All textures are stored as 3D, we represent our 2D texture
// by setting depth to 1.
⋮----
mip_level_count: 1, // We'll talk about this a little later
⋮----
// Most images are stored using sRGB, so we need to reflect that here.
⋮----
// TEXTURE_BINDING tells wgpu that we want to use this texture in shaders
// COPY_DST means that we want to copy data to this texture
⋮----
label: Some("diffuse_texture"),
// This is the same as with the SurfaceConfig. It
// specifies what texture formats can be used to
// create TextureViews for this texture. The base
// texture format (Rgba8UnormSrgb in this case) is
// always supported. Note that using a different
// texture format is not supported on the WebGL2
// backend.
⋮----
p.queue.write_texture(
// Tells wgpu where to copy the pixel data
⋮----
// The actual pixel data
⋮----
// The layout of the texture
⋮----
bytes_per_row: Some(4 * dimensions.0),
rows_per_image: Some(dimensions.1),
⋮----
// We don't need to configure the texture view much, so let's
// let wgpu define it.
⋮----
diffuse_texture.create_view(&wgpu::TextureViewDescriptor::default());
let diffuse_sampler = p.device.create_sampler(&wgpu::SamplerDescriptor {
⋮----
.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
⋮----
// This should match the filterable field of the
// corresponding Texture entry above.
⋮----
label: Some("texture_bind_group_layout"),
⋮----
let diffuse_bind_group = p.device.create_bind_group(&wgpu::BindGroupDescriptor {
⋮----
label: Some("diffuse_bind_group"),
⋮----
.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
⋮----
// Load the shaders from disk
⋮----
.create_shader_module(include_spirv!("../shader/vertex.spv"));
⋮----
.create_shader_module(include_spirv!("../shader/fragment.spv"));
⋮----
.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
⋮----
layout: Some(&pipeline_layout),
⋮----
fragment: Some(wgpu::FragmentState {
⋮----
targets: &[Some(wgpu::ColorTargetState {
format: p.config.format, // for direct rendering into te surface
blend: Some(wgpu::BlendState::REPLACE),
⋮----
fn frame(&mut self, p: &mut Painter, _tpf: f32) {
let frame = p.surface.get_current_texture().unwrap();
⋮----
.create_view(&wgpu::TextureViewDescriptor::default());
⋮----
.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: None });
⋮----
let mut rpass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
⋮----
color_attachments: &[Some(wgpu::RenderPassColorAttachment {
⋮----
rpass.set_pipeline(&self.pipeline);
rpass.set_bind_group(0, &self.diffuse_bind_group, &[]);
rpass.set_vertex_buffer(0, self.buffer.slice(..));
rpass.draw(0..3, 0..1);
⋮----
p.queue.submit(Some(encoder.finish()));
frame.present();
⋮----
fn event(&mut self, _e: Event<()>, _p: &mut Painter) {}
fn resize(&mut self, _p: &mut Painter, _w: u32, _h: u32) {}
⋮----
pub fn main() {
App::create().start();
</file>

<file path="README.md">
# trivalibs

Shared Rust libraries used for graphics programming targeting WebAssembly and desktop.

## shader crates in trivalibs-painter

Shaders are compiled from Rust to rspirv shaders using [cargo-gpu](https://github.com/Rust-GPU/cargo-gpu).

To compile a shader crate, run `cargo gpu build` in the crate directory.

To watch compile, install `watchexec` and run `watchexec -r -e rs cargo gpu build` in the shader crate directory.
</file>

<file path="crates/trivalibs_painter/src/form.rs">
use trivalibs_core::rendering::BufferedGeometry;
⋮----
pub struct FormProps {
⋮----
impl Default for FormProps {
fn default() -> Self {
⋮----
pub(crate) struct FormGPUBuffers {
⋮----
pub(crate) struct FormStorage {
⋮----
fn create_form_gpu_buffers(device: &wgpu::Device, vertex_size: u64) -> FormGPUBuffers {
let padded_size = get_padded_size(vertex_size);
let vertex_buffer = device.create_buffer(&wgpu::BufferDescriptor {
⋮----
pub struct FormData<'a, T>
⋮----
pub struct FormBuffer<'a> {
⋮----
fn into(self) -> FormBuffer<'a> {
⋮----
vertex_count: self.vertex_buffer.len() as u32,
index_buffer: self.index_buffer.map(|i| bytemuck::cast_slice(i)),
index_count: self.index_buffer.map(|i| i.len() as u32).unwrap_or(0),
⋮----
vertex_buffer: self.vertex_buffer.as_slice(),
⋮----
index_buffer: self.index_buffer.as_deref(),
⋮----
vertex_count: self.len() as u32,
⋮----
vertex_buffer: bytemuck::cast_slice(self.as_slice()),
⋮----
pub struct Form(pub(crate) usize);
⋮----
impl Form {
pub fn update_all<'a, I, B>(&self, painter: &mut Painter, buffers: I)
⋮----
let buffers: Vec<FormBuffer<'a>> = buffers.into_iter().map(|b| b.into()).collect();
⋮----
// Allocate new buffers if we need more than we currently have
while f.buffers.len() < buffers.len() {
let buf_index = f.buffers.len();
let vertex_size = buffers[buf_index].vertex_buffer.len() as u64;
⋮----
.push(create_form_gpu_buffers(&painter.device, vertex_size));
⋮----
for (i, buf) in buffers.iter().enumerate() {
⋮----
// Handle vertex buffer
let vertex_size = buf.vertex_buffer.len() as u64;
let padded_vertex_size = get_padded_size(vertex_size);
⋮----
// If the new data is larger than max_size, recreate the vertex buffer
⋮----
f_buf.vertex_buffer.destroy();
f_buf.vertex_buffer = painter.device.create_buffer(&wgpu::BufferDescriptor {
⋮----
.write_buffer(&f_buf.vertex_buffer, 0, &buf.vertex_buffer);
⋮----
// Handle index buffer
⋮----
let index_size = index_data.len() as u64;
let padded_index_size = get_padded_size(index_size);
⋮----
// If buffer doesn't exist yet (lazy init) or new data is larger, (re)create it
if f_buf.index_buffer.is_none() || f_buf.index_buffer_max_size < padded_index_size {
f_buf.index_buffer.as_ref().map(|b| b.destroy());
⋮----
Some(painter.device.create_buffer(&wgpu::BufferDescriptor {
⋮----
let index_buffer = f_buf.index_buffer.as_ref().unwrap();
painter.queue.write_buffer(index_buffer, 0, &index_data);
⋮----
// Update the count of buffers that contain valid data
f.currently_active_buffers = buffers.len();
⋮----
pub fn update<'a>(&self, painter: &mut Painter, buffer: impl Into<FormBuffer<'a>>) {
self.update_all(painter, vec![buffer.into()]);
⋮----
pub fn new_with_sizes(painter: &mut Painter, sizes: &[u64], props: FormProps) -> Self {
let mut buffers = Vec::with_capacity(sizes.len());
⋮----
buffers.push(create_form_gpu_buffers(&painter.device, *size));
⋮----
currently_active_buffers: 0, // No data yet - will be set by update_all
⋮----
let i = painter.forms.len();
painter.forms.push(f);
⋮----
return Form(i);
⋮----
pub fn new<'a, I, B>(painter: &mut Painter, buffers: I, props: FormProps) -> Self
⋮----
form.update_all(painter, buffers);
⋮----
pub struct FormBuilder<'a, 'b> {
⋮----
pub fn new(painter: &'a mut Painter) -> Self {
⋮----
pub fn create(self) -> Form {
if self.sizes.len() == 0 {
⋮----
f.update_all(self.painter, self.buffers);
⋮----
pub fn with_sizes<I>(mut self, sizes: I) -> Self
⋮----
self.sizes = sizes.into_iter().collect();
⋮----
pub fn with_size(mut self, size: u64) -> Self {
self.sizes.push(size);
⋮----
pub fn with_buffer(mut self, buffer: impl Into<FormBuffer<'b>>) -> Self {
self.buffers.push(buffer.into());
⋮----
pub fn with_buffers<I, B>(mut self, buffers: I) -> Self
⋮----
self.buffers = buffers.into_iter().map(|b| b.into()).collect();
⋮----
pub fn with_topology(mut self, topology: wgpu::PrimitiveTopology) -> Self {
⋮----
pub fn with_front_face(mut self, front_face: wgpu::FrontFace) -> Self {
</file>

<file path="examples/dynamic_texture/main.rs">
struct App {
⋮----
fn init(p: &mut Painter) -> Self {
// Create color shader for red/blue layers
⋮----
.shade_effect()
.with_bindings([BINDING_BUFFER_FRAG])
.create();
load_fragment_shader!(color_shader, p, "./shader/col_fs.spv");
⋮----
// Create texture shader for display layer
⋮----
.with_bindings([BINDING_SAMPLER_FRAG])
.with_layers([BINDING_LAYER_FRAG])
⋮----
load_fragment_shader!(texture_shader, p, "./shader/tex_fs.spv");
⋮----
// Create color uniform bindings
let red_color = p.bind_const_vec4(vec4(1.0, 0.0, 0.0, 1.0));
let blue_color = p.bind_const_vec4(vec4(0.0, 0.0, 1.0, 1.0));
⋮----
// Create red layer - renders solid red color
⋮----
.single_effect_layer(color_shader)
.with_bindings(vec![(0, red_color)])
.with_size(4, 4)
⋮----
p.init_and_paint(red_layer);
⋮----
// Create blue layer - renders solid blue color
⋮----
.with_bindings(vec![(0, blue_color)])
⋮----
p.init_and_paint(blue_layer);
⋮----
// Create sampler for texture sampling
let sampler = p.sampler_nearest();
⋮----
// Create display layer - samples from red/blue layers
// Initially bound to red layer
⋮----
.single_effect_layer(texture_shader)
.with_bindings(vec![(0, sampler.binding())])
.with_layers(vec![(0, red_layer.binding())])
⋮----
fn resize(&mut self, _p: &mut Painter, _width: u32, _height: u32) {}
⋮----
fn frame(&mut self, p: &mut Painter, tpf: f32) {
⋮----
// Toggle every second
⋮----
// This is the key part - dynamically switch texture binding!
⋮----
println!("Switching to RED ({:.2}s)", self.time);
⋮----
.set_layer_binding(p, 0, self.red_layer.binding());
⋮----
println!("Switching to BLUE ({:.2}s)", self.time);
⋮----
.set_layer_binding(p, 0, self.blue_layer.binding());
⋮----
// Render and show display layer (which samples from red or blue)
p.paint_and_show(self.display_layer);
⋮----
p.request_next_frame();
⋮----
fn event(&mut self, _e: Event<()>, _p: &mut Painter) {}
⋮----
pub fn main() {
⋮----
.config(AppConfig {
⋮----
..default()
⋮----
.start();
</file>

<file path="examples/mipmap/shader/Cargo.toml">
[package]
name = "mipmap_shader"
edition.workspace = true
version = "0.1.0"

[lib]
crate-type = ["rlib", "cdylib"]

[dependencies]
spirv-std.workspace = true
trivalibs-nostd.workspace = true
</file>

<file path="examples/render_to_mip/shader/Cargo.toml">
[package]
name = "render_to_mip_shader"
edition.workspace = true
version = "0.1.0"

[lib]
crate-type = ["rlib", "cdylib"]

[dependencies]
spirv-std.workspace = true
trivalibs-nostd.workspace = true
</file>

<file path="crates/trivalibs_painter/src/lib.rs">
pub use wgpu;
pub use winit;
⋮----
pub mod painter;
pub use painter::Painter;
pub mod app;
pub mod bind_group;
pub mod binding;
pub mod binding_constants;
pub mod effect;
pub mod events;
pub mod form;
pub mod layer;
pub(crate) mod pipeline;
pub mod sampler;
pub mod shade;
pub mod shaders;
pub mod shape;
pub mod texture;
pub mod texture_utils;
pub mod utils;
pub(crate) mod window_dimensions;
⋮----
pub mod prelude {
</file>

<file path="crates/trivalibs_painter/src/shape.rs">
pub(crate) struct ShapeStorage {
⋮----
pub struct ShapeProps {
⋮----
impl Default for ShapeProps {
fn default() -> Self {
⋮----
cull_mode: Some(wgpu::Face::Back),
⋮----
pub struct Shape(pub(crate) usize);
⋮----
impl Shape {
pub fn new(painter: &mut Painter, form: Form, shade: Shade, props: ShapeProps) -> Self {
⋮----
let pipeline_key = vec![
⋮----
.into_iter()
.flatten()
.collect();
⋮----
painter.shapes.push(shape);
⋮----
Shape(painter.shapes.len() - 1)
⋮----
/// Builder for creating new [`Shape`]s with custom properties.
///
⋮----
///
/// # Default values for [`ShapeProps`]:
⋮----
/// # Default values for [`ShapeProps`]:
/// - `cull_mode`: `Some(wgpu::Face::Back)`
⋮----
/// - `cull_mode`: `Some(wgpu::Face::Back)`
/// - `blend_state`: `wgpu::BlendState::REPLACE`
⋮----
/// - `blend_state`: `wgpu::BlendState::REPLACE`
///
⋮----
///
/// # Example
⋮----
/// # Example
/// ```
⋮----
/// ```
/// let shape = ShapeBuilder::new(painter, form, shade)
⋮----
/// let shape = ShapeBuilder::new(painter, form, shade)
///     .with_bindings(bindings)
⋮----
///     .with_bindings(bindings)
///     .with_instances(instances)
⋮----
///     .with_instances(instances)
///     .create();
⋮----
///     .create();
/// ```
⋮----
/// ```
pub struct ShapeBuilder<'a> {
⋮----
pub struct ShapeBuilder<'a> {
⋮----
pub fn new(painter: &'a mut Painter, form: Form, shade: Shade) -> Self {
⋮----
pub fn create(self) -> Shape {
⋮----
pub fn with_bindings<I>(mut self, bindings: I) -> Self
⋮----
self.props.bindings = bindings.into_iter().collect();
⋮----
pub fn with_layers<I>(mut self, layers: I) -> Self
⋮----
self.props.layers = layers.into_iter().collect();
⋮----
pub fn with_instances(mut self, instances: Vec<InstanceBinding>) -> Self {
⋮----
pub fn with_cull_mode(mut self, cull_mode: Option<wgpu::Face>) -> Self {
⋮----
pub fn with_blend_state(mut self, blend_state: wgpu::BlendState) -> Self {
</file>

<file path="crates/trivalibs_painter/src/texture_utils.rs">
use trivalibs_core::utils::default;
use wgpu::StoreOp;
⋮----
pub fn num_mip_levels(size: wgpu::Extent3d) -> u32 {
⋮----
let max_size = sizes.into_iter().max().unwrap_or(1);
1 + (max_size as f32).log2().floor() as u32
⋮----
pub fn generate_mipmap_2d(painter: &Painter, texture: &wgpu::Texture) {
⋮----
.create_command_encoder(&wgpu::CommandEncoderDescriptor {
label: Some("mip gen encoder"),
⋮----
for base_mip_level in 1..texture.mip_level_count() {
let src_view = texture.create_view(&wgpu::TextureViewDescriptor {
⋮----
dimension: Some(wgpu::TextureViewDimension::D2),
⋮----
mip_level_count: Some(1),
..default()
⋮----
let dst_view = texture.create_view(&wgpu::TextureViewDescriptor {
⋮----
.create_bind_group(&wgpu::BindGroupDescriptor {
⋮----
layout: &pipeline.pipeline.get_bind_group_layout(1),
⋮----
let mut pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
⋮----
color_attachments: &[Some(wgpu::RenderPassColorAttachment {
⋮----
pass.set_pipeline(&pipeline.pipeline);
pass.set_bind_group(0, &painter.bind_groups[1].bind_group, &[]);
pass.set_bind_group(1, &src_binding, &[]);
⋮----
pass.draw(0..3, 0..1); // Assuming a fullscreen quad
⋮----
painter.queue.submit(Some(encoder.finish()));
⋮----
pub(crate) fn map_format_to_u8(format: wgpu::TextureFormat) -> u8 {
</file>

<file path="examples/random_lines/main.rs">
struct App {
⋮----
// Generate a single line made of multiple quad segments
fn generate_line_geometry(start: Vec2, end: Vec2, width: f32, segments: usize) -> Vec<Vec2> {
⋮----
let dir = (end - start).normalize();
let perp = vec2(-dir.y, dir.x) * (width * 0.5);
⋮----
let p0 = start + dir * (t0 * (end - start).length());
let p1 = start + dir * (t1 * (end - start).length());
⋮----
// Create quad for this segment (two triangles)
// Triangle 1
vertices.push(vec2(p0.x - perp.x, p0.y - perp.y));
vertices.push(vec2(p1.x + perp.x, p1.y + perp.y));
vertices.push(vec2(p0.x + perp.x, p0.y + perp.y));
⋮----
// Triangle 2
⋮----
vertices.push(vec2(p1.x - perp.x, p1.y - perp.y));
⋮----
// Generate random lines with varying segment counts - each line as separate vector
fn generate_all_lines() -> Vec<Vec<Vec2>> {
let line_count = rand_range(1.0, 10.0) as usize;
⋮----
let start = vec2(rand_range(-0.9, 0.9), rand_range(-0.9, 0.9));
let end = vec2(rand_range(-0.9, 0.9), rand_range(-0.9, 0.9));
let segments = rand_range(1.0, 10.0) as usize;
⋮----
// Width in normalized device coordinates (60px relative to screen)
⋮----
let line_verts = generate_line_geometry(start, end, width, segments);
all_lines.push(line_verts);
⋮----
fn init(p: &mut Painter) -> Self {
// Generate initial geometry - each line gets its own buffer
let initial_lines = generate_all_lines();
⋮----
// Create form with initial data using FormBuilder with_buffers
// Pass the Vec directly - each Vec<Vec3> converts to FormBuffer automatically
let form = p.form_builder().with_buffers(&initial_lines).create();
⋮----
// Create shade with vec3 position and vec3 color uniform
⋮----
.shade([Float32x2])
.with_bindings([BINDING_BUFFER_FRAG])
.create();
⋮----
// Load shaders
load_vertex_shader!(shade, p, "./shader/vertex.spv");
load_fragment_shader!(shade, p, "./shader/fragment.spv");
⋮----
// Create color binding with random initial color
let color_binding = p.bind_vec3();
color_binding.update_vec3(p, rand_vec3());
⋮----
// Create shape
⋮----
.shape(form, shade)
.with_bindings(map! {
⋮----
.layer()
.with_shape(shape)
.with_clear_color(wgpu::Color::WHITE)
.with_multisampling()
⋮----
fn frame(&mut self, p: &mut Painter, tpf: f32) {
⋮----
// Every second, regenerate geometry and color
⋮----
// Generate new random lines - each line as separate buffer
let new_lines = generate_all_lines();
⋮----
// Update form with all new geometries using update_all
// Pass the Vec directly - each Vec<Vec2> converts to FormBuffer automatically
self.form.update_all(p, &new_lines);
⋮----
// Update color with new random color
self.color_binding.update_vec3(p, rand_vec3());
⋮----
let total_vertices: usize = new_lines.iter().map(|l| l.len()).sum();
println!(
⋮----
p.paint_and_show(self.canvas);
⋮----
// Request continuous rendering
p.request_next_frame();
⋮----
fn resize(&mut self, _p: &mut Painter, _width: u32, _height: u32) {}
fn event(&mut self, _e: Event<()>, _p: &mut Painter) {}
⋮----
pub fn main() {
⋮----
.config(AppConfig {
⋮----
..default()
⋮----
.start();
</file>

<file path="examples/simple_triangle/main.rs">
const VERTICES: &[Vec3] = &[vec3(0.0, 5.0, 0.0), vec3(-2.5, 0., 0.0), vec3(2.5, 0., 0.0)];
⋮----
struct App {
⋮----
fn init(p: &mut Painter) -> Self {
⋮----
.shade([Float32x3])
.with_bindings([
⋮----
.create();
load_vertex_shader!(shade, p, "./shader/vertex.spv");
load_fragment_shader!(shade, p, "./shader/fragment.spv");
⋮----
let form = p.form(VERTICES).create();
⋮----
let model_mat = p.bind_mat4();
let cam = p.bind_mat4();
⋮----
let color = p.bind_const_vec4(vec4(1.0, 0.0, 0.0, 1.0));
⋮----
.shape(form, shade)
.with_bindings(map! {
⋮----
.with_cull_mode(None)
⋮----
.layer()
.with_shape(shape)
.with_clear_color(wgpu::Color::BLACK)
.with_multisampling()
⋮----
Transform::from_translation(vec3(0.0, -20.0, 0.0)).with_scale(Vec3::splat(8.0));
⋮----
fov: Some(0.6),
translation: Some(vec3(0.0, 0.0, 80.0)),
..default()
⋮----
fn resize(&mut self, p: &mut Painter, width: u32, height: u32) {
self.cam.set_aspect_ratio(width as f32 / height as f32);
⋮----
self.vp_mat.update(p, self.cam.view_proj_mat());
⋮----
fn frame(&mut self, p: &mut Painter, tpf: f32) {
self.transform.rotate_y(tpf * 0.5);
self.model_mat.update(p, self.transform.model_mat());
⋮----
p.paint_and_show(self.canvas);
⋮----
p.request_next_frame();
⋮----
fn event(&mut self, _e: Event<()>, _p: &mut Painter) {}
⋮----
pub fn main() {
⋮----
.config(AppConfig {
⋮----
.start();
</file>

<file path="crates/trivalibs_painter/src/shade.rs">
use std::fs;
⋮----
pub(crate) struct ShadeStorage {
⋮----
pub struct ShadeProps<Format: Into<AttribsFormat>> {
⋮----
fn layouts_from_props(
⋮----
let mut layouts = vec![];
⋮----
layouts.push(&painter.bind_group_layouts[l.0]);
⋮----
.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
⋮----
bind_group_layouts: layouts.as_slice(),
⋮----
impl Default for ShadeProps<AttribsFormat> {
fn default() -> Self {
⋮----
attributes: vec![],
⋮----
bindings: vec![],
layers: vec![],
⋮----
pub struct ShadeEffectProps {
⋮----
impl Default for ShadeEffectProps {
⋮----
pub struct AttribsFormat {
⋮----
pub fn attrib(location: u32, format: wgpu::VertexFormat, offset: u64) -> wgpu::VertexAttribute {
⋮----
fn from(formats: &[wgpu::VertexFormat]) -> Self {
⋮----
let mut attributes = Vec::with_capacity(formats.len());
⋮----
attributes.push(attrib(location, *format, stride));
stride += format.size();
⋮----
// Generic implementation for all array sizes using const generics
⋮----
fn from(formats: [wgpu::VertexFormat; N]) -> Self {
AttribsFormat::from(formats.as_slice())
⋮----
fn from(formats: &[wgpu::VertexFormat; N]) -> Self {
⋮----
fn from(formats: Vec<wgpu::VertexFormat>) -> Self {
⋮----
fn from(format: wgpu::VertexFormat) -> Self {
⋮----
attributes: vec![attrib(0, format, 0)],
stride: format.size(),
⋮----
pub struct Shade(pub(crate) usize);
⋮----
impl Shade {
pub fn new<Format: Into<AttribsFormat>>(
⋮----
let format = props.attributes.into();
let bindings_len = props.bindings.len();
let layers_len = props.layers.len();
⋮----
layouts_from_props(painter, &props.bindings, &props.layers);
⋮----
let i = painter.shades.len();
painter.shades.push(s);
⋮----
Shade(i)
⋮----
pub fn new_effect(painter: &mut Painter, props: ShadeEffectProps) -> Self {
⋮----
let format = vec![].into();
⋮----
pub fn form_stride(&self, painter: &Painter) -> u64 {
⋮----
pub fn set_vertex_bytes(&self, painter: &mut Painter, bytes: Vec<u8>) {
painter.shades[self.0].vertex_bytes = Some(bytes);
⋮----
pub(crate) fn load_vertex_from_path(&self, painter: &mut Painter) {
⋮----
let bytes = fs::read(shader_path).expect("Failed to read vertex shader file");
self.set_vertex_bytes(painter, bytes);
⋮----
pub fn set_vertex_path(&self, painter: &mut Painter, path: &str) {
painter.shades[self.0].vertex_path = Some(path.to_string());
self.load_vertex_from_path(painter);
⋮----
pub fn set_fragment_bytes(&self, painter: &mut Painter, bytes: Vec<u8>) {
painter.shades[self.0].fragment_bytes = Some(bytes);
⋮----
pub(crate) fn load_fragment_from_path(&self, painter: &mut Painter) {
⋮----
let bytes = fs::read(shader_path).expect("Failed to read fragment shader file");
self.set_fragment_bytes(painter, bytes);
⋮----
pub fn set_fragment_path(&self, painter: &mut Painter, path: &str) {
painter.shades[self.0].fragment_path = Some(path.to_string());
self.load_fragment_from_path(painter);
⋮----
pub struct ShadeBuilder<'b, Format>
⋮----
pub fn new(painter: &'b mut Painter, attributes: Format) -> Self {
⋮----
pub fn create(self) -> Shade {
⋮----
pub fn with_bindings<I>(mut self, bindings: I) -> Self
⋮----
self.props.bindings = bindings.into_iter().collect();
⋮----
pub fn with_layers<I>(mut self, layers: I) -> Self
⋮----
self.props.layers = layers.into_iter().collect();
⋮----
pub struct ShadeEffectBuilder<'b> {
⋮----
pub fn new(painter: &'b mut Painter) -> Self {
⋮----
pub fn with_layer(mut self) -> Self {
self.props.layers = vec![BINDING_LAYER_FRAG];
⋮----
macro_rules! load_fragment_shader {
⋮----
macro_rules! load_vertex_shader {
</file>

<file path="crates/trivalibs_painter/src/bind_group.rs">
use std::collections::btree_map;
⋮----
pub(crate) struct BindGroupLayout(pub(crate) usize);
⋮----
impl BindGroupLayout {
pub(crate) fn layers(painter: &mut Painter, layouts: &[LayerLayout]) -> Option<Self> {
if layouts.is_empty() {
⋮----
.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
⋮----
.iter()
.enumerate()
.map(|(i, l)| wgpu::BindGroupLayoutEntry {
⋮----
.as_slice(),
⋮----
painter.bind_group_layouts.push(layout);
⋮----
Some(BindGroupLayout(painter.bind_group_layouts.len() - 1))
⋮----
pub(crate) fn values(painter: &mut Painter, layouts: &[BindingLayout]) -> Option<Self> {
⋮----
.map(|(i, u)| wgpu::BindGroupLayoutEntry {
⋮----
pub(crate) struct ValuesBindGroupData {
⋮----
impl ValuesBindGroupData {
pub(crate) fn from_bindings(
⋮----
if bindings_length == 0 || bind_group_layout.is_none() {
⋮----
let layout = bind_group_layout.unwrap();
⋮----
// Build base binding map from layer and shape bindings (shape overrides layer)
⋮----
for (i, u) in layer_bindings.iter() {
binding_map.insert(*i, *u);
⋮----
for (i, u) in shape_bindings.iter() {
⋮----
// Check if any instance has value bindings
let has_instance_values = shape_instances.iter().any(|inst| !inst.bindings.is_empty());
⋮----
if shape_instances.is_empty() || !has_instance_values {
// No instances or all instances have empty value bindings
// Return single bind group with base (layer+shape) bindings
let mut bindings = binding_map.iter().collect::<Vec<_>>();
bindings.sort_by(|(a, _), (b, _)| a.cmp(b));
let bindings = bindings.iter().map(|(_, b)| **b).collect::<Vec<_>>();
⋮----
Some(Self {
⋮----
data: vec![bindings],
⋮----
// At least one instance has value bindings
// Create per-instance bind groups (instance bindings override shape/layer)
let mut instances = Vec::with_capacity(shape_instances.len());
⋮----
let mut instance_map = binding_map.clone();
⋮----
for (i, u) in instance.bindings.iter() {
instance_map.insert(*i, *u);
⋮----
let mut bindings = instance_map.iter().collect::<Vec<_>>();
⋮----
instances.push(bindings);
⋮----
pub(crate) fn to_gpu_bind_groups(&self, painter: &Painter) -> Vec<wgpu::BindGroup> {
⋮----
.map(|u| {
⋮----
.map(|(i, u)| wgpu::BindGroupEntry {
⋮----
resource: value_to_resource(u, painter),
⋮----
.create_bind_group(&wgpu::BindGroupDescriptor {
⋮----
pub(crate) struct LayerBindGroupData {
⋮----
impl LayerBindGroupData {
/// Helper function to create bind group entries from an iterator of LayerBindings
	fn create_layer_entries<'a>(
⋮----
fn create_layer_entries<'a>(
⋮----
resource: layer_to_resource(u, painter),
⋮----
.collect()
⋮----
/// Helper function to create a bind group from entries
	fn create_bind_group_from_entries<'a>(
⋮----
fn create_bind_group_from_entries<'a>(
⋮----
// Check if any instance has layer bindings
let has_instance_layers = shape_instances.iter().any(|inst| !inst.layers.is_empty());
⋮----
if shape_instances.is_empty() || !has_instance_layers {
// No instances or all instances have empty layer bindings
⋮----
// At least one instance has layer bindings
⋮----
for (i, u) in instance.layers.iter() {
⋮----
.map(|bindings| {
let entries = Self::create_layer_entries(bindings.iter(), painter);
⋮----
pub(crate) fn to_gpu_bind_group(&self, painter: &Painter) -> wgpu::BindGroup {
let entries = Self::create_layer_entries(self.data.first().unwrap().iter(), painter);
⋮----
pub(crate) fn to_gpu_bind_group_with_first(
⋮----
std::iter::once(first).chain(self.data.first().unwrap().iter()),
⋮----
/// Creates multiple bind groups (one per instance), each with the first binding prepended.
	/// Used for effect rendering with instances where the source texture needs to be inserted
⋮----
/// Used for effect rendering with instances where the source texture needs to be inserted
	/// as the first binding for each instance.
⋮----
/// as the first binding for each instance.
	pub(crate) fn to_gpu_bind_groups_with_first(
⋮----
pub(crate) fn to_gpu_bind_groups_with_first(
⋮----
std::iter::once(first).chain(bindings.iter()),
⋮----
pub(crate) struct BindGroupStorage {
⋮----
fn value_to_resource<'a>(
⋮----
buffer.as_entire_binding()
⋮----
fn layer_to_resource<'a>(
⋮----
wgpu::BindingResource::TextureView(l.current_source_texture().source_view(painter))
⋮----
l.current_source_texture()
.view(painter, &TexViewKey::AtMipLevel(*mip_level)),
⋮----
l.depth_texture.unwrap().view(painter, &TexViewKey::Default),
⋮----
l.target_textures[*index].view(painter, &TexViewKey::WithAllMips),
⋮----
pub struct BindGroup(pub(crate) usize);
⋮----
impl BindGroup {
pub(crate) fn layer_gpu_bind_group(
⋮----
resource: layer_to_resource(&layer, painter),
⋮----
pub(crate) fn values_bind_groups(
⋮----
let bind_groups = data.to_gpu_bind_groups(painter);
let mut bind_group_indices = Vec::with_capacity(bind_groups.len());
⋮----
let index = painter.bind_groups.len();
painter.bind_groups.push(BindGroupStorage { bind_group });
bind_group_indices.push(BindGroup(index));
</file>

<file path="crates/trivalibs_painter/src/binding.rs">
//! # Binding System
//!
⋮----
//!
//! This module defines the binding system for shaders in the painter.
⋮----
//! This module defines the binding system for shaders in the painter.
//!
⋮----
//!
//! ## Binding Types
⋮----
//! ## Binding Types
//!
⋮----
//!
//! There are two main categories of bindings:
⋮----
//! There are two main categories of bindings:
//!
⋮----
//!
//! - **ValueBindings**: Uniforms (buffers) and samplers that can be bound to shaders
⋮----
//! - **ValueBindings**: Uniforms (buffers) and samplers that can be bound to shaders
//! - **LayerBindings**: Texture layers that can be bound as inputs to shaders
⋮----
//! - **LayerBindings**: Texture layers that can be bound as inputs to shaders
//!
⋮----
//!
//! ## Binding Override Hierarchy
⋮----
//! ## Binding Override Hierarchy
//!
⋮----
//!
//! Bindings can be set at three levels, with later levels overriding earlier ones:
⋮----
//! Bindings can be set at three levels, with later levels overriding earlier ones:
//!
⋮----
//!
//! 1. **Layer level** (lowest priority): Set via `Layer::set_layer_bindings()`
⋮----
//! 1. **Layer level** (lowest priority): Set via `Layer::set_layer_bindings()`
//! 2. **Shape/Effect level** (medium priority): Set when creating shapes/effects via `bindings` parameter
⋮----
//! 2. **Shape/Effect level** (medium priority): Set when creating shapes/effects via `bindings` parameter
//! 3. **Instance level** (highest priority): Set via `InstanceBinding` for per-instance variation
⋮----
//! 3. **Instance level** (highest priority): Set via `InstanceBinding` for per-instance variation
//!
⋮----
//!
//! ### Override Rules:
⋮----
//! ### Override Rules:
//!
⋮----
//!
//! - Shape/Effect bindings override Layer bindings at the same binding slot
⋮----
//! - Shape/Effect bindings override Layer bindings at the same binding slot
//! - Instance bindings override both Shape/Effect and Layer bindings at the same binding slot
⋮----
//! - Instance bindings override both Shape/Effect and Layer bindings at the same binding slot
//!
⋮----
//!
//! ## Instance Rendering Optimization
⋮----
//! ## Instance Rendering Optimization
//!
⋮----
//!
//! The system optimizes rendering based on which binding types vary per-instance:
⋮----
//! The system optimizes rendering based on which binding types vary per-instance:
//!
⋮----
//!
//! - **No instances**: Set all bindings once, single draw call
⋮----
//! - **No instances**: Set all bindings once, single draw call
//! - **Only value bindings vary**: Set layer bindings once, iterate through value bindings
⋮----
//! - **Only value bindings vary**: Set layer bindings once, iterate through value bindings
//! - **Only layer bindings vary**: Set value bindings once, iterate through layer bindings
⋮----
//! - **Only layer bindings vary**: Set value bindings once, iterate through layer bindings
//! - **Both vary**: Iterate through all instances, setting both binding types per draw call
⋮----
//! - **Both vary**: Iterate through all instances, setting both binding types per draw call
//!
⋮----
//!
//! This optimization is handled automatically by:
⋮----
//! This optimization is handled automatically by:
//! - `ValuesBindGroupData::from_bindings()` and `LayerBindGroupData::from_bindings()` in bind_group.rs
⋮----
//! - `ValuesBindGroupData::from_bindings()` and `LayerBindGroupData::from_bindings()` in bind_group.rs
//! - `render_shape()` and `render_effect()` in painter.rs
⋮----
//! - `render_shape()` and `render_effect()` in painter.rs
⋮----
pub struct BindingLayout {
⋮----
pub struct LayerLayout {
⋮----
pub enum ValueBinding {
⋮----
pub enum LayerBinding {
⋮----
pub struct Buffer(pub(crate) usize);
⋮----
impl Buffer {
pub fn binding(&self) -> ValueBinding {
⋮----
pub struct BindingBuffer<T> {
⋮----
pub fn new(painter: &mut Painter, data: T) -> Self {
let buffer = painter.device.create_buffer(&wgpu::BufferDescriptor {
⋮----
size: get_padded_size(std::mem::size_of::<T>() as u64),
⋮----
painter.buffers.push(buffer);
⋮----
let buffer = Buffer(painter.buffers.len() - 1);
⋮----
binding.update(&painter, data);
⋮----
pub fn update(&self, painter: &Painter, data: T) {
⋮----
.write_buffer(buffer, 0, bytemuck::cast_slice(&[data]));
⋮----
pub struct Mat3U(pub(crate) Mat3A);
⋮----
pub fn new_mat3(painter: &mut Painter, data: Mat3) -> Self {
BindingBuffer::new(painter, Mat3U(Mat3A::from(data)))
⋮----
pub fn update_mat3(&self, painter: &Painter, data: Mat3) {
self.update(painter, Mat3U(Mat3A::from(data)));
⋮----
pub struct Vec3U(pub(crate) Vec3A);
⋮----
pub fn new_vec3(painter: &mut Painter, data: Vec3) -> Self {
BindingBuffer::new(painter, Vec3U(Vec3A::from(data)))
⋮----
pub fn update_vec3(&self, painter: &Painter, data: Vec3) {
self.update(painter, Vec3U(Vec3A::from(data)));
⋮----
/// Per-instance binding overrides.
///
⋮----
///
/// Allows individual instances of shapes or effects to override the base bindings
⋮----
/// Allows individual instances of shapes or effects to override the base bindings
/// set at the layer or shape/effect level.
⋮----
/// set at the layer or shape/effect level.
///
⋮----
///
/// # Fields
⋮----
/// # Fields
///
⋮----
///
/// - `bindings`: Value bindings (buffers, samplers) to override, indexed by binding slot
⋮----
/// - `bindings`: Value bindings (buffers, samplers) to override, indexed by binding slot
/// - `layers`: Layer bindings (textures) to override, indexed by binding slot
⋮----
/// - `layers`: Layer bindings (textures) to override, indexed by binding slot
///
⋮----
///
/// # Override Behavior
⋮----
/// # Override Behavior
///
⋮----
///
/// - If `bindings` is empty for all instances, value bindings won't vary per-instance
⋮----
/// - If `bindings` is empty for all instances, value bindings won't vary per-instance
/// - If `layers` is empty for all instances, layer bindings won't vary per-instance
⋮----
/// - If `layers` is empty for all instances, layer bindings won't vary per-instance
/// - If both are populated in at least one instance, both binding types will be set per draw call
⋮----
/// - If both are populated in at least one instance, both binding types will be set per draw call
///
⋮----
///
/// # Examples
⋮----
/// # Examples
///
⋮----
///
/// ```ignore
⋮----
/// ```ignore
/// // Instance with only value binding override (uniform color per instance)
⋮----
/// // Instance with only value binding override (uniform color per instance)
/// let instance1 = InstanceBinding {
⋮----
/// let instance1 = InstanceBinding {
///     bindings: vec![(0, color_buffer.binding())],
⋮----
///     bindings: vec![(0, color_buffer.binding())],
///     layers: vec![],
⋮----
///     layers: vec![],
/// };
⋮----
/// };
///
⋮----
///
/// // Instance with only layer binding override (different texture per instance)
⋮----
/// // Instance with only layer binding override (different texture per instance)
/// let instance2 = InstanceBinding {
⋮----
/// let instance2 = InstanceBinding {
///     bindings: vec![],
⋮----
///     bindings: vec![],
///     layers: vec![(0, LayerBinding::Source(layer))],
⋮----
///     layers: vec![(0, LayerBinding::Source(layer))],
/// };
///
/// // Instance with both overrides
⋮----
/// // Instance with both overrides
/// let instance3 = InstanceBinding {
⋮----
/// let instance3 = InstanceBinding {
///     bindings: vec![(0, color_buffer.binding())],
⋮----
///     bindings: vec![(0, color_buffer.binding())],
///     layers: vec![(0, LayerBinding::Source(layer))],
/// };
/// ```
⋮----
/// ```
#[derive(Clone)]
pub struct InstanceBinding {
⋮----
impl Default for InstanceBinding {
fn default() -> Self {
</file>

<file path="examples/base_effect/main.rs">
struct App {
⋮----
fn init(p: &mut Painter) -> Self {
⋮----
.shade_effect()
.with_bindings([BINDING_BUFFER_FRAG, BINDING_BUFFER_FRAG])
.create();
load_fragment_shader!(shade, p, "./shader/main.spv");
⋮----
let u_time = p.bind_f32();
let u_size = p.bind_uvec2();
⋮----
.effect(shade)
.with_bindings(map! {
⋮----
let canvas = p.layer().with_effect(effect).create();
⋮----
fn resize(&mut self, p: &mut Painter, width: u32, height: u32) {
self.u_size.update(p, uvec2(width, height));
⋮----
fn frame(&mut self, p: &mut Painter, tpf: f32) {
p.request_next_frame();
⋮----
self.u_time.update(p, self.time);
⋮----
p.paint_and_show(self.canvas);
⋮----
fn event(&mut self, _e: Event<()>, _p: &mut Painter) {}
⋮----
pub fn main() {
⋮----
.config(AppConfig {
⋮----
..default()
⋮----
.start();
</file>

<file path="examples/dynamic_shapes/main.rs">
// Generate a simple square geometry centered at a position with a given size
fn generate_square(pos: Vec2, size: f32) -> Vec<Vec2> {
⋮----
vec![
// Triangle 1
⋮----
// Triangle 2
⋮----
// Pick a random selection of shapes from the pool
// Randomly selects a count between 0 and POOL_SIZE
fn pick_random_shapes(shape_pool: &[Shape]) -> Vec<Shape> {
let count = rand_range(0.0, POOL_SIZE as f32) as usize;
⋮----
let idx = rand_range(0.0, shape_pool.len() as f32) as usize % shape_pool.len();
selected_shapes.push(shape_pool[idx]);
⋮----
struct App {
⋮----
fn init(p: &mut Painter) -> Self {
// Create a single shade that all shapes will share
⋮----
.shade([Float32x2])
.with_bindings([BINDING_BUFFER_FRAG, BINDING_BUFFER_FRAG])
.create();
load_vertex_shader!(shade, p, "./shader/vertex.spv");
load_fragment_shader!(shade, p, "./shader/fragment.spv");
⋮----
// Create a pool of shapes, each with:
// - A form (square at random position)
// - A random color binding
⋮----
// Random position in normalized device coordinates (-1 to 1)
let pos = vec2(rand_range(-0.8, 0.8), rand_range(-0.8, 0.8));
let size = rand_range(0.1, 0.3);
⋮----
// Create form for this square
let vertices = generate_square(pos, size);
let form = p.form(&vertices).create();
⋮----
// Create color binding with random color
let color = rand_vec3();
let color_binding = p.bind_const_vec3(color);
⋮----
// Create shape
⋮----
.shape(form, shade)
.with_bindings(map! {
⋮----
shape_pool.push(shape);
⋮----
println!(
⋮----
let is_vertical = p.bind_const_u32(1);
let is_horizontal = p.bind_const_u32(0);
⋮----
// Create two intermediate layers with distinct random shapes
⋮----
.layer()
.with_bindings(vec![(1, is_vertical)])
.with_clear_color(wgpu::Color::TRANSPARENT)
.with_multisampling()
⋮----
.with_bindings(vec![(1, is_horizontal)])
⋮----
// Pick distinct sets of shapes for each layer
let shapes1 = pick_random_shapes(&shape_pool);
let shapes2 = pick_random_shapes(&shape_pool);
⋮----
layer1.set_shapes(p, shapes1.clone());
layer2.set_shapes(p, shapes2.clone());
⋮----
println!("\nLayer 1: {} shapes", shapes1.len());
println!("Layer 2: {} shapes", shapes2.len());
⋮----
// Create effect shader for rendering textures
⋮----
.shade_effect()
.with_bindings([BINDING_SAMPLER_FRAG])
.with_layer()
⋮----
load_fragment_shader!(effect_shade, p, "./shader/effect_fragment.spv");
⋮----
// Create a default sampler
let sampler = p.sampler_linear();
⋮----
// Create effect with two instances for the two layers
⋮----
.effect(effect_shade)
.with_instances(vec![
⋮----
.with_blend_state(wgpu::BlendState::ALPHA_BLENDING)
⋮----
// Create the canvas layer with the effect instances
⋮----
.with_effect(effect)
.with_bindings(vec![(0, sampler.binding())])
.with_clear_color(wgpu::Color {
⋮----
fn resize(&mut self, _p: &mut Painter, _width: u32, _height: u32) {}
⋮----
fn frame(&mut self, p: &mut Painter, tpf: f32) {
⋮----
// Every second, pick a random selection of shapes from the pool for both layers
⋮----
// Randomly select shapes from the pool for each layer
let shapes1 = pick_random_shapes(&self.shape_pool);
let shapes2 = pick_random_shapes(&self.shape_pool);
⋮----
// Update both layers with new selections
self.layer1.set_shapes(p, shapes1.clone());
self.layer2.set_shapes(p, shapes2.clone());
⋮----
// Request continuous rendering
p.request_next_frame();
⋮----
// render
p.paint(self.layer1);
p.paint(self.layer2);
p.paint_and_show(self.canvas);
⋮----
fn event(&mut self, _e: Event<()>, _p: &mut Painter) {}
⋮----
pub fn main() {
⋮----
.config(AppConfig {
⋮----
..default()
⋮----
.start();
</file>

<file path="crates/trivalibs_core/src/rendering/mesh_geometry/tests.rs">
use crate::data::Position3D;
⋮----
struct Vert {
⋮----
impl Position3D for Vert {
fn position(&self) -> Vec3 {
⋮----
fn vert(x: f32, y: f32, z: f32) -> Vert {
Vert { pos: vec3(x, y, z) }
⋮----
fn position_face_refs(geom: &MeshGeometry<Vert>, v: Vert) -> Vec<PositionFaceRef> {
geom.get_position_faces(v.position())
.map(|faces| faces.to_vec())
.unwrap_or_default()
⋮----
fn position_face_indices(geom: &MeshGeometry<Vert>, v: Vert) -> Vec<usize> {
let mut indices = position_face_refs(geom, v)
.into_iter()
.map(|r| r.face_index)
⋮----
indices.sort();
⋮----
fn position_face_vertices(geom: &MeshGeometry<Vert>, v: Vert) -> Vec<Vert> {
let mut refs = position_face_refs(geom, v)
⋮----
.map(|face_ref| {
let vertex = *geom.face(face_ref.face_index).vertex(face_ref.vertex_slot);
⋮----
refs.sort_by_key(|(face_ref, _)| (face_ref.face_index, face_ref.vertex_slot));
refs.iter().map(|(_, v)| *v).collect()
⋮----
fn generate_geometry() {
⋮----
let v1 = vert(0.0, 0.0, 0.0);
let v2 = vert(1.0, 0.0, 0.0);
let v3 = vert(0.0, 1.0, 0.0);
⋮----
geom.add_face(&[v1, v2, v3]);
⋮----
assert_eq!(geom.face_count(), 1);
assert_eq!(geom.position_count(), 3);
⋮----
let face = geom.face(0);
assert_eq!(face.vertices(), &[v1, v2, v3]);
⋮----
assert_eq!(position_face_vertices(&geom, v1), vec![v1]);
assert_eq!(position_face_vertices(&geom, v2), vec![v2]);
assert_eq!(position_face_vertices(&geom, v3), vec![v3]);
⋮----
assert!(geom.get_position_faces(vec3(9.0, 9.0, 9.0)).is_none());
⋮----
fn remove_face() {
⋮----
let center = vert(1.0, 1.0, 0.0);
let bottom_right = vert(2.0, 0.0, 0.0);
let bottom_left = vert(0.0, 0.0, 0.0);
let top_left = vert(0.0, 2.0, 0.0);
let top_right = vert(2.0, 2.0, 0.0);
⋮----
geom.add_face(&[center, bottom_right, bottom_left]);
geom.add_face(&[center, top_right, bottom_right]);
geom.add_face(&[center, top_left, top_right]);
geom.add_face(&[center, bottom_left, top_left]);
⋮----
assert_eq!(geom.face_count(), 4);
assert_eq!(geom.position_count(), 5);
assert_eq!(geom.face(1).vertices(), &[center, top_right, bottom_right]);
assert_eq!(geom.face(2).vertices(), &[center, top_left, top_right]);
assert_eq!(geom.face(3).vertices(), &[center, bottom_left, top_left]);
⋮----
assert_eq!(position_face_indices(&geom, center), vec![0, 1, 2, 3]);
assert_eq!(position_face_indices(&geom, bottom_right), vec![0, 1]);
assert_eq!(position_face_indices(&geom, bottom_left), vec![0, 3]);
assert_eq!(position_face_indices(&geom, top_right), vec![1, 2]);
assert_eq!(position_face_indices(&geom, top_left), vec![2, 3]);
⋮----
geom.remove_face(1);
⋮----
assert_eq!(geom.face_count(), 3);
⋮----
assert_eq!(geom.face(1).vertices(), &[center, bottom_left, top_left]);
⋮----
assert_eq!(position_face_indices(&geom, center), vec![0, 1, 2]);
assert_eq!(position_face_indices(&geom, bottom_right), vec![0]);
assert_eq!(position_face_indices(&geom, bottom_left), vec![0, 1]);
assert_eq!(position_face_indices(&geom, top_right), vec![2]);
assert_eq!(position_face_indices(&geom, top_left), vec![1, 2]);
⋮----
geom.remove_face(0);
⋮----
assert_eq!(geom.face_count(), 2);
⋮----
assert_eq!(geom.face(0).vertices(), &[center, top_left, top_right]);
⋮----
assert_eq!(position_face_indices(&geom, center), vec![0, 1]);
assert_eq!(position_face_indices(&geom, bottom_right), vec![]);
assert_eq!(position_face_indices(&geom, bottom_left), vec![1]);
assert_eq!(position_face_indices(&geom, top_right), vec![0]);
assert_eq!(position_face_indices(&geom, top_left), vec![0, 1]);
⋮----
assert_eq!(position_face_indices(&geom, center), vec![0]);
⋮----
assert_eq!(position_face_indices(&geom, bottom_left), vec![]);
⋮----
assert_eq!(position_face_indices(&geom, top_left), vec![0]);
⋮----
assert_eq!(geom.face_count(), 0);
⋮----
assert!(position_face_refs(&geom, center).is_empty());
assert!(position_face_refs(&geom, bottom_right).is_empty());
assert!(position_face_refs(&geom, bottom_left).is_empty());
assert!(position_face_refs(&geom, top_right).is_empty());
assert!(position_face_refs(&geom, top_left).is_empty());
⋮----
fn new_from_section_resets_sections() {
⋮----
vert(0.0, 0.0, 0.0),
vert(1.0, 0.0, 0.0),
vert(0.0, 1.0, 0.0),
⋮----
vert(0.0, 0.0, 1.0),
vert(1.0, 0.0, 1.0),
vert(0.0, 1.0, 1.0),
⋮----
geom.add_face_data(base, face_section(2));
geom.add_face_data(other, face_section(3));
⋮----
let section = geom.new_from_section(3);
⋮----
assert_eq!(section.face_count(), 1);
assert_eq!(section.position_count(), 3);
assert_eq!(section.face(0).section, DEFAULT_MESH_SECTION);
assert_eq!(section.face(0).vertex_count, 3);
⋮----
fn split_by_sections_produces_separate_meshes() {
⋮----
vert(0.0, 0.0, 2.0),
vert(1.0, 0.0, 2.0),
vert(1.0, 1.0, 2.0),
vert(0.0, 1.0, 2.0),
⋮----
geom.add_face_data(base, face_section(5));
geom.add_face_data(shifted, face_section(5));
geom.add_face_data(quad, face_section(8));
⋮----
let sections = geom.split_by_sections();
⋮----
assert_eq!(sections.len(), 2);
⋮----
let sec5 = sections.get(&5).unwrap();
assert_eq!(sec5.face_count(), 2);
assert!(
⋮----
let sec8 = sections.get(&8).unwrap();
assert_eq!(sec8.face_count(), 1);
assert_eq!(sec8.face(0).vertex_count, 4);
⋮----
fn face_calculate_normal_triangle() {
⋮----
geom.add_face([v1, v2, v3]);
⋮----
let normal = face.calculate_normal();
⋮----
// Counter-clockwise triangle should have normal pointing up (0, 0, 1)
assert!((normal - vec3(0.0, 0.0, 1.0)).length() < 0.0001);
⋮----
fn face_calculate_normal_quad() {
⋮----
let v3 = vert(1.0, 1.0, 0.0);
let v4 = vert(0.0, 1.0, 0.0);
⋮----
geom.add_face([v1, v2, v3, v4]);
⋮----
// CCW quad in XY plane should have normal pointing up (0, 0, 1)
⋮----
fn face_calculate_and_store_normal() {
⋮----
// Initially no normal stored
assert_eq!(geom.faces[0].face_normal, None);
⋮----
geom.faces[0].calculate_and_store_normal();
⋮----
// Now normal should be stored
let stored_normal = geom.faces[0].face_normal.unwrap();
assert!((stored_normal - vec3(0.0, 0.0, 1.0)).length() < 0.0001);
⋮----
fn map_scale_vertices() {
⋮----
// Scale all vertices by 2
let scaled = geom.map(|face| {
face.vertices()
.iter()
.map(|v| vert(v.pos.x * 2.0, v.pos.y * 2.0, v.pos.z * 2.0))
.collect()
⋮----
assert_eq!(scaled.face_count(), 1);
assert_eq!(scaled.position_count(), 3);
⋮----
let face = scaled.face(0);
let verts = (face).vertices();
assert_eq!(verts[0], vert(0.0, 0.0, 0.0));
assert_eq!(verts[1], vert(2.0, 0.0, 0.0));
assert_eq!(verts[2], vert(0.0, 2.0, 0.0));
⋮----
fn map_preserves_face_properties() {
⋮----
let normal = vec3(0.0, 0.0, 1.0);
geom.add_face_data([v1, v2, v3], face_props(normal, 5));
⋮----
let mapped = geom.map(|face| face.vertices().to_vec());
⋮----
assert_eq!(mapped.face_count(), 1);
let face = mapped.face(0);
assert_eq!(face.section, 5);
assert_eq!(face.face_normal, Some(normal));
⋮----
fn map_multiple_faces() {
⋮----
geom.add_face([
⋮----
vert(1.0, 1.0, 0.0),
⋮----
// Translate all faces by (10, 0, 0)
let translated = geom.map(|face| {
⋮----
.map(|v| vert(v.pos.x + 10.0, v.pos.y, v.pos.z))
⋮----
assert_eq!(translated.face_count(), 2);
assert_eq!(translated.position_count(), 4);
⋮----
// Check first face
let face0 = translated.face(0);
let verts0 = (face0).vertices();
assert_eq!(verts0[0], vert(10.0, 0.0, 0.0));
assert_eq!(verts0[1], vert(11.0, 0.0, 0.0));
assert_eq!(verts0[2], vert(10.0, 1.0, 0.0));
⋮----
fn map_data_modify_section_and_normal() {
⋮----
geom.add_face_data(&[v1, v2, v3], super::face_section(1));
⋮----
let mapped = geom.map_data(|face| {
let new_normal = vec3(1.0, 0.0, 0.0);
⋮----
face.vertices().to_vec(),
⋮----
assert_eq!(face.section, 3);
assert_eq!(face.face_normal, Some(vec3(1.0, 0.0, 0.0)));
⋮----
fn map_data_calculate_normal_on_fly() {
⋮----
// Scale vertices and recalculate normal
let scaled = geom.map_data(|face| {
⋮----
.vertices()
⋮----
.collect();
⋮----
// Create a temporary face to calculate new normal
⋮----
temp_geom.add_face(new_verts.as_slice());
let new_normal = temp_geom.face(0).calculate_normal();
⋮----
(new_verts, face_normal(new_normal))
⋮----
// Normal should still point in same direction even after scaling
assert!((face.face_normal.unwrap() - vec3(0.0, 0.0, 1.0)).length() < 0.0001);
⋮----
fn flat_map_filter_out_faces() {
⋮----
geom.add_face_data(
⋮----
vert(2.0, 0.0, 0.0),
vert(3.0, 0.0, 0.0),
vert(2.0, 1.0, 0.0),
⋮----
// Filter: keep only faces in section 1
let filtered = geom.flat_map(|face| {
⋮----
vec![face.vertices().to_vec()]
⋮----
vec![]
⋮----
assert_eq!(filtered.face_count(), 2);
assert_eq!(filtered.face(0).section, 1);
assert_eq!(filtered.face(1).section, 1);
⋮----
fn flat_map_identity_map() {
⋮----
geom.add_face(&[
⋮----
// Identity mapping: each face maps to exactly one face
let mapped = geom.flat_map(|face| vec![face.vertices().to_vec()]);
⋮----
assert_eq!(mapped.face_count(), 2);
assert_eq!((mapped.face(0)).vertices(), (geom.face(0).vertices()));
assert_eq!((mapped.face(1).vertices()), (geom.face(1).vertices()));
⋮----
fn flat_map_split_quad_into_triangles() {
⋮----
geom.add_face_data(&[v1, v2, v3, v4], super::face_section(5));
⋮----
// Split each quad into two triangles
let triangulated = geom.flat_map(|face| {
let verts = face.vertices();
if verts.len() == 4 {
vec![
⋮----
vec![verts.to_vec()]
⋮----
assert_eq!(triangulated.face_count(), 2);
assert_eq!(triangulated.face(0).vertex_count, 3);
assert_eq!(triangulated.face(1).vertex_count, 3);
// Both triangles should preserve the section
assert_eq!(triangulated.face(0).section, 5);
assert_eq!(triangulated.face(1).section, 5);
⋮----
fn flat_map_duplicate_faces() {
⋮----
// Duplicate each face 3 times
let duplicated = geom.flat_map(|face| {
⋮----
assert_eq!(duplicated.face_count(), 3);
assert_eq!(duplicated.face(0).vertices(), &[v1, v2, v3]);
assert_eq!(duplicated.face(1).vertices(), &[v1, v2, v3]);
assert_eq!(duplicated.face(2).vertices(), &[v1, v2, v3]);
⋮----
fn flat_map_data_split_with_different_sections() {
⋮----
geom.add_face(&[v1, v2, v3, v4]);
⋮----
// Split quad into two triangles with different sections
let split = geom.flat_map_data(|face| {
⋮----
vec![(verts.to_vec(), super::face_section(0))]
⋮----
assert_eq!(split.face_count(), 2);
assert_eq!(split.face(0).section, 10);
assert_eq!(split.face(1).section, 20);
⋮----
fn flat_map_data_recalculate_normals_per_split() {
⋮----
// Split and recalculate normals for each part
⋮----
// Create two triangles and calculate their normals
let tri1 = vec![verts[0], verts[1], verts[2]];
let tri2 = vec![verts[0], verts[2], verts[3]];
⋮----
temp_geom1.add_face(tri1.as_slice());
let normal1 = temp_geom1.face(0).calculate_normal();
⋮----
temp_geom2.add_face(tri2.as_slice());
let normal2 = temp_geom2.face(0).calculate_normal();
⋮----
vec![(tri1, face_normal(normal1)), (tri2, face_normal(normal2))]
⋮----
vec![(verts.to_vec(), Default::default())]
⋮----
// Both triangles should have the same normal since they're coplanar
let normal1 = split.face(0).face_normal.unwrap();
let normal2 = split.face(1).face_normal.unwrap();
assert!((normal1 - vec3(0.0, 0.0, 1.0)).length() < 0.0001);
assert!((normal2 - vec3(0.0, 0.0, 1.0)).length() < 0.0001);
⋮----
fn flat_map_data_filter_and_modify() {
⋮----
face_section(1),
⋮----
face_section(2),
⋮----
// Keep only section 1 faces and move them to section 10
let filtered = geom.flat_map_data(|face| {
⋮----
vec![(face.vertices().to_vec(), face_section(10))]
⋮----
assert_eq!(filtered.face(0).section, 10);
assert_eq!(filtered.face(1).section, 10);
</file>

<file path="crates/trivalibs_painter/src/app.rs">
use crate::layer::Layer;
⋮----
use crate::window_dimensions::WindowDimensions;
⋮----
use notify::Watcher;
⋮----
use std::collections::BTreeMap;
use std::sync::Arc;
⋮----
use wasm_bindgen_futures::spawn_local;
use web_time::Instant;
⋮----
use winit::dpi::PhysicalPosition;
⋮----
// Re-export custom event types
⋮----
pub trait CanvasApp<UserEvent> {
⋮----
fn create() -> CanvasAppStarter<UserEvent, Self>
⋮----
let _ = console_log::init(); // Ignore error if already initialized
⋮----
.build()
.unwrap();
⋮----
let event_loop_proxy = event_loop.create_proxy();
⋮----
enum WindowState<UserEvent, App: CanvasApp<UserEvent>> {
⋮----
pub enum CustomEvent<UserEvent> {
⋮----
pub struct CanvasAppRunner<UserEvent, App>
⋮----
pub fn pause(&mut self) {
⋮----
pub fn play(&mut self) {
⋮----
painter.request_next_frame();
⋮----
pub struct CanvasHandle<UserEvent>
⋮----
pub fn send_event(
⋮----
.send_event(CustomEvent::UserEvent(event))
⋮----
pub struct AppConfig {
⋮----
impl Default for AppConfig {
fn default() -> Self {
⋮----
pub struct CanvasAppStarter<UserEvent, App>
⋮----
pub fn config(mut self, config: AppConfig) -> Self {
⋮----
pub fn start(self) {
⋮----
let mut watcher = notify::recommended_watcher(tx).unwrap();
⋮----
let path = std::env::current_dir().unwrap();
⋮----
println!("Watching: {:?}", path);
⋮----
.watch(&path, notify::RecursiveMode::Recursive)
⋮----
let proxy = runner.event_loop_proxy.clone();
⋮----
// Block forever, printing out events as they come in
⋮----
if event.kind.is_modify() {
⋮----
event.paths.iter().for_each(|path| {
if let Some(ext) = path.extension() {
⋮----
if let Some(last_event_time) = current_shaders.get(path) {
⋮----
.duration_since(*last_event_time)
.unwrap()
.as_millis() < 500
⋮----
.send_event(CustomEvent::ReloadShaders(
path.display().to_string(),
⋮----
.unwrap_or_else(|_| {
panic!("Failed to send shader reload event");
⋮----
current_shaders.insert(path.clone(), current_time);
⋮----
Err(e) => println!("watch error: {:?}", e),
⋮----
let _ = event_loop.run_app(&mut runner);
⋮----
pub fn get_handle(&self) -> CanvasHandle<UserEvent> {
⋮----
event_loop_proxy: self.runner.event_loop_proxy.clone(),
⋮----
// This is a common indicator that you can create a window.
fn resumed(&mut self, event_loop: &ActiveEventLoop) {
⋮----
// Load and apply saved window state
⋮----
.with_inner_size(PhysicalSize::new(state.size.0, state.size.1));
window_attributes = window_attributes.with_position(PhysicalPosition::new(
⋮----
use winit::platform::web::WindowAttributesExtWebSys;
⋮----
// Use the provided canvas
⋮----
.create_window(window_attributes.with_canvas(Some(canvas.clone())))
⋮----
// Set canvas attributes even for provided canvas
⋮----
.set_attribute("tabindex", "0")
.expect("failed to set tabindex");
canvas.focus().expect("Unable to focus on canvas");
⋮----
// Create a new canvas as before
let window = event_loop.create_window(window_attributes).unwrap();
⋮----
use winit::platform::web::WindowExtWebSys;
⋮----
.and_then(|win| win.document())
.and_then(|doc| {
let body = doc.body()?;
let canvas = window.canvas().expect("Failed to get canvas");
⋮----
// Set canvas size to fill the window
canvas.style().set_property("width", "100%").ok();
canvas.style().set_property("height", "100%").ok();
canvas.style().set_property("display", "block").ok();
body.append_child(&canvas).ok()?;
⋮----
Some(())
⋮----
.expect("Couldn't append canvas to document body.");
⋮----
let event_loop_proxy = self.event_loop_proxy.clone();
spawn_local(async move {
⋮----
.send_event(CustomEvent::StateInitializationEvent(painter))
⋮----
panic!("Failed to send initialization event");
⋮----
fn user_event(&mut self, _event_loop: &ActiveEventLoop, event: CustomEvent<UserEvent>) {
⋮----
for i in 0..painter.layers.len() {
Layer(i).init_gpu_pipelines(&mut painter);
⋮----
let size = painter.canvas_size();
app.resize(&mut painter, size.width, size.height);
⋮----
app.event(Event::UserEvent(user_event), painter);
⋮----
let _ = path; // Use the path if needed
⋮----
painter.reload_shader(path);
app.event(Event::ShaderReloadEvent, painter);
app.frame(painter, 0.0);
⋮----
fn window_event(
⋮----
// Reconfigure the surface with the new size
painter.resize(new_size);
app.resize(painter, new_size.width, new_size.height);
// On macos the window needs to be redrawn manually after resizing
⋮----
let window = painter.window();
⋮----
window.outer_position().unwrap_or_default(),
⋮----
let _ = dim.save();
⋮----
WindowDimensions::from_window(window.inner_size(), new_position);
⋮----
let elapsed = self.now.elapsed().as_secs_f32();
⋮----
// TODO: setup logger
println!("FPS: {}", self.frame_count as f32 / self.frame_time);
⋮----
app.frame(painter, elapsed);
⋮----
painter.resize(PhysicalSize {
⋮----
app.resize(
⋮----
// The system is out of memory, we should probably quit
⋮----
event_loop.exit();
⋮----
// This happens when the a frame takes too long to present
⋮----
WindowEvent::CloseRequested => event_loop.exit(),
⋮----
self.last_cursor = Some((x, y));
⋮----
app.event(
⋮----
let (x, y) = self.last_cursor.unwrap_or((0.0, 0.0));
⋮----
app.event(Event::PointerDown { button, x, y }, painter);
⋮----
app.event(Event::PointerUp { button, x, y }, painter);
⋮----
// Handle exit with Escape on native
⋮----
if matches!(key, KeyCode::Escape) {
⋮----
app.event(Event::KeyUp { key }, painter);
⋮----
// Handle internal pause/play with Space after event processing
if matches!(key, KeyCode::Space) {
⋮----
app.event(Event::KeyDown { key }, painter);
⋮----
// Ignore other window events (focus, hover, etc.)
⋮----
fn device_event(
⋮----
// Raw mouse motion - typically from mouse lock / FPS mode
⋮----
// Ignore other device events for now
</file>

<file path="examples/instances/main.rs">
const VERTICES: &[Vec3] = &[vec3(0.0, 5.0, 0.0), vec3(-2.5, 0., 0.0), vec3(2.5, 0., 0.0)];
⋮----
struct Triangle {
⋮----
struct App {
⋮----
fn init(p: &mut Painter) -> Self {
⋮----
let scale = rand_vec3_range(1., 2.0);
let mut t = Transform::from_translation(rand_vec3_range(-30.0, 30.0)).with_scale(scale);
t.look_at(rand_vec3_range(-30.0, 30.0), Vec3::Y);
triangles.push(Triangle {
⋮----
speed: rand_range(0.1, 1.0) * rand_sign(),
⋮----
triangles.sort_by(|a, b| {
⋮----
.partial_cmp(&b.transform.translation.z)
.unwrap()
⋮----
.shade([Float32x3])
.with_bindings([
⋮----
.create();
load_vertex_shader!(shade, p, "./shader/vertex.spv");
load_fragment_shader!(shade, p, "./shader/fragment.spv");
⋮----
let form = p.form(VERTICES).create();
⋮----
let model_mats = (0..triangles.len())
.map(|_| p.bind_mat4())
⋮----
let cam = p.bind_mat4();
⋮----
.iter()
.map(|model| InstanceBinding {
bindings: map! {
⋮----
..default()
⋮----
.collect();
⋮----
.shape(form, shade)
.with_bindings(map! {
⋮----
.with_instances(instances)
.with_cull_mode(None)
.with_blend_state(wgpu::BlendState::ALPHA_BLENDING)
⋮----
.layer()
.with_shape(shape)
.with_clear_color(wgpu::Color::BLACK)
.with_multisampling()
⋮----
fov: Some(0.6),
translation: Some(vec3(0.0, 0.0, 80.0)),
⋮----
fn resize(&mut self, p: &mut Painter, width: u32, height: u32) {
self.cam.set_aspect_ratio(width as f32 / height as f32);
⋮----
self.vp_mat.update(p, self.cam.view_proj_mat());
⋮----
fn frame(&mut self, p: &mut Painter, tpf: f32) {
p.request_next_frame();
⋮----
for (tri, model) in self.triangles.iter_mut().zip(self.model_mats.iter_mut()) {
tri.transform.rotate_y(tpf * tri.speed);
⋮----
model.update(p, tri.transform.model_mat());
⋮----
p.paint_and_show(self.canvas);
⋮----
fn event(&mut self, _e: Event<()>, _p: &mut Painter) {}
⋮----
pub fn main() {
⋮----
.config(AppConfig {
⋮----
.start();
</file>

<file path="examples/noise_tests/main.rs">
struct App {
⋮----
fn init(p: &mut Painter) -> Self {
let u_size = p.bind_uvec2();
let u_time = p.bind_f32();
⋮----
.shade_effect()
.with_bindings([BINDING_BUFFER_FRAG, BINDING_BUFFER_FRAG])
.create();
⋮----
let e = p.effect(s).create();
⋮----
.layer()
.with_effect(e)
.with_bindings(map! {
⋮----
let (s, simplex_2d_test) = shade_canvas(p);
load_fragment_shader!(s, p, "./shader/simplex_2d_shader.spv");
⋮----
let (s, simplex_3d_test) = shade_canvas(p);
load_fragment_shader!(s, p, "./shader/simplex_3d_shader.spv");
⋮----
let (s, simplex_4d_test) = shade_canvas(p);
load_fragment_shader!(s, p, "./shader/simplex_4d_shader.spv");
⋮----
let (s, tiling_simplex_test) = shade_canvas(p);
load_fragment_shader!(s, p, "./shader/tiling_simplex_shader.spv");
⋮----
let (s, tiling_noise_2d_test) = shade_canvas(p);
load_fragment_shader!(s, p, "./shader/tiling_noise_2d_shader.spv");
⋮----
let (s, tiling_noise_3d_test) = shade_canvas(p);
load_fragment_shader!(s, p, "./shader/tiling_noise_3d_shader.spv");
⋮----
let (s, hash_test) = shade_canvas(p);
load_fragment_shader!(s, p, "./shader/hash_shader.spv");
⋮----
// return App
⋮----
layers: vec![
⋮----
fn resize(&mut self, p: &mut Painter, width: u32, height: u32) {
self.u_size.update(p, uvec2(width, height));
⋮----
fn frame(&mut self, p: &mut Painter, tpf: f32) {
⋮----
self.u_time.update(p, self.time);
⋮----
p.paint_and_show(layer);
⋮----
p.request_next_frame();
⋮----
fn event(&mut self, e: Event<()>, _p: &mut Painter) {
⋮----
self.current_layer = (self.current_layer + 1) % self.layers.len();
⋮----
(self.current_layer + self.layers.len() - 1) % self.layers.len();
⋮----
pub fn main() {
⋮----
.config(AppConfig {
⋮----
..default()
⋮----
.start();
</file>

<file path="crates/trivalibs_core/src/rendering/mesh_geometry/mod.rs">
use bytemuck::Zeroable;
use glam::Vec3;
use rustc_hash::FxHashMap;
use std::collections::BTreeMap;
⋮----
pub mod utils;
⋮----
struct FaceVertex<V> {
⋮----
pub struct Face<V> {
⋮----
fn new(face_vertices: Vec<FaceVertex<V>>, face_normal: Option<Vec3>, section: usize) -> Self {
debug_assert!(face_vertices.len() == 3 || face_vertices.len() == 4);
let vertex_count = face_vertices.len() as u8;
⋮----
for (i, fv) in face_vertices.into_iter().enumerate() {
⋮----
pub fn vertices(&self) -> &[V] {
⋮----
pub fn vertex(&self, idx: usize) -> &V {
debug_assert!(idx < self.vertex_count as usize);
⋮----
fn position_indices(&self) -> &[usize] {
⋮----
/// Calculate the face normal from vertex positions without modifying the stored normal.
	pub fn calculate_normal(&self) -> Vec3 {
⋮----
pub fn calculate_normal(&self) -> Vec3 {
let verts = self.vertices();
let pos0 = verts[0].position();
let pos1 = verts[1].position();
let pos2 = verts[2].position();
⋮----
let v1_len = v1.length();
let v2_len = v2.length();
⋮----
let v3_len_0 = (v2 / v2_len).dot(v1 / v1_len).abs() > 0.9999;
⋮----
if (v1_len_0 || v2_len_0 || v3_len_0) && verts.len() > 3 {
⋮----
v2 = pos1 - verts[3].position();
⋮----
v1 = verts[3].position() - pos0;
⋮----
v2.cross(v1).normalize()
⋮----
/// Calculate and store the face normal in the face_normal field.
	pub fn calculate_and_store_normal(&mut self) {
⋮----
pub fn calculate_and_store_normal(&mut self) {
self.face_normal = Some(self.calculate_normal());
⋮----
pub struct PositionFaceRef {
⋮----
pub struct VertexPosition {
⋮----
pub struct FaceProps {
⋮----
pub fn face_normal(normal: Vec3) -> FaceProps {
⋮----
normal: Some(normal),
..default()
⋮----
pub fn face_section(section: usize) -> FaceProps {
⋮----
section: Some(section),
⋮----
pub fn face_props(normal: Vec3, section: usize) -> FaceProps {
⋮----
pub struct MeshGeometry<V>
⋮----
pub trait FaceVertexCollection<V> {
⋮----
type IntoIter = std::vec::IntoIter<V>;
⋮----
fn into_face_vertices(self) -> Self::IntoIter {
self.into_iter()
⋮----
type IntoIter = std::array::IntoIter<V, N>;
⋮----
type IntoIter = std::iter::Cloned<std::slice::Iter<'a, V>>;
⋮----
self.iter().cloned()
⋮----
self.as_slice().iter().cloned()
⋮----
pub fn from_faces<Faces, FaceVertices>(faces: Faces) -> Self
⋮----
geom.add_faces(faces);
⋮----
pub fn from_faces_data<Faces, FaceVertices>(faces: Faces) -> Self
⋮----
geom.add_faces_data(faces);
⋮----
pub fn from_face<Vertices>(vertices: Vertices) -> Self
⋮----
geom.add_face(vertices);
⋮----
pub fn from_face_data<Vertices>(vertices: Vertices, props: FaceProps) -> Self
⋮----
geom.add_face_data(vertices, props);
⋮----
pub fn new() -> Self {
⋮----
pub fn position_count(&self) -> usize {
self.positions.len()
⋮----
pub fn face_count(&self) -> usize {
self.faces.len()
⋮----
fn get_position_index(&mut self, pos: Vec3) -> usize {
if let Some(idx) = self.position_indices.get(&pos.into()) {
⋮----
let idx = self.positions.len();
self.positions.push(VertexPosition {
⋮----
self.position_indices.insert(pos.into(), idx);
⋮----
fn register_face_refs(&mut self, face_idx: usize) {
⋮----
for (slot, &pos_idx) in face.position_indices().iter().enumerate() {
self.positions[pos_idx].faces.push(PositionFaceRef {
⋮----
fn unregister_face_refs(&mut self, face_idx: usize, face: &Face<V>) {
for &pos_idx in face.position_indices() {
⋮----
.retain(|f| f.face_index != face_idx);
⋮----
fn rewrite_face_refs(&mut self, from: usize, to: usize) {
⋮----
.iter_mut()
.find(|r| r.face_index == from)
⋮----
fn first_vertex_data_at(&self, vertex_idx: usize) -> &V {
⋮----
.first()
.expect("vertex must be part of at least one face to compact");
⋮----
pub fn add_face_data<Vertices>(&mut self, vertices: Vertices, props: FaceProps)
⋮----
for vertex in vertices.into_face_vertices() {
face_vertices.push(FaceVertex {
position_index: self.get_position_index(vertex.position()),
⋮----
if face_vertices.len() < 3 || face_vertices.len() > 4 {
⋮----
let section_idx = props.section.unwrap_or(DEFAULT_MESH_SECTION);
⋮----
let face_idx = self.faces.len();
self.faces.push(face);
self.register_face_refs(face_idx);
⋮----
pub fn add_face<Vertices>(&mut self, vertices: Vertices)
⋮----
self.add_face_data(vertices, default())
⋮----
pub fn add_faces_data<Faces, FaceVertices>(&mut self, faces: Faces)
⋮----
self.add_face_data(vertices, props);
⋮----
pub fn add_faces<Faces, FaceVertices>(&mut self, faces: Faces)
⋮----
self.add_face(vertices);
⋮----
pub fn new_from_section(&self, section_idx: usize) -> Self {
⋮----
for face in self.faces.iter().filter(|face| face.section == section_idx) {
⋮----
section: Some(DEFAULT_MESH_SECTION),
⋮----
geom.add_face_data(face.vertices(), props);
⋮----
pub fn split_by_sections(&self) -> BTreeMap<usize, MeshGeometry<V>> {
⋮----
let entry = result.entry(face.section).or_insert_with(MeshGeometry::new);
⋮----
entry.add_face_data(face.vertices(), props);
⋮----
/// Map each face to new vertices, preserving face properties (normal, section).
	/// The mapper function receives a reference to each face and should return new vertices (3 or 4).
⋮----
/// The mapper function receives a reference to each face and should return new vertices (3 or 4).
	pub fn map<F>(&self, mut f: F) -> Self
⋮----
pub fn map<F>(&self, mut f: F) -> Self
⋮----
let vertices = f(face);
geom.add_face_data(
⋮----
section: Some(face.section),
⋮----
/// Map each face to new vertices and properties.
	/// The mapper function receives a reference to each face and should return new vertices and FaceProps.
⋮----
/// The mapper function receives a reference to each face and should return new vertices and FaceProps.
	pub fn map_data<F>(&self, mut f: F) -> Self
⋮----
pub fn map_data<F>(&self, mut f: F) -> Self
⋮----
let (new_vertices, props) = f(face);
geom.add_face_data(new_vertices, props);
⋮----
/// Map each face to zero or more new faces, preserving face properties for all output faces.
	/// The mapper function receives a reference to each face and should return a Vec of vertex arrays.
⋮----
/// The mapper function receives a reference to each face and should return a Vec of vertex arrays.
	/// Return an empty Vec to filter out the face, a single-element Vec to map, or multiple elements to split.
⋮----
/// Return an empty Vec to filter out the face, a single-element Vec to map, or multiple elements to split.
	pub fn flat_map<F>(&self, mut f: F) -> Self
⋮----
pub fn flat_map<F>(&self, mut f: F) -> Self
⋮----
let new_faces = f(face);
⋮----
/// Map each face to zero or more new faces with full control over vertices and properties.
	/// The mapper function receives a reference to each face and should return a Vec of (vertices, FaceProps) tuples.
⋮----
/// The mapper function receives a reference to each face and should return a Vec of (vertices, FaceProps) tuples.
	/// Return an empty Vec to filter out the face, a single-element Vec to map, or multiple elements to split.
⋮----
/// Return an empty Vec to filter out the face, a single-element Vec to map, or multiple elements to split.
	pub fn flat_map_data<F>(&self, mut f: F) -> Self
⋮----
pub fn flat_map_data<F>(&self, mut f: F) -> Self
⋮----
pub fn get_position_faces(&self, pos: Vec3) -> Option<&[PositionFaceRef]> {
⋮----
.get(&pos.into())
.map(|i| self.positions[*i].faces.as_slice())
⋮----
pub fn face(&self, index: usize) -> &Face<V> {
⋮----
pub fn remove_face(&mut self, face_idx: usize) {
if face_idx >= self.faces.len() {
⋮----
let last_idx = self.faces.len() - 1;
let removed_face = self.faces.swap_remove(face_idx);
self.unregister_face_refs(face_idx, &removed_face);
⋮----
self.rewrite_face_refs(last_idx, face_idx);
⋮----
fn calculate_vertex_normal(&self, vertex_idx: usize, section_filter: Option<usize>) -> Vec3 {
⋮----
for face_ref in vert.faces.iter() {
⋮----
if section_filter.map_or(true, |section| face.section == section) {
⋮----
normal.normalize_or_zero()
⋮----
fn ensure_face_normals(&mut self) -> bool {
⋮----
for face_idx in 0..self.faces.len() {
⋮----
if face.face_normal.is_none() {
face.calculate_and_store_normal();
⋮----
fn has_quads(&self) -> bool {
self.faces.iter().any(|face| face.vertex_count > 3)
⋮----
pub enum MeshBufferType {
/// Emit per-face vertex data without normals; triangles/quads unrolled in order added.
	/// Assumes provided vertex data might differ even for shared positions.
⋮----
/// Assumes provided vertex data might differ even for shared positions.
	FaceVertices,
/// Emit per-face vertex data with interpolated vertex normals for smooth shading.
	/// Assumes provided vertex data might differ even for shared positions.
⋮----
/// Assumes provided vertex data might differ even for shared positions.
	FaceVerticesWithVertexNormal,
/// Emit per-face vertex data with the same normal duplicated per face for flat shading.
	/// Vertex data might differ for shared positions because normals might be different.
⋮----
/// Vertex data might differ for shared positions because normals might be different.
	FaceVerticesWithFaceNormal,
/// Emit deduped vertex data (no normals) plus an index buffer. Most compact buffer storage.
	/// Assumes provided vertex data is the same for shared positions.
⋮----
/// Assumes provided vertex data is the same for shared positions.
	CompactVertices,
/// Same as `CompactVertices` but appends a vertex normal alongside each deduped vertex.
	/// Assumes provided vertex data is the same for shared positions.
⋮----
/// Assumes provided vertex data is the same for shared positions.
	CompactVerticesWithNormal,
⋮----
impl MeshBufferType {
fn includes_normals(&self) -> bool {
matches!(
⋮----
pub fn to_buffered_geometry_by_type(&mut self, geom_type: MeshBufferType) -> BufferedGeometry {
let mut buffer = vec![];
let mut indices = vec![];
⋮----
let has_quads = self.has_quads();
for face in self.faces.iter() {
⋮----
for vertex_data in face.vertices() {
buffer.extend(bytemuck::bytes_of(vertex_data));
⋮----
.map(|i| i + index_offset)
⋮----
fill_face_index_buffer(&mut indices, &face_indices);
⋮----
let has_quads = self.ensure_face_normals();
⋮----
face.vertices().iter().zip(face.position_indices())
⋮----
let normal = self.calculate_vertex_normal(pos_idx, Some(face.section));
⋮----
buffer.extend(bytemuck::bytes_of(&normal));
⋮----
let normal = face.face_normal.unwrap();
⋮----
for vertex_idx in 0..self.positions.len() {
let data = self.first_vertex_data_at(vertex_idx);
buffer.extend(bytemuck::bytes_of(data));
⋮----
fill_face_index_buffer(&mut indices, face.position_indices());
⋮----
self.ensure_face_normals();
⋮----
let normal = self.calculate_vertex_normal(vertex_idx, None);
⋮----
let indices_len = indices.len();
⋮----
Some(indices)
⋮----
fn fill_face_index_buffer(index_buffer: &mut Vec<u8>, indices: &[usize]) {
index_buffer.extend(bytemuck::cast_slice(&[
⋮----
if indices.len() == 4 {
⋮----
pub fn to_webgl_buffered_geometry_by_type(
⋮----
if geom_type.includes_normals() {
layout.push(VertexType {
⋮----
let buffer = self.to_buffered_geometry_by_type(geom_type);
⋮----
let geom_layout = create_buffered_geometry_layout(layout);
⋮----
vertex_count: if buffer.index_buffer.is_some() {
⋮----
impl Position3D for VertexPosition {
fn position(&self) -> Vec3 {
⋮----
mod tests;
</file>

<file path="crates/trivalibs_painter/src/effect.rs">
pub struct EffectProps {
⋮----
impl Default for EffectProps {
fn default() -> Self {
⋮----
pub(crate) struct EffectStorage {
⋮----
pub struct Effect(pub(crate) usize);
⋮----
impl Effect {
pub fn new(painter: &mut Painter, shade: Shade, props: EffectProps) -> Self {
let pipeline_key = vec![
⋮----
.into_iter()
.flatten()
.collect();
⋮----
painter.effects.push(effect);
⋮----
Self(painter.effects.len() - 1)
⋮----
pub fn has_mip_target(&self, painter: &Painter) -> bool {
⋮----
e.dst_mip_level.is_some()
⋮----
pub fn has_mip_source(&self, painter: &Painter) -> bool {
⋮----
e.src_mip_level.is_some()
⋮----
pub struct EffectBuilder<'a> {
⋮----
pub fn new(painter: &'a mut Painter, shade: Shade) -> Self {
⋮----
pub fn create(self) -> Effect {
⋮----
pub fn with_bindings<I>(mut self, bindings: I) -> Self
⋮----
self.props.bindings = bindings.into_iter().collect();
⋮----
pub fn with_layers<I>(mut self, layers: I) -> Self
⋮----
self.props.layers = layers.into_iter().collect();
⋮----
/// Repeatedly render this effect multiple times with different bindings into the same target without target swapping.
	/// This is useful for example for deferred lighting, where each light is rendered with custom blend state on top of the last.
⋮----
/// This is useful for example for deferred lighting, where each light is rendered with custom blend state on top of the last.
	pub fn with_instances(mut self, instances: Vec<InstanceBinding>) -> Self {
⋮----
pub fn with_instances(mut self, instances: Vec<InstanceBinding>) -> Self {
⋮----
pub fn with_blend_state(mut self, blend_state: wgpu::BlendState) -> Self {
⋮----
pub fn with_mip_target(mut self, dst_mip_level: u32) -> Self {
self.props.dst_mip_level = Some(dst_mip_level);
⋮----
pub fn with_mip_source(mut self, src_mip_level: u32) -> Self {
self.props.src_mip_level = Some(src_mip_level);
</file>

<file path="examples/blur/main.rs">
struct Vertex {
⋮----
pos: vec2(-0.7, -0.7),
uv: vec2(0.0, 1.0),
⋮----
pos: vec2(0.7, -0.7),
uv: vec2(1.0, 1.0),
⋮----
pos: vec2(0.0, 0.7),
uv: vec2(0.5, 0.0),
⋮----
struct App {
⋮----
fn init(p: &mut Painter) -> Self {
let triangle_shade = p.shade([Float32x2, Float32x2]).create();
load_vertex_shader!(triangle_shade, p, "./shader/triangle_vs.spv");
load_fragment_shader!(triangle_shade, p, "./shader/triangle_fs.spv");
⋮----
.shade_effect()
.with_bindings([
⋮----
.with_layer()
.create();
load_fragment_shader!(blur_shade, p, "./shader/blur_fs.spv");
⋮----
let tri_form = p.form(TRIANGLE).create();
⋮----
let tri_shape = p.shape(tri_form, triangle_shade).create();
⋮----
let size = p.bind_vec2();
let horiz = p.bind_const_vec2(vec2(1.0, 0.0));
let vertical = p.bind_const_vec2(vec2(0.0, 1.0));
let s = p.sampler_linear().binding();
⋮----
let mut effects = vec![];
⋮----
// ===  This does blur in multiple passes ===
// It cuts the number of texture reads logarithmically, but increases the number of passes
⋮----
let mut counter = BLUR_DIAMETER / 9.0; // Fixed diameter in shader is 9.0
⋮----
let diameter = p.bind_const_f32(counter);
effects.push(
p.effect(blur_shade)
.with_bindings(map! {
⋮----
.create(),
⋮----
// println!("effects: {:?}", effects.len());
⋮----
// === This does all blurs in one pass ===
⋮----
// let diameter = p.binding_const_f32(BLUR_DIAMETER);
// effects.push(
// 	p.effect(blur_shade)
// 		.with_bindings(map! {
// 			0 => diameter,
// 			1 => size.binding(),
// 			2 => horiz,
// 			3 => s
// 		})
// 		.create(),
// );
⋮----
// 			2 => vertical,
⋮----
.layer()
.with_shape(tri_shape)
.with_effects(effects)
.with_clear_color(wgpu::Color::BLUE)
⋮----
fn resize(&mut self, p: &mut Painter, width: u32, height: u32) {
self.size.update(p, vec2(width as f32, height as f32));
⋮----
fn frame(&mut self, p: &mut Painter, _tpf: f32) {
p.request_next_frame();
p.paint_and_show(self.canvas)
⋮----
fn event(&mut self, _e: Event<()>, _p: &mut Painter) {}
⋮----
pub fn main() {
⋮----
.config(AppConfig {
⋮----
..default()
⋮----
.start();
</file>

<file path="examples/deferred_light/main.rs">
mod geom;
⋮----
struct App {
⋮----
fn init(p: &mut Painter) -> Self {
⋮----
.shade([Float32x3, Float32x3, Float32x3])
.with_bindings([
⋮----
.create();
load_vertex_shader!(scene_shade, p, "./shader/scene_vs.spv");
load_fragment_shader!(scene_shade, p, "./shader/scene_fs.spv");
⋮----
let ball_form = p.form(&create_ball_geom()).create();
⋮----
let u_vp_mat = p.bind_mat4();
⋮----
let u_ball_model_mat = p.bind_mat4();
let u_ball_rot = p.bind_quat();
⋮----
.shape(ball_form, scene_shade)
.with_bindings(map! {
⋮----
let box_form = p.form(&create_box_geom()).create();
⋮----
let u_box_model_mat = p.bind_mat4();
let u_box_rot = p.bind_quat();
⋮----
.shape(box_form, scene_shade)
⋮----
.layer()
.with_clear_color(wgpu::Color {
⋮----
.with_shapes([ball_shape, box_shape])
.with_formats([Rgba8UnormSrgb, Rgba16Float, Rgba16Float])
⋮----
.with_multisampling()
.with_depth_test()
⋮----
.shade_effect()
⋮----
.with_layers([BINDING_LAYER_FRAG, BINDING_LAYER_FRAG, BINDING_LAYER_FRAG])
⋮----
load_fragment_shader!(canvas_shade, p, "./shader/light_fs.spv");
⋮----
let color_target = scene_layer.binding_at(0);
let normal_target = scene_layer.binding_at(1);
let position_target = scene_layer.binding_at(2);
⋮----
.map(|_| {
let light_pos = rand_vec3_unit() * rand_range(10.0, 30.0);
let light_pos_u = p.bind_const_vec3(light_pos);
⋮----
let light_color_u = p.bind_const_vec3(rand_vec3());
⋮----
bindings: map! {
⋮----
..default()
⋮----
.collect();
⋮----
let cam_pos = vec3(0.0, 5.0, 0.0);
let cam_pos_u = p.bind_const_vec3(cam_pos);
⋮----
let s = p.sampler_nearest().binding();
⋮----
.effect(canvas_shade)
⋮----
.with_layers(map! {
⋮----
.with_instances(lights)
.with_blend_state(wgpu::BlendState {
⋮----
.with_effect(canvas_effect)
⋮----
fov: Some(0.65),
translation: Some(cam_pos),
rot_vertical: Some(-0.26),
⋮----
ball_transform: Transform::from_translation(vec3(5.0, 0.0, -20.0))
.with_scale(Vec3::ONE * 5.0),
box_transform: Transform::from_translation(vec3(-5.0, 0.0, -20.0))
.with_scale(Vec3::ONE * 7.5),
⋮----
fn resize(&mut self, p: &mut Painter, width: u32, height: u32) {
self.cam.set_aspect_ratio(width as f32 / height as f32);
self.u_vp_mat.update(p, self.cam.view_proj_mat());
⋮----
fn frame(&mut self, p: &mut Painter, tpf: f32) {
self.ball_transform.rotate_y(tpf * 0.25);
self.box_transform.rotate_y(tpf * 0.25);
self.box_transform.rotate_x(tpf * 0.3);
⋮----
.update(p, self.ball_transform.model_mat());
self.u_ball_rot.update(p, self.ball_transform.rotation);
⋮----
.update(p, self.box_transform.model_mat());
self.u_box_rot.update(p, self.box_transform.rotation);
⋮----
p.request_next_frame();
⋮----
// render
p.paint(self.scene_layer);
p.paint(self.canvas);
p.show(self.canvas)
⋮----
fn event(&mut self, _e: Event<()>, _p: &mut Painter) {}
⋮----
pub fn main() {
⋮----
.config(AppConfig {
⋮----
.start();
</file>

<file path="examples/layer_tex/main.rs">
struct Vertex {
⋮----
pos: vec3(-1.0, -1.0, 0.0),
uv: vec2(0.0, 1.0),
⋮----
pos: vec3(1.0, -1.0, 0.0),
uv: vec2(1.0, 1.0),
⋮----
pos: vec3(0.0, 1.0, 0.0),
uv: vec2(0.5, 0.0),
⋮----
pos: vec3(-1.0, 1.0, 0.0),
uv: vec2(0.0, 0.0),
⋮----
pos: vec3(1.0, 1.0, 0.0),
uv: vec2(1.0, 0.0),
⋮----
struct App {
⋮----
struct ResizeEvent;
⋮----
fn init(p: &mut Painter) -> Self {
⋮----
.shade([Float32x3, Float32x2])
.with_bindings([BINDING_BUFFER_VERT, BINDING_BUFFER_FRAG])
.create();
load_vertex_shader!(color_shade, p, "./shader/color_vs.spv");
load_fragment_shader!(color_shade, p, "./shader/color_fs.spv");
⋮----
.with_bindings([BINDING_BUFFER_VERT, BINDING_SAMPLER_FRAG])
.with_layers([BINDING_LAYER_FRAG])
⋮----
load_vertex_shader!(tex_shade, p, "./shader/texture_vs.spv");
load_fragment_shader!(tex_shade, p, "./shader/texture_fs.spv");
⋮----
let quad_form = p.form(QUAD).create();
let triangle_form = p.form(TRIANGLE).create();
⋮----
let color_quad_mvp = p.bind_mat4();
let color_triangle_mvp = p.bind_mat4();
⋮----
let quad_color = p.bind_const_vec3(vec3(0.0, 0.0, 1.0));
let triangle_color = p.bind_const_vec3(vec3(1.0, 0.0, 0.0));
⋮----
.shape(quad_form, color_shade)
.with_bindings(map! {
⋮----
.with_cull_mode(None)
⋮----
.shape(triangle_form, color_shade)
⋮----
.layer()
.with_shape(color_triangle_shape)
.with_size(COLOR_TEX_SIZE_BIG.0, COLOR_TEX_SIZE_BIG.1)
.with_clear_color(YELLOW)
⋮----
let sl = p.sampler_linear();
let sn = p.sampler_nearest();
⋮----
.with_shape(color_quad_shape)
⋮----
.with_clear_color(GREEN)
.with_multisampling()
⋮----
let tex_triangle_mvp = p.bind_mat4();
let tex_quad_mvp = p.bind_mat4();
⋮----
.shape(quad_form, tex_shade)
⋮----
.with_layers(map! {
⋮----
.shape(triangle_form, tex_shade)
⋮----
.with_shapes([tex_quad_shape, tex_triangle_shape])
.with_clear_color(wgpu::Color::BLACK)
.with_depth_test()
⋮----
fov: Some(0.6),
translation: vec3(0.0, 0.0, 5.0).into(),
..default()
⋮----
fn resize(&mut self, _p: &mut Painter, width: u32, height: u32) {
self.tex_cam.set_aspect_ratio(width as f32 / height as f32);
⋮----
fn frame(&mut self, p: &mut Painter, tpf: f32) {
self.triangle_transform.rotate_y(0.25 * tpf);
self.quad_transform.rotate_y(0.3 * tpf);
⋮----
self.color_triangle_mvp.update(
⋮----
self.triangle_transform.model_view_proj_mat(&self.color_cam),
⋮----
self.tex_triangle_mvp.update(
⋮----
self.triangle_transform.model_view_proj_mat(&self.tex_cam),
⋮----
.update(p, self.quad_transform.model_view_proj_mat(&self.color_cam));
⋮----
.update(p, self.quad_transform.model_view_proj_mat(&self.tex_cam));
⋮----
p.paint(self.color_triangle_layer);
p.paint(self.color_quad_layer);
p.paint(self.canvas);
p.show(self.canvas);
⋮----
p.request_next_frame();
⋮----
fn event(&mut self, e: Event<ResizeEvent>, p: &mut Painter) {
⋮----
self.color_triangle_layer.resize(p, size.0, size.1);
self.color_quad_layer.resize(p, size.0, size.1);
⋮----
self.color_triangle_layer.set_clear_color(p, Some(GREEN));
self.color_quad_layer.set_clear_color(p, Some(YELLOW));
⋮----
self.color_triangle_layer.set_clear_color(p, Some(YELLOW));
self.color_quad_layer.set_clear_color(p, Some(GREEN));
⋮----
pub fn main() {
let app = App::create().config(AppConfig {
⋮----
let handle = app.get_handle();
⋮----
let _ = handle.send_event(ResizeEvent);
⋮----
app.start();
</file>

<file path="examples/mipmap/main.rs">
struct App {
⋮----
fn init(p: &mut Painter) -> Self {
⋮----
.shade_effect()
.with_bindings([BINDING_BUFFER_FRAG, BINDING_BUFFER_FRAG])
.create();
load_fragment_shader!(image_shade, p, "./shader/image.spv");
⋮----
let u_time = p.bind_f32();
let u_size = p.bind_uvec2();
let u_mip_levels = p.bind_f32();
⋮----
.effect(image_shade)
.with_bindings(map! {
⋮----
let image = p.layer().with_effect(image_effect).with_mips().create();
⋮----
.with_bindings([
⋮----
.with_layer()
⋮----
load_fragment_shader!(sample_shade, p, "./shader/mip_sampling.spv");
⋮----
.sampler()
.with_filters(wgpu::FilterMode::Linear)
.with_mipmap_filter(wgpu::FilterMode::Linear)
⋮----
.effect(sample_shade)
⋮----
.with_layers(map! { 1 => image.binding() })
⋮----
.with_bindings([BINDING_BUFFER_FRAG, BINDING_SAMPLER_FRAG])
⋮----
load_fragment_shader!(effect_shade, p, "./shader/wave_effect.spv");
⋮----
.effect(effect_shade)
⋮----
let canvas = p.layer().with_effects([sample_effect, effect]).create();
⋮----
fn resize(&mut self, p: &mut Painter, width: u32, height: u32) {
self.u_size.update(p, uvec2(width, height));
⋮----
let mips = self.image.get_mip_levels_count(p);
println!("mip levels: {}", mips);
self.u_mip_levels.update(p, mips as f32);
⋮----
let canvas_mips = self.canvas.get_mip_levels_count(p);
println!("canvas mip levels: {}", canvas_mips);
⋮----
fn frame(&mut self, p: &mut Painter, tpf: f32) {
⋮----
self.u_time.update(p, self.time);
⋮----
p.paint(self.image);
p.paint_and_show(self.canvas);
⋮----
p.request_next_frame();
⋮----
fn event(&mut self, _e: Event<()>, _p: &mut Painter) {}
⋮----
pub fn main() {
⋮----
.config(AppConfig {
⋮----
..default()
⋮----
.start();
</file>

<file path="examples/render_to_mip/main.rs">
use trivalibs_nostd::color::hsv2rgb;
⋮----
struct App {
⋮----
fn init(p: &mut Painter) -> Self {
⋮----
.shade_effect()
.with_bindings([BINDING_BUFFER_FRAG, BINDING_SAMPLER_FRAG])
.with_layer()
.create();
load_fragment_shader!(image_shade, p, "./shader/image.spv");
⋮----
.sampler()
.with_filters(wgpu::FilterMode::Nearest)
.with_mipmap_filter(wgpu::FilterMode::Linear)
⋮----
let mut effects = vec![];
⋮----
let color = hsv2rgb(vec3(color_shift, 1.0, 0.7));
let color_binding = p.bind_const_vec3(color);
⋮----
effects.push(
p.effect(image_shade)
.with_bindings(map! {
⋮----
.with_mip_source(i)
.with_mip_target(i - 1)
.create(),
⋮----
.layer()
.with_effects(effects)
.with_mips_max(MIP_EFFECT_COUNT)
⋮----
let u_time = p.bind_f32();
let u_mip_levels = p.bind_f32();
⋮----
.with_bindings([
⋮----
load_fragment_shader!(sample_shade, p, "./shader/mip_sampling.spv");
⋮----
.effect(sample_shade)
⋮----
.with_layers(map! { 1 => image.binding() })
⋮----
let canvas = p.layer().with_effects([sample_effect]).create();
⋮----
fn resize(&mut self, p: &mut Painter, _width: u32, _height: u32) {
let mips = self.image.get_mip_levels_count(p);
self.u_mip_levels.update(p, mips as f32);
⋮----
fn frame(&mut self, p: &mut Painter, tpf: f32) {
⋮----
self.u_time.update(p, self.time);
⋮----
p.paint(self.image);
p.paint_and_show(self.canvas);
⋮----
p.request_next_frame();
⋮----
fn event(&mut self, _e: Event<()>, _p: &mut Painter) {}
⋮----
pub fn main() {
⋮----
.config(AppConfig {
⋮----
..default()
⋮----
.start();
</file>

<file path="Cargo.toml">
[package]
name = "trivalibs_examples"
version = "0.1.0"
edition = "2024"

[workspace]
resolver = "2"
members = [
	"crates/*",
	"examples/triangle",    # special example where the code references a shader crate
	"examples/**/shader",
]

[workspace.package]
edition = "2024"

[workspace.dependencies]
trivalibs = { path = "crates/trivalibs" }
trivalibs-core = { path = "crates/trivalibs_core" }
trivalibs-painter = { path = "crates/trivalibs_painter" }
trivalibs-nostd = { path = "crates/trivalibs_nostd" }
trivalibs-macros = { path = "crates/trivalibs_macros" }
serde = { version = "1.0", features = ["derive"] }
serde_repr = "0.1"
serde_bytes = "0.11"
bytemuck = { version = "1.24", features = ["derive"] }
js-sys = "0.3"
lerp = "0.5"
approx = "0.5.1"
rand = {version = "0.9", features = ["thread_rng"] }
getrandom = { version = "0.3", features = ["wasm_js"] }
glam = { version = "0.30", features = [
	"bytemuck",
	"serde",
	"rand",
	"approx",
] }
winit = "0.30"
wgpu = { version = "26.0", features = ["spirv"] }
spirv-std = { git = "https://github.com/Rust-GPU/rust-gpu", rev = "b3eda4df9814b6176d3c0844eb67f70a22ebb378" }
log = "0.4"
env_logger = "0.11"
pollster = "0.4"
macro_rules_attribute = "0.2.0"
png = "0.18"
flume = "0.11"
notify = "8.2"

[dependencies]

trivalibs = { path = "crates/trivalibs" }
trivalibs-core = { path = "crates/trivalibs_core" }
trivalibs-painter = { path = "crates/trivalibs_painter" }
trivalibs-nostd = { path = "crates/trivalibs_nostd" }
png.workspace = true
bytemuck.workspace = true
log.workspace = true
pollster.workspace = true
env_logger.workspace = true
flume.workspace = true

[workspace.metadata.rust-gpu.build]
multimodule = true

[workspace.metadata.rust-gpu.install]
spirv_builder_source = "https://github.com/Rust-GPU/rust-gpu"
spirv_builder_version = "b3eda4df9814b6176d3c0844eb67f70a22ebb378"
</file>

<file path="crates/trivalibs_painter/src/texture.rs">
use std::collections::BTreeMap;
use trivalibs_core::utils::default;
use wgpu::TextureViewDescriptor;
⋮----
pub enum MipMapCount {
⋮----
/// # Default Texture2DProps
/// - Format: `Rgba8UnormSrgb` (8-bit RGBA color in sRGB color space)
⋮----
/// - Format: `Rgba8UnormSrgb` (8-bit RGBA color in sRGB color space)
/// - Usage: `TEXTURE_BINDING | COPY_DST` (can be used as texture and receive data)
⋮----
/// - Usage: `TEXTURE_BINDING | COPY_DST` (can be used as texture and receive data)
#[derive(Clone, Copy)]
pub(crate) struct Texture2DProps {
⋮----
impl Default for Texture2DProps {
fn default() -> Self {
⋮----
pub(crate) enum TexViewKey {
⋮----
impl TexViewKey {
pub fn make_view(&self, t: &wgpu::Texture) -> wgpu::TextureView {
⋮----
TexViewKey::Default => t.create_view(&default()),
TexViewKey::WithAllMips => t.create_view(&TextureViewDescriptor {
mip_level_count: Some(t.mip_level_count()),
..default()
⋮----
TexViewKey::AtMipLevel(mip_level) => t.create_view(&wgpu::TextureViewDescriptor {
⋮----
mip_level_count: Some(1),
⋮----
pub(crate) struct TextureStorage {
⋮----
impl TextureStorage {
pub(crate) fn prepare_view(&mut self, key: TexViewKey) {
let view = key.make_view(&self.texture);
self.views.insert(key, view);
⋮----
pub struct Texture(pub(crate) usize);
⋮----
fn create_2d(
⋮----
let max_mip_levels = num_mip_levels(extent);
⋮----
MipMapCount::Max(max) => max.min(max_mip_levels),
⋮----
painter.device.create_texture(&wgpu::TextureDescriptor {
⋮----
fn create_depth(
⋮----
impl Texture {
pub(crate) fn create_2d(
⋮----
let texture = create_2d(painter, width, height, props, multi_sampled);
⋮----
storage.prepare_view(TexViewKey::AtMipLevel(0));
storage.prepare_view(TexViewKey::WithAllMips);
⋮----
painter.textures.push(storage);
⋮----
Self(painter.textures.len() - 1)
⋮----
pub(crate) fn replace_2d(
⋮----
old.texture.destroy();
⋮----
pub fn create_depth(
⋮----
let texture = create_depth(painter, width, height, multi_sampled);
⋮----
storage.prepare_view(TexViewKey::Default);
⋮----
pub fn replace_depth(
⋮----
pub fn fill_2d(&self, painter: &Painter, data: &[u8]) {
⋮----
let bytes_per_pixel = texture.format().block_copy_size(None).unwrap();
⋮----
let size = texture.size();
painter.queue.write_texture(
// Tells wgpu where to copy the pixel data
⋮----
// The actual pixel data
⋮----
// The layout of the texture
⋮----
bytes_per_row: Some(size.width * bytes_per_pixel),
rows_per_image: Some(size.height),
⋮----
self.update_mips(painter);
⋮----
pub fn destroy(self, painter: &mut Painter) {
⋮----
t.texture.destroy();
⋮----
pub(crate) fn prepare_view(&self, painter: &mut Painter, key: TexViewKey) {
⋮----
if !t.views.contains_key(&key) {
let view = key.make_view(&t.texture);
painter.textures[self.0].views.insert(key, view);
⋮----
pub(crate) fn prepare_mip_level_views(&self, painter: &mut Painter) {
⋮----
for i in 1..t.mip_level_count() {
self.prepare_view(painter, TexViewKey::AtMipLevel(i));
⋮----
pub(crate) fn view<'a>(&self, painter: &'a Painter, key: &TexViewKey) -> &'a wgpu::TextureView {
painter.textures[self.0].views.get(key).unwrap()
⋮----
pub(crate) fn source_view<'a>(&'a self, painter: &'a Painter) -> &'a wgpu::TextureView {
self.view(painter, &TexViewKey::WithAllMips)
⋮----
pub(crate) fn target_view<'a>(&self, painter: &'a Painter) -> &'a wgpu::TextureView {
self.view(painter, &TexViewKey::AtMipLevel(0))
⋮----
pub fn update_mips(&self, painter: &Painter) {
⋮----
if t.mip_level_count() > 1 {
let texture = &t.clone();
generate_mipmap_2d(painter, texture);
⋮----
pub fn get_mip_level_count(&self, painter: &Painter) -> u32 {
painter.textures[self.0].texture.mip_level_count()
</file>

<file path="examples/ball/main.rs">
use geom::create_ball_geom;
⋮----
mod geom;
⋮----
struct App {
⋮----
fn init(p: &mut Painter) -> Self {
let tex_bytes = include_bytes!("./texture.png");
⋮----
.read_info()
.unwrap();
// Allocate the output buffer.
let mut buf = vec![0; reader.output_buffer_size().unwrap()];
// Read the next frame. An APNG might contain multiple frames.
let info = reader.next_frame(&mut buf).unwrap();
// Grab the bytes of the image.
let tex_rgba = &buf[..info.buffer_size()];
⋮----
.layer()
.with_size(info.width, info.height)
.with_static_texture_data(tex_rgba)
.with_format(wgpu::TextureFormat::Rgba8UnormSrgb)
.create();
⋮----
.shade([Float32x3, Float32x2, Float32x3, Float32x3])
.with_bindings([
⋮----
.with_layers([BINDING_LAYER_FRAG])
⋮----
load_vertex_shader!(shade, p, "./shader/vertex.spv");
load_fragment_shader!(shade, p, "./shader/fragment.spv");
⋮----
let form = p.form(&create_ball_geom()).create();
⋮----
let mvp = p.bind_mat4();
let norm = p.bind_mat3();
⋮----
let s = p.sampler_linear().binding();
⋮----
.shape(form, shade)
.with_bindings(map! {
⋮----
.with_layers(map! {
⋮----
.with_shape(shape)
.with_clear_color(wgpu::Color {
⋮----
.with_multisampling()
⋮----
fov: Some(0.65),
translation: Some(vec3(0.0, 5.0, 0.0)),
rot_vertical: Some(-0.26),
..default()
⋮----
ball_transform: Transform::from_translation(vec3(0.0, 0.0, -20.0)),
⋮----
fn resize(&mut self, _p: &mut Painter, width: u32, height: u32) {
self.cam.set_aspect_ratio(width as f32 / height as f32);
⋮----
fn frame(&mut self, p: &mut Painter, tpf: f32) {
self.ball_transform.rotate_y(tpf * 0.5);
⋮----
.update(p, self.ball_transform.model_view_proj_mat(&self.cam));
⋮----
.update_mat3(p, self.ball_transform.view_normal_mat(&self.cam));
⋮----
p.paint_and_show(self.canvas);
⋮----
p.request_next_frame();
⋮----
fn event(&mut self, _e: Event<()>, _p: &mut Painter) {}
⋮----
pub fn main() {
⋮----
.config(AppConfig {
⋮----
.start();
</file>

<file path="examples/geometries/main.rs">
pub fn create_plane(width: f32, height: f32, normal: Vec3, center: Vec3) -> BufferedGeometry {
⋮----
Quad3D::from_dimensions_center_f(width, height, normal, center, vert_pos_uv).into();
⋮----
geom.add_face_data(&plane.to_ccw_verts(), face_normal(plane.normal));
⋮----
geom.to_buffered_geometry_by_type(MeshBufferType::FaceVerticesWithVertexNormal)
⋮----
pub fn create_box(center: Vec3, size: Vec3) -> BufferedGeometry {
⋮----
let front = bbox.front_face_f(|pos, uvw| vert_pos_uv(pos, vec2(uvw.x, uvw.y)));
geom.add_face_data(&front.to_ccw_verts(), face_props(front.normal, 0));
⋮----
let back = bbox.back_face_f(|pos, uvw| vert_pos_uv(pos, vec2(1.0 - uvw.x, uvw.y)));
geom.add_face_data(&back.to_ccw_verts(), face_props(back.normal, 1));
⋮----
let left = bbox.left_face_f(|pos, uvw| vert_pos_uv(pos, vec2(1.0 - uvw.z, uvw.y)));
geom.add_face_data(&left.to_ccw_verts(), face_props(left.normal, 2));
⋮----
let right = bbox.right_face_f(|pos, uvw| vert_pos_uv(pos, vec2(uvw.z, uvw.y)));
geom.add_face_data(&right.to_ccw_verts(), face_props(right.normal, 3));
⋮----
let top = bbox.top_face_f(|pos, uvw| vert_pos_uv(pos, vec2(uvw.x, 1.0 - uvw.z)));
geom.add_face_data(&top.to_ccw_verts(), face_props(top.normal, 4));
⋮----
let bottom = bbox.bottom_face_f(|pos, uvw| vert_pos_uv(pos, vec2(uvw.x, uvw.z)));
geom.add_face_data(&bottom.to_ccw_verts(), face_props(bottom.normal, 5));
⋮----
geom.to_buffered_geometry_by_type(MeshBufferType::FaceVerticesWithFaceNormal)
⋮----
struct App {
⋮----
fn init(p: &mut Painter) -> Self {
⋮----
.shade([Float32x3, Float32x3, Float32x2])
.with_bindings([BINDING_BUFFER_VERT])
.create();
load_vertex_shader!(shade, p, "./shader/ground_vert.spv");
load_fragment_shader!(shade, p, "./shader/ground_frag.spv");
⋮----
fov: Some(0.6),
translation: Some(vec3(0.0, 3.0, 15.0)),
..default()
⋮----
.form(&create_plane(100.0, 100.0, Vec3::Y, Vec3::ZERO))
⋮----
.form(&create_plane(100.0, 100.0, -Vec3::Y, vec3(0.0, 10.0, 0.0)))
⋮----
.form(&create_plane(20.5, 5.0, Vec3::Z, vec3(15.0, 3.0, 0.0)))
⋮----
.form(&create_box(vec3(2.5, 0.5, 0.0), vec3(5.0, 0.5, 0.5)))
⋮----
.form(&create_box(vec3(0.0, 3.0, 0.0), vec3(0.5, 5.0, 0.5)))
⋮----
.form(&create_box(vec3(0.0, 0.5, 2.5), vec3(0.5, 0.5, 5.0)))
⋮----
let ground_shape = p.shape(ground_form, shade).create();
let wall_shape = p.shape(wall_form, shade).create();
let roof_shape = p.shape(roof_form, shade).create();
let x_axis_shape = p.shape(x_axis_form, shade).with_cull_mode(None).create();
let y_axis_shape = p.shape(y_axis_form, shade).with_cull_mode(None).create();
let z_axis_shape = p.shape(z_axis_form, shade).with_cull_mode(None).create();
⋮----
let vp_mat = p.bind_mat4();
⋮----
.layer()
.with_shapes([
⋮----
.with_clear_color(wgpu::Color {
⋮----
.with_bindings(map! {
⋮----
.with_multisampling()
.with_depth_test()
⋮----
input: default(),
⋮----
fn resize(&mut self, _p: &mut Painter, width: u32, height: u32) {
self.cam.set_aspect_ratio(width as f32 / height as f32);
self.cam_controller.set_screen_size(width, height);
⋮----
fn frame(&mut self, p: &mut Painter, tpf: f32) {
⋮----
.update_camera(&mut self.cam, &self.input, tpf);
⋮----
self.vp_mat.update(p, self.cam.view_proj_mat());
⋮----
p.paint_and_show(self.canvas);
⋮----
p.request_next_frame();
⋮----
fn event(&mut self, e: Event<()>, _p: &mut Painter) {
self.input.process_event(e);
⋮----
pub fn main() {
⋮----
.config(AppConfig {
⋮----
.start();
</file>

<file path="crates/trivalibs_painter/src/painter.rs">
use wgpu::RenderPassColorAttachment;
use winit::window::Window;
⋮----
pub struct Painter {
⋮----
pub(crate) struct PainterConfig {
⋮----
impl Painter {
pub(crate) async fn new(window: Arc<Window>, painter_config: PainterConfig) -> Self {
let mut size = window.inner_size();
size.width = size.width.max(1);
size.height = size.height.max(1);
⋮----
let surface = instance.create_surface(window.clone()).unwrap();
⋮----
.request_adapter(&wgpu::RequestAdapterOptions {
⋮----
// Request an adapter which can render to our surface
compatible_surface: Some(&surface),
⋮----
.expect("Failed to find an appropriate adapter");
⋮----
// Create the logical device and command queue
⋮----
.request_device(&wgpu::DeviceDescriptor {
⋮----
required_features: painter_config.features.unwrap_or(wgpu::Features::empty()),
// Make sure we use the texture resolution limits from the adapter, so we can support images the size of the swapchain.
⋮----
.using_resolution(adapter.limits()),
⋮----
.expect("Failed to create device");
⋮----
let surface_caps = surface.get_capabilities(&adapter);
⋮----
view_formats: vec![],
⋮----
surface.configure(&device, &config);
⋮----
let fullscreen_quad_shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
label: Some("Fullscreen Quad Shader"),
⋮----
window: window.clone(),
⋮----
BindGroupLayout::values(&mut painter, &[BINDING_SAMPLER_FRAG]).unwrap();
⋮----
BindGroupLayout::layers(&mut painter, &[BINDING_LAYER_FRAG]).unwrap();
⋮----
Some(layer_sampler_layout),
⋮----
&vec![(0, Sampler(0).binding())],
⋮----
&vec![(0, Sampler(1).binding())],
⋮----
.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
⋮----
.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
⋮----
layout: Some(&fullscreen_quad_pipeline_layout),
⋮----
entry_point: Some("vs_main"),
⋮----
compilation_options: default(),
⋮----
fragment: Some(wgpu::FragmentState {
⋮----
entry_point: Some("fs_main"),
targets: &[Some(wgpu::ColorTargetState {
⋮----
blend: Some(wgpu::BlendState::REPLACE),
⋮----
..default()
⋮----
painter.pipelines.insert(
FULL_SCREEN_TEXTURE_PIPELINE.to_vec(),
⋮----
pub fn window(&self) -> &Arc<Window> {
⋮----
// form helpers
⋮----
pub fn form<'a>(&mut self, buffer: impl Into<FormBuffer<'a>>) -> FormBuilder<'_, 'a> {
FormBuilder::new(self).with_buffer(buffer)
⋮----
pub fn form_builder(&mut self) -> FormBuilder<'_, '_> {
⋮----
pub fn form_update<'a>(&mut self, form: Form, buffer: impl Into<FormBuffer<'a>>) {
form.update(self, buffer);
⋮----
// shade helpers
⋮----
pub fn shade<Format: Into<AttribsFormat>>(
⋮----
pub fn shade_effect(&mut self) -> ShadeEffectBuilder<'_> {
⋮----
// texture helpers
⋮----
pub fn sampler(&mut self) -> SamplerBuilder<'_> {
⋮----
pub fn sampler_nearest(&self) -> Sampler {
Sampler(0)
⋮----
pub fn sampler_linear(&self) -> Sampler {
Sampler(1)
⋮----
// shape utils
⋮----
pub fn shape(&mut self, form: Form, shade: Shade) -> ShapeBuilder<'_> {
⋮----
pub fn effect(&mut self, shade: Shade) -> EffectBuilder<'_> {
⋮----
// layer utils
⋮----
pub fn layer<'b>(&mut self) -> LayerBuilder<'_, 'b> {
⋮----
pub fn single_effect_layer(&mut self, shade: Shade) -> SingleEffectLayerBuilder<'_> {
⋮----
// binding utils
⋮----
pub fn bind_buff<T: bytemuck::Pod>(&mut self, data: T) -> BindingBuffer<T> {
⋮----
pub fn bind_mat3(&mut self) -> BindingBuffer<Mat3U> {
self.bind_buff(Mat3U(Mat3A::IDENTITY))
⋮----
pub fn bind_mat4(&mut self) -> BindingBuffer<Mat4> {
self.bind_buff(Mat4::IDENTITY)
⋮----
pub fn bind_vec2(&mut self) -> BindingBuffer<Vec2> {
self.bind_buff(Vec2::ZERO)
⋮----
pub fn bind_vec3(&mut self) -> BindingBuffer<Vec3U> {
self.bind_buff(Vec3U(Vec3A::ZERO))
⋮----
pub fn bind_vec4(&mut self) -> BindingBuffer<Vec4> {
self.bind_buff(Vec4::ZERO)
⋮----
pub fn bind_uvec2(&mut self) -> BindingBuffer<UVec2> {
self.bind_buff(UVec2::ZERO)
⋮----
pub fn bind_f32(&mut self) -> BindingBuffer<f32> {
self.bind_buff(0.0f32)
⋮----
pub fn bind_u32(&mut self) -> BindingBuffer<u32> {
self.bind_buff(0u32)
⋮----
pub fn bind_quat(&mut self) -> BindingBuffer<Quat> {
self.bind_buff(Quat::IDENTITY)
⋮----
pub fn bind_const_buff<T: bytemuck::Pod>(&mut self, data: T) -> ValueBinding {
self.bind_buff(data).binding()
⋮----
pub fn bind_const_mat3(&mut self, mat: Mat3) -> ValueBinding {
let u = self.bind_mat3();
u.update_mat3(self, mat);
u.binding()
⋮----
pub fn bind_const_mat4(&mut self, mat: Mat4) -> ValueBinding {
self.bind_const_buff(mat)
⋮----
pub fn bind_const_vec2(&mut self, vec: Vec2) -> ValueBinding {
self.bind_const_buff(vec)
⋮----
pub fn bind_const_vec3(&mut self, vec: Vec3) -> ValueBinding {
let u = self.bind_vec3();
u.update_vec3(self, vec);
⋮----
pub fn bind_const_vec4(&mut self, vec: Vec4) -> ValueBinding {
⋮----
pub fn bind_const_uvec2(&mut self, vec: UVec2) -> ValueBinding {
⋮----
pub fn bind_const_f32(&mut self, f: f32) -> ValueBinding {
self.bind_const_buff(f)
⋮----
pub fn bind_const_u32(&mut self, u: u32) -> ValueBinding {
self.bind_const_buff(u)
⋮----
pub fn bind_const_quat(&mut self, quat: Quat) -> ValueBinding {
self.bind_const_buff(quat)
⋮----
// general utils
⋮----
pub fn request_next_frame(&self) {
self.window.request_redraw();
⋮----
pub fn resize(&mut self, new_size: winit::dpi::PhysicalSize<u32>) {
self.config.width = new_size.width.max(1);
self.config.height = new_size.height.max(1);
self.surface.configure(&self.device, &self.config);
⋮----
.iter()
.enumerate()
.filter_map(|(i, l)| if l.use_window_size { Some(i) } else { None })
.collect();
⋮----
Layer(idx).resize(self, 0, 0);
⋮----
pub fn canvas_size(&self) -> winit::dpi::PhysicalSize<u32> {
self.window.inner_size()
⋮----
pub(crate) fn get_shape_pipeline_key(&self, shape: Shape, layer: Layer) -> Vec<u8> {
⋮----
[sp.pipeline_key.as_slice(), l.pipeline_key.as_slice()].concat()
⋮----
pub(crate) fn ensure_shape_pipeline<'a>(
⋮----
if !self.pipelines.contains_key(pipeline_key) {
⋮----
self.pipelines.insert(pipeline_key.clone(), pipeline);
⋮----
pub(crate) fn get_effect_pipeline_key(&self, effect: Effect, layer: Layer) -> Vec<u8> {
let layer_key = self.layers[layer.0].pipeline_key.as_slice();
let effect_key = self.effects[effect.0].pipeline_key.as_slice();
[effect_key, layer_key].concat()
⋮----
pub(crate) fn ensure_effect_pipeline<'a>(
⋮----
self.pipelines.insert(pipeline_key.to_vec(), pipeline);
⋮----
/// Renders a shape with optimized instance handling.
	///
⋮----
///
	/// # Instance Rendering Rules
⋮----
/// # Instance Rendering Rules
	/// Based on the lengths of bind_groups (value bindings) and layer_bind_group_data (layer bindings):
⋮----
/// Based on the lengths of bind_groups (value bindings) and layer_bind_group_data (layer bindings):
	///
⋮----
///
	/// 1. **No instances** (both ≤ 1): Set bindings once, single draw call
⋮----
/// 1. **No instances** (both ≤ 1): Set bindings once, single draw call
	/// 2. **Only value bindings vary** (values > 1, layers ≤ 1):
⋮----
/// 2. **Only value bindings vary** (values > 1, layers ≤ 1):
	///    Set layer bindings once, iterate through value bindings
⋮----
///    Set layer bindings once, iterate through value bindings
	/// 3. **Only layer bindings vary** (layers > 1, values ≤ 1):
⋮----
/// 3. **Only layer bindings vary** (layers > 1, values ≤ 1):
	///    Set value bindings once, iterate through layer bindings
⋮----
///    Set value bindings once, iterate through layer bindings
	/// 4. **Both vary** (both > 1):
⋮----
/// 4. **Both vary** (both > 1):
	///    Iterate through all instances, setting both bind groups per draw
⋮----
///    Iterate through all instances, setting both bind groups per draw
	///
⋮----
///
	/// This respects the override hierarchy: Layer → Shape → Instance
⋮----
/// This respects the override hierarchy: Layer → Shape → Instance
	fn render_shape(&self, pass: &mut wgpu::RenderPass<'_>, shape_index: usize, layer: Layer) {
⋮----
fn render_shape(&self, pass: &mut wgpu::RenderPass<'_>, shape_index: usize, layer: Layer) {
⋮----
pass.set_bind_group(0, &self.bind_groups[binding.0].bind_group, &[]);
⋮----
pass.set_vertex_buffer(0, b.vertex_buffer.slice(..b.vertex_buffer_current_size));
⋮----
pass.set_index_buffer(
index_buffer.slice(..b.index_buffer_current_size),
⋮----
pass.draw_indexed(0..b.index_count, 0, 0..1);
⋮----
pass.draw(0..b.vertex_count, 0..1);
⋮----
let pipeline_key = self.get_shape_pipeline_key(shape, layer);
⋮----
pass.set_pipeline(&pipeline.pipeline);
⋮----
// Get bindings from shape_data
⋮----
// Use pre-computed rendering strategy
⋮----
// Case 1: No instances - both bindings ≤ 1
// Set both bind groups once and do single draw
⋮----
let layer_bind_group = layer_bind_group_data.to_gpu_bind_group(self);
pass.set_bind_group(1, &layer_bind_group, &[]);
⋮----
let value_binding = bind_groups.first().copied();
draw(pass, value_binding);
⋮----
// Case 2: Only value bindings vary (values > 1, layers ≤ 1)
// Set layer bindings once, iterate through value bindings
⋮----
draw(pass, Some(*value_bg));
⋮----
// Case 3: Only layer bindings vary (layers > 1, values ≤ 1)
// Set value bindings once, iterate through layer bindings
if let Some(value_bg) = bind_groups.first() {
pass.set_bind_group(0, &self.bind_groups[value_bg.0].bind_group, &[]);
⋮----
let layer_bind_groups = layer_bind_group_data.to_gpu_bind_groups(self);
⋮----
pass.set_bind_group(1, &layer_bg, &[]);
draw(pass, None);
⋮----
// Case 4: Both bindings vary (both > 1)
// Iterate through all instances, setting both bind groups per draw
⋮----
for (value_bg, layer_bg) in bind_groups.iter().zip(layer_bind_groups.iter()) {
⋮----
pass.set_bind_group(1, layer_bg, &[]);
⋮----
/// Helper to create a single layer bind group, optionally prepending the source binding.
	fn create_layer_bind_group(
⋮----
fn create_layer_bind_group(
⋮----
layer_bind_group_data.to_gpu_bind_group_with_first(self, binding)
⋮----
layer_bind_group_data.to_gpu_bind_group(self)
⋮----
/// Helper to create multiple layer bind groups, optionally prepending the source binding to each.
	fn create_layer_bind_groups(
⋮----
fn create_layer_bind_groups(
⋮----
layer_bind_group_data.to_gpu_bind_groups_with_first(self, binding)
⋮----
layer_bind_group_data.to_gpu_bind_groups(self)
⋮----
/// Renders an effect with optimized instance handling.
	///
⋮----
///
	/// This respects the override hierarchy: Layer → Effect → Instance
⋮----
/// This respects the override hierarchy: Layer → Effect → Instance
	fn render_effect(&self, effect_index: usize, layer: Layer, skip_source: bool) {
⋮----
fn render_effect(&self, effect_index: usize, layer: Layer, skip_source: bool) {
⋮----
l.current_target_texture()
.view(self, &TexViewKey::AtMipLevel(mip_level))
⋮----
l.current_target_texture().target_view(self)
⋮----
.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: None });
⋮----
let mut pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
⋮----
color_attachments: &[Some(wgpu::RenderPassColorAttachment {
⋮----
.map_or(wgpu::LoadOp::Load, |color| wgpu::LoadOp::Clear(color)),
⋮----
let pipeline_key = self.get_effect_pipeline_key(effect, layer);
⋮----
// Get bindings from effect_data
⋮----
// Pre-compute source binding if needed (avoids duplicate computation in all cases)
⋮----
Some(if let Some(src_mip_level) = e.src_mip_level {
layer.binding_at_mip_level(src_mip_level)
⋮----
layer.binding()
⋮----
let layer_bind_group = self.create_layer_bind_group(
⋮----
source_binding.as_ref(),
⋮----
pass.draw(0..3, 0..1);
⋮----
let layer_bind_groups = self.create_layer_bind_groups(
⋮----
for (value_bg, layer_bg) in bind_groups.iter().zip(layer_bind_groups.iter())
⋮----
self.queue.submit(Some(encoder.finish()));
⋮----
pub fn paint(&mut self, layer: Layer) {
⋮----
let shapes_len = l.shapes.len();
let effects_len = l.effects.len();
⋮----
let target_view = l.current_target_texture().target_view(self);
let multisampled_texture = l.multisampled_textures.get(0);
⋮----
let view = multisampled_texture.map_or(target_view, |t| t.target_view(self));
let resolve_target = multisampled_texture.map(|_| target_view);
⋮----
vec![Some(wgpu::RenderPassColorAttachment {
⋮----
.map(|(i, t)| {
let target_view = t.target_view(self);
let multisampled_texture = l.multisampled_textures.get(i);
⋮----
multisampled_texture.map_or(target_view, |t| t.target_view(self));
⋮----
Some(wgpu::RenderPassColorAttachment {
⋮----
load: l.clear_color.map_or(wgpu::LoadOp::Load, |color| {
⋮----
depth_stencil_attachment: l.depth_texture.as_ref().map(|t| {
⋮----
view: t.view(self, &TexViewKey::Default),
depth_ops: Some(wgpu::Operations {
⋮----
self.render_shape(&mut pass, i, layer);
⋮----
l.current_target_texture().update_mips(self);
⋮----
self.layers[layer.0].swap_targets();
⋮----
let skip_source_tex = i == 0 && !(has_shapes || e.src_mip_level.is_some());
self.render_effect(i, layer, skip_source_tex);
⋮----
if e.dst_mip_level.is_none() {
⋮----
// If the effect has a mip target, we don't swap the targets.
// Instead, we update the mips of the current target texture.
⋮----
.current_source_texture()
.update_mips(self);
⋮----
pub fn compose<I>(&mut self, layers: I)
⋮----
self.paint(layer);
⋮----
pub fn show(&mut self, layer: Layer) {
let result = self.surface.get_current_texture();
⋮----
if result.is_err() {
self.surface_error = Some(result.err().unwrap());
⋮----
let frame = result.unwrap();
⋮----
.create_view(&wgpu::TextureViewDescriptor::default());
⋮----
pass.set_bind_group(0, &self.bind_groups[0].bind_group, &[]);
pass.set_bind_group(
⋮----
&BindGroup::layer_gpu_bind_group(self, layer.binding()),
⋮----
frame.present();
⋮----
pub fn paint_and_show(&mut self, layer: Layer) {
⋮----
self.show(layer)
⋮----
/// Initializes GPU pipelines for the layer and then renders it.
	/// Pipelines need to be initialized only once per layer, so this is a convenient method for the first paint.
⋮----
/// Pipelines need to be initialized only once per layer, so this is a convenient method for the first paint.
	///
⋮----
///
	/// Only needed if the layer was created outsite of CanvasApp::init, or if the layer should be rendered immediately after creation.
⋮----
/// Only needed if the layer was created outsite of CanvasApp::init, or if the layer should be rendered immediately after creation.
	/// Otherwise, all layers are initialized automatically after CanvasApp::init and before the first CanvasApp::render call.
⋮----
/// Otherwise, all layers are initialized automatically after CanvasApp::init and before the first CanvasApp::render call.
	pub fn init_and_paint(&mut self, layer: Layer) {
⋮----
pub fn init_and_paint(&mut self, layer: Layer) {
layer.init_gpu_pipelines(self);
⋮----
pub(crate) fn reload_shader(&mut self, path: String) {
println!("Reloading shader: {}", path);
⋮----
.filter_map(|(idx, s)| {
if s.vertex_path.as_ref().map_or(false, |p| p.contains(&path)) {
return Some(idx);
⋮----
.as_ref()
.map_or(false, |p| p.contains(&path))
⋮----
.keys()
.cloned()
.map(|key| (u16::from_le_bytes([key[0], key[1]]), key))
⋮----
Shade(idx).load_fragment_from_path(self);
Shade(idx).load_vertex_from_path(self);
⋮----
let pipeline = self.pipelines.remove(pipeline_key);
⋮----
let pipeline = pipeline.recreate(self);
⋮----
pub(crate) fn get_padded_size(unpadded_size: u64) -> u64 {
// Valid vulkan usage is
// 1. buffer size must be a multiple of COPY_BUFFER_ALIGNMENT.
// 2. buffer size must be greater than 0.
// Therefore we round the value up to the nearest multiple, and ensure it's at least COPY_BUFFER_ALIGNMENT.
⋮----
((unpadded_size + align_mask) & !align_mask).max(wgpu::COPY_BUFFER_ALIGNMENT)
</file>

<file path="crates/trivalibs_painter/src/layer.rs">
/// Describes the instance rendering strategy to use based on binding configurations.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub(crate) enum InstanceRenderingStrategy {
/// No instances - both value and layer bindings ≤ 1
	/// Set both bind groups once and do single draw
⋮----
/// Set both bind groups once and do single draw
	NoInstances,
/// Only value bindings vary - values > 1, layers ≤ 1
	/// Set layer bindings once, iterate through value bindings
⋮----
/// Set layer bindings once, iterate through value bindings
	ValueBindingsVary,
/// Only layer bindings vary - layers > 1, values ≤ 1
	/// Set value bindings once, iterate through layer bindings
⋮----
/// Set value bindings once, iterate through layer bindings
	LayerBindingsVary,
/// Both bindings vary - both > 1
	/// Iterate through all instances, setting both bind groups per draw
⋮----
/// Iterate through all instances, setting both bind groups per draw
	BothBindingsVary,
⋮----
impl InstanceRenderingStrategy {
/// Determines the rendering strategy based on bind group counts.
	pub(crate) fn from_counts(value_count: usize, layer_count: usize) -> Self {
⋮----
pub(crate) fn from_counts(value_count: usize, layer_count: usize) -> Self {
⋮----
pub struct LayerProps<'a> {
⋮----
impl Default for LayerProps<'_> {
fn default() -> Self {
⋮----
/// Encapsulates a single shape and its per-layer binding state.
#[derive(Clone)]
pub(crate) struct ShapeData {
⋮----
impl ShapeData {
/// Creates a new ShapeData with bindings prepared using explicit layer data.
	pub(crate) fn new(
⋮----
pub(crate) fn new(
⋮----
shape_data.prepare_value_bindings(painter, layer_bindings);
shape_data.prepare_layer_bindings(painter, layer_layers);
shape_data.update_rendering_strategy();
⋮----
/// Updates the rendering strategy based on current bind group counts.
	fn update_rendering_strategy(&mut self) {
⋮----
fn update_rendering_strategy(&mut self) {
let value_count = self.bind_groups.len();
⋮----
.as_ref()
.map(|d| d.data.len())
.unwrap_or(0);
⋮----
/// Prepares value bindings (expensive - creates GPU resources).
	pub(crate) fn prepare_value_bindings(
⋮----
pub(crate) fn prepare_value_bindings(
⋮----
// Extract necessary data from storage
⋮----
let value_bindings = sp.bindings.clone();
let instances = sp.instances.clone();
⋮----
// Create GPU bind groups (expensive operation)
⋮----
/// Prepares layer bindings (cheap - only descriptors).
	pub(crate) fn prepare_layer_bindings(
⋮----
pub(crate) fn prepare_layer_bindings(
⋮----
let shape_layers = sp.layers.as_slice();
let shape_instances = sp.instances.as_slice();
⋮----
// Create layer bind group data (cheap operation)
⋮----
/// Encapsulates a single effect and its per-layer binding state.
#[derive(Clone)]
pub(crate) struct EffectData {
⋮----
impl EffectData {
/// Creates a new EffectData with bindings prepared using explicit layer data.
	pub(crate) fn new(
⋮----
effect_data.prepare_value_bindings(painter, layer_bindings);
effect_data.prepare_layer_bindings(painter, layer_layers);
effect_data.update_rendering_strategy();
⋮----
let value_bindings = ep.bindings.clone();
let instances = ep.instances.clone();
⋮----
// Convert slice to Vec for API compatibility
let layer_bindings_vec = layer_bindings.to_vec();
⋮----
let effect_layers = ep.layers.clone();
let effect_instances = ep.instances.as_slice();
⋮----
let layer_layers_vec = layer_layers.to_vec();
⋮----
pub(crate) struct LayerStorage {
⋮----
impl LayerStorage {
pub(crate) fn swap_targets(&mut self) {
⋮----
pub(crate) fn current_target_texture<'a>(&'a self) -> &'a Texture {
⋮----
pub(crate) fn current_source_texture<'a>(&'a self) -> &'a Texture {
⋮----
pub struct Layer(pub(crate) usize);
⋮----
impl Layer {
pub fn new(painter: &mut Painter, props: LayerProps) -> Self {
if props.static_texture && props.shapes.len() > 0 {
panic!("A layer can only either contain a static texture or render shapes, not both")
⋮----
.then(|| Texture::create_depth(painter, width, height, props.multisampled));
⋮----
let pipeline_key = vec![
⋮----
.into_iter()
.flatten()
.collect();
⋮----
let layer = Layer(painter.layers.len());
⋮----
.iter()
.filter(|e| !e.has_mip_target(painter) && !e.has_mip_source(painter))
.count();
⋮----
|| ((props.shapes.len() > 0 || props.static_texture) && swapping_effect_count > 0);
⋮----
let format_len = props.formats.len();
⋮----
panic!(
⋮----
target_textures.push(tex);
⋮----
multisampled_textures.push(Texture::create_2d(
⋮----
formats.push(format);
⋮----
let format = *props.formats.get(0).unwrap_or(&painter.config.format);
⋮----
.map(|shape| ShapeData::new(painter, shape, &props.bindings, &props.layers))
⋮----
.map(|effect| EffectData::new(painter, *effect, &props.bindings, &props.layers))
⋮----
painter.layers.push(storage);
⋮----
if props.effects.iter().any(|e| e.has_mip_target(painter)) {
let textures = painter.layers[layer.0].target_textures.clone();
⋮----
t.prepare_mip_level_views(painter);
⋮----
layer.update_static_data(painter, data);
⋮----
/// This function is called by after the CanvasApp::init function automatically.
	///
⋮----
///
	/// If Layers are created dynamically during App runtime,
⋮----
/// If Layers are created dynamically during App runtime,
	/// or if they need to be rendered directly inside CanvasApp::init,
⋮----
/// or if they need to be rendered directly inside CanvasApp::init,
	/// this method must to be called manually after all shaders are loaded.
⋮----
/// this method must to be called manually after all shaders are loaded.
	///
⋮----
///
	/// Alternatively, LayerBuilder::create_and_init can be used to create and initialize.
⋮----
/// Alternatively, LayerBuilder::create_and_init can be used to create and initialize.
	/// Or Painter::init_and_paint can be used to initialize and paint in one call.
⋮----
/// Or Painter::init_and_paint can be used to initialize and paint in one call.
	pub fn init_gpu_pipelines(&self, painter: &mut Painter) {
⋮----
pub fn init_gpu_pipelines(&self, painter: &mut Painter) {
⋮----
.map(|sd| sd.shape)
⋮----
.map(|ed| ed.effect)
⋮----
let key = painter.get_shape_pipeline_key(s, *self);
painter.ensure_shape_pipeline(&key, s, *self);
⋮----
let key = painter.get_effect_pipeline_key(e, *self);
painter.ensure_effect_pipeline(&key, e, *self);
⋮----
pub fn update_static_data(&self, painter: &Painter, data: &[u8]) {
⋮----
.current_source_texture()
.fill_2d(painter, data);
⋮----
pub fn binding(&self) -> LayerBinding {
⋮----
pub fn binding_at_mip_level(&self, mip_level: u32) -> LayerBinding {
⋮----
pub fn depth_binding(&self) -> LayerBinding {
⋮----
pub fn binding_at(&self, index: usize) -> LayerBinding {
⋮----
pub fn set_clear_color(&mut self, painter: &mut Painter, color: Option<wgpu::Color>) {
⋮----
/// Updates all layer-level bindings at once.
	///
⋮----
///
	/// Layer-level bindings serve as defaults for all shapes and effects in this layer.
⋮----
/// Layer-level bindings serve as defaults for all shapes and effects in this layer.
	/// These bindings are merged with shape/effect-specific bindings during rendering,
⋮----
/// These bindings are merged with shape/effect-specific bindings during rendering,
	/// with shape/effect bindings taking precedence.
⋮----
/// with shape/effect bindings taking precedence.
	///
⋮----
///
	/// This method automatically re-prepares all shapes and effects in the layer
⋮----
/// This method automatically re-prepares all shapes and effects in the layer
	/// to reflect the new bindings.
⋮----
/// to reflect the new bindings.
	///
⋮----
///
	/// # Arguments
⋮----
/// # Arguments
	/// * `painter` - The painter instance
⋮----
/// * `painter` - The painter instance
	/// * `layers` - Vector of (slot_index, LayerBinding) pairs
⋮----
/// * `layers` - Vector of (slot_index, LayerBinding) pairs
	///
⋮----
///
	pub fn set_layer_bindings(&self, painter: &mut Painter, layers: Vec<(u32, LayerBinding)>) {
⋮----
pub fn set_layer_bindings(&self, painter: &mut Painter, layers: Vec<(u32, LayerBinding)>) {
painter.layers[self.0].layers = layers.clone();
⋮----
// Clone the shapes and effects to avoid borrow conflicts
let mut shapes = painter.layers[self.0].shapes.clone();
let mut effects = painter.layers[self.0].effects.clone();
⋮----
// Update ONLY layer bindings (cheap operation - no GPU resource regeneration)
⋮----
sd.prepare_layer_bindings(painter, &layers);
⋮----
// Update ONLY layer bindings for effects
⋮----
ed.prepare_layer_bindings(painter, &layers);
⋮----
// Write back
⋮----
/// Updates a single layer-level binding by slot index.
	///
⋮----
///
	/// This is a convenience method for updating just one binding without
⋮----
/// This is a convenience method for updating just one binding without
	/// replacing the entire bindings vector. If the slot doesn't exist,
⋮----
/// replacing the entire bindings vector. If the slot doesn't exist,
	/// it will be added. If it exists, it will be updated.
⋮----
/// it will be added. If it exists, it will be updated.
	///
⋮----
/// * `painter` - The painter instance
	/// * `slot` - The binding slot index
⋮----
/// * `slot` - The binding slot index
	/// * `binding` - The new LayerBinding for this slot
⋮----
/// * `binding` - The new LayerBinding for this slot
	///
⋮----
///
	pub fn set_layer_binding(&self, painter: &mut Painter, slot: u32, binding: LayerBinding) {
⋮----
pub fn set_layer_binding(&self, painter: &mut Painter, slot: u32, binding: LayerBinding) {
let mut layers = painter.layers[self.0].layers.clone();
⋮----
// Find and update or insert
if let Some(pos) = layers.iter().position(|(i, _)| *i == slot) {
⋮----
layers.push((slot, binding));
layers.sort_by_key(|(s, _)| *s);
⋮----
self.set_layer_bindings(painter, layers);
⋮----
/// Replaces all shapes in the layer with a new list of shapes.
	///
⋮----
///
	/// This is useful for dynamically changing which shapes are rendered in a layer at runtime.
⋮----
/// This is useful for dynamically changing which shapes are rendered in a layer at runtime.
	/// The method will prepare bindings for the new shapes and ensure their GPU pipelines exist.
⋮----
/// The method will prepare bindings for the new shapes and ensure their GPU pipelines exist.
	/// Pipelines are cached and reused, so adding shapes that share configurations with existing
⋮----
/// Pipelines are cached and reused, so adding shapes that share configurations with existing
	/// shapes is efficient.
⋮----
/// shapes is efficient.
	///
⋮----
///
	pub fn set_shapes(&self, painter: &mut Painter, shapes: Vec<Shape>) {
⋮----
pub fn set_shapes(&self, painter: &mut Painter, shapes: Vec<Shape>) {
let layer_bindings = painter.layers[self.0].bindings.clone();
let layer_layers = painter.layers[self.0].layers.clone();
⋮----
.map(|&shape| ShapeData::new(painter, shape, &layer_bindings, &layer_layers))
⋮----
// Ensure pipelines exist for all shapes (will reuse cached if available)
⋮----
let key = painter.get_shape_pipeline_key(shape, *self);
painter.ensure_shape_pipeline(&key, shape, *self);
⋮----
/// Adds a single shape to the layer.
	///
⋮----
///
	/// This is a convenience method for appending a shape to the existing shapes vector.
⋮----
/// This is a convenience method for appending a shape to the existing shapes vector.
	/// If you need to replace all shapes or add multiple shapes at once, use `set_shapes()` instead.
⋮----
/// If you need to replace all shapes or add multiple shapes at once, use `set_shapes()` instead.
	///
⋮----
///
	pub fn add_shape(&self, painter: &mut Painter, shape: Shape) {
⋮----
pub fn add_shape(&self, painter: &mut Painter, shape: Shape) {
⋮----
painter.layers[self.0].shapes.push(shape_data);
⋮----
// Ensure pipeline exists for this shape
⋮----
/// Removes a specific shape from the layer.
	///
⋮----
///
	/// This filters out all occurrences of the given shape from the layer's shape list.
⋮----
/// This filters out all occurrences of the given shape from the layer's shape list.
	/// If the shape appears multiple times, all instances will be removed.
⋮----
/// If the shape appears multiple times, all instances will be removed.
	///
⋮----
///
	pub fn remove_shape(&self, painter: &mut Painter, shape: Shape) {
⋮----
pub fn remove_shape(&self, painter: &mut Painter, shape: Shape) {
⋮----
.retain(|sd| sd.shape.0 != shape.0);
⋮----
pub fn resize(&mut self, painter: &mut Painter, width: u32, height: u32) {
⋮----
let targets = storage.target_textures.clone();
let depth_texture = storage.depth_texture.clone();
let multisampled_textures = storage.multisampled_textures.clone();
⋮----
for texture in targets.iter() {
let format = painter.textures[texture.0].texture.format();
texture.replace_2d(
⋮----
depth_texture.replace_depth(painter, width, height, !multisampled_textures.is_empty());
⋮----
let format = painter.textures[t.0].texture.format();
t.replace_2d(
⋮----
.any(|ed| ed.effect.has_mip_target(painter));
⋮----
let textures = painter.layers[self.0].target_textures.clone();
⋮----
pub fn get_mip_levels_count(&self, painter: &Painter) -> u32 {
⋮----
storage.target_textures[0].get_mip_level_count(painter)
⋮----
/// A builder for creating a new [`Layer`].
///
⋮----
///
/// # Default Configuration values:
⋮----
/// # Default Configuration values:
/// - `sampler`: Nearest / ClampToEdge
⋮----
/// - `sampler`: Nearest / ClampToEdge
/// - `layer_layout`: BINDING_LAYER_FRAG
⋮----
/// - `layer_layout`: BINDING_LAYER_FRAG
/// - `clear_color`: None
⋮----
/// - `clear_color`: None
/// - `depth_test`: false
⋮----
/// - `depth_test`: false
/// - `multisampled`: false
⋮----
/// - `multisampled`: false
///
⋮----
///
/// # Example
⋮----
/// # Example
/// ```
⋮----
/// ```
/// let layer = LayerBuilder::new(painter)
⋮----
/// let layer = LayerBuilder::new(painter)
///     .with_size(800, 600)
⋮----
///     .with_size(800, 600)
///     .with_shape(rectangle)
⋮----
///     .with_shape(rectangle)
///     .with_clear_color(wgpu::Color::BLACK)
⋮----
///     .with_clear_color(wgpu::Color::BLACK)
///     .create();
⋮----
///     .create();
/// ```
⋮----
/// ```
///
⋮----
///
pub struct LayerBuilder<'a, 'b> {
⋮----
pub struct LayerBuilder<'a, 'b> {
⋮----
pub fn new(painter: &'a mut Painter) -> Self {
⋮----
pub fn create(self) -> Layer {
⋮----
/// Creates a layer and initializes the its gpu pipelines.
	///
⋮----
///
	/// Layers created in the App::init function are automatically initialized.
⋮----
/// Layers created in the App::init function are automatically initialized.
	/// They can use `create` method to create the layer.
⋮----
/// They can use `create` method to create the layer.
	///
⋮----
///
	/// Layers created during runtime must be initialized manually.
⋮----
/// Layers created during runtime must be initialized manually.
	/// Alternatively, use Painter::init_and_paint method to initialize and paint in one call.
⋮----
/// Alternatively, use Painter::init_and_paint method to initialize and paint in one call.
	pub fn create_and_init(self) -> Layer {
⋮----
pub fn create_and_init(self) -> Layer {
⋮----
layer.init_gpu_pipelines(self.painter);
⋮----
/// Creates a layer, initializes the its gpu pipelines and immediately renders it.
	pub fn create_and_paint(self) -> Layer {
⋮----
pub fn create_and_paint(self) -> Layer {
⋮----
self.painter.paint(layer);
⋮----
pub fn with_static_texture(mut self) -> Self {
⋮----
pub fn with_static_texture_data(mut self, data: &'b [u8]) -> Self {
⋮----
self.props.static_texture_data = Some(data);
⋮----
pub fn with_shapes<I>(mut self, shapes: I) -> Self
⋮----
self.props.shapes = shapes.into_iter().collect();
⋮----
pub fn with_shape(mut self, shape: Shape) -> Self {
self.props.shapes.push(shape);
⋮----
pub fn with_effects<I>(mut self, effects: I) -> Self
⋮----
self.props.effects = effects.into_iter().collect();
⋮----
pub fn with_effect(mut self, effect: Effect) -> Self {
self.props.effects.push(effect);
⋮----
pub fn with_bindings<I>(mut self, bindings: I) -> Self
⋮----
self.props.bindings = bindings.into_iter().collect();
⋮----
pub fn with_layers<I>(mut self, layers: I) -> Self
⋮----
self.props.layers = layers.into_iter().collect();
⋮----
pub fn with_size(mut self, width: u32, height: u32) -> Self {
⋮----
pub fn with_formats<I>(mut self, formats: I) -> Self
⋮----
self.props.formats = formats.into_iter().collect();
⋮----
pub fn with_format(mut self, format: wgpu::TextureFormat) -> Self {
self.props.formats = vec![format];
⋮----
pub fn with_clear_color(mut self, color: wgpu::Color) -> Self {
self.props.clear_color = Some(color);
⋮----
pub fn with_depth_test(mut self) -> Self {
⋮----
pub fn with_layer_layout_vert(mut self) -> Self {
⋮----
pub fn with_layer_layout_both(mut self) -> Self {
⋮----
pub fn with_multisampling(mut self) -> Self {
⋮----
pub fn with_mips(mut self) -> Self {
self.props.mips = Some(MipMapCount::Full);
⋮----
pub fn with_mips_max(mut self, max: u32) -> Self {
self.props.mips = Some(MipMapCount::Max(max));
⋮----
/// A builder for creating a new [`Layer`] with a single [`Effect`].
///
⋮----
///
/// This builder merges the functionality of [`LayerBuilder`] and [`EffectBuilder`]
⋮----
/// This builder merges the functionality of [`LayerBuilder`] and [`EffectBuilder`]
/// for the common case of creating a layer with exactly one effect.
⋮----
/// for the common case of creating a layer with exactly one effect.
///
/// # Default Configuration values:
/// - `blend_state`: wgpu::BlendState::REPLACE
⋮----
/// - `blend_state`: wgpu::BlendState::REPLACE
/// - `clear_color`: None
⋮----
/// - `clear_color`: None
///
⋮----
/// ```
/// let layer = SingleEffectBuilder::new(painter, shade)
⋮----
/// let layer = SingleEffectBuilder::new(painter, shade)
///     .with_size(800, 600)
⋮----
///     .with_size(800, 600)
///     .with_bindings(vec![(0, some_binding)])
⋮----
///     .with_bindings(vec![(0, some_binding)])
///     .with_clear_color(wgpu::Color::BLACK)
⋮----
///
pub struct SingleEffectLayerBuilder<'a> {
⋮----
pub struct SingleEffectLayerBuilder<'a> {
⋮----
// Effect properties
⋮----
// Layer properties
⋮----
pub fn new(painter: &'a mut Painter, shade: Shade) -> Self {
⋮----
let (painter, props) = self.into_layer_props();
⋮----
/// Creates a layer and immediately initializes its GPU pipelines.
	///
⋮----
///
	/// Layers created during app initialization are initialized automatically,
⋮----
/// Layers created during app initialization are initialized automatically,
	/// so they can use `create`. Runtime-created layers must either call
⋮----
/// so they can use `create`. Runtime-created layers must either call
	/// `Layer::init_gpu_pipelines` manually or use this helper instead.
⋮----
/// `Layer::init_gpu_pipelines` manually or use this helper instead.
	pub fn create_and_init(self) -> Layer {
⋮----
layer.init_gpu_pipelines(painter);
⋮----
// Effect builder methods
⋮----
self.effect_bindings = bindings.into_iter().collect();
⋮----
self.effect_layers = layers.into_iter().collect();
⋮----
/// Repeatedly render this effect multiple times with different bindings into the same target without target swapping.
	/// This is useful for example for deferred lighting, where each light is rendered with custom blend state on top of the last.
⋮----
/// This is useful for example for deferred lighting, where each light is rendered with custom blend state on top of the last.
	pub fn with_instances(mut self, instances: Vec<InstanceBinding>) -> Self {
⋮----
pub fn with_instances(mut self, instances: Vec<InstanceBinding>) -> Self {
⋮----
pub fn with_blend_state(mut self, blend_state: wgpu::BlendState) -> Self {
⋮----
pub fn with_mip_target(mut self, dst_mip_level: u32) -> Self {
self.dst_mip_level = Some(dst_mip_level);
⋮----
pub fn with_mip_source(mut self, src_mip_level: u32) -> Self {
self.src_mip_level = Some(src_mip_level);
⋮----
// Layer builder methods
⋮----
self.format = Some(format);
⋮----
self.clear_color = Some(color);
⋮----
self.mips = Some(MipMapCount::Full);
⋮----
self.mips = Some(MipMapCount::Max(max));
⋮----
fn into_layer_props(self) -> (&'a mut Painter, LayerProps<'a>) {
⋮----
effects: vec![effect],
</file>

</files>
